# Component Development Formula v1.0
#
# Specification-driven component development using System Modeling Quad pattern
# (.spec.md + .model.lisp + .test.js + .js)
#
# Supports both team-based parallel development and solo sequential development
# with first-class artifact tracking and validation.
#
# Usage:
# ```bash
# bd mol wisp component-dev \
#   --var component_name="MessageRouter" \
#   --var component_type="message-handler" \
#   --var development_mode="team" \
#   --var validation_level="standard" \
#   --var output_dir="src/components"
# ```

formula = "component-dev"
description = """
Specification-driven component development workflow using System Modeling Quad.

Creates four synchronized artifacts:
1. .spec.md - Human-readable specification (dev-spec-modeler)
2. .model.lisp - Formal DSL model (dev-spec-modeler)
3. .test.js - Specification-based tests (dev-tester, isolated)
4. .js - Specification-compliant implementation (dev-coder, isolated)

Coordination: Team mode uses parallel isolated development with third-party validation.
Solo mode uses sequential development by single agent.

Result: Complete validated component with comprehensive specifications and tests.
"""
type = "workflow"
version = 1

# =============================================================================
# Variables: Formula Parameterization
# =============================================================================

[vars.component_name]
description = "Name of component to develop (e.g., 'MessageRouter')"
required = true

[vars.component_type]
description = "Component type for DSL foundation selection"
default = "message-handler"
options = ["message-handler", "state-machine", "data-processor", "service-provider", "integration-adapter"]

[vars.development_mode]
description = "Development mode: team (parallel isolated) or solo (sequential)"
default = "team"
options = ["team", "solo"]

[vars.validation_level]
description = "Validation thoroughness: standard or strict"
default = "standard"
options = ["standard", "strict"]

[vars.output_dir]
description = "Directory for component output (e.g., 'src/components')"
required = true

[vars.requirements]
description = "Component requirements (user-provided or from analysis)"
required = true

# =============================================================================
# Quality Gates: Measurable Success Criteria
# =============================================================================

[quality_gates.standard]
test_pass_rate_min = 95
coverage_min = 90
spec_compliance_min = 100
require_user_approval = true

[quality_gates.strict]
test_pass_rate_min = 100
coverage_min = 100
spec_compliance_min = 100
performance_validation = true
security_scan = true
require_user_approval = true

# =============================================================================
# Epic: Parent for all development work
# =============================================================================

[[steps]]
id = "epic"
title = "Develop {{component_name}} component with System Modeling Quad"
description = """
Complete specification-driven development of {{component_name}}.

Goal: Create production-ready component with:
- Comprehensive specifications (spec.md + model.lisp)
- Specification-based tests (test.js)
- Compliant implementation (js)
- Independent validation and approval

Development mode: {{development_mode}}
Validation level: {{validation_level}}
"""

# =============================================================================
# Phase 1: Specification Architecture (P0)
# Agent: @agent-dev-spec-modeler
# Outputs: .spec.md + .model.lisp
# =============================================================================

[[steps]]
id = "specifications"
title = "Create or verify specifications for {{component_name}}"
needs = ["epic"]
agent = "@agent-dev-spec-modeler"
description = """
Create comprehensive specifications for {{component_name}}:

Requirements: {{requirements}}
Component Type: {{component_type}}
Output Directory: {{output_dir}}

VERIFY FIRST: Read existing {{component_name}}.spec.md and {{component_name}}.model.lisp
Compare against current requirements
ONLY UPDATE IF NECESSARY

Agent workflow:
1. Analyze requirements and extract component intent
2. Check for existing specifications
3. Create or update specifications as needed
4. Present specifications for user approval
5. Wait for explicit approval before marking complete
"""

# Artifact tracking for this step
[[steps.outputs]]
artifact = "{{component_name}}.spec.md"
path = "{{output_dir}}/{{component_name}}.spec.md"
type = "documentation"
required = true
description = "Human-readable specification with overview, features, usage, integration"
validation = [
  "File exists",
  "Contains all required sections: Overview, Features, Usage Examples, Integration",
  "Intent clearly stated",
  "All features documented with examples"
]

[[steps.outputs]]
artifact = "{{component_name}}.model.lisp"
path = "{{output_dir}}/{{component_name}}.model.lisp"
type = "formal-spec"
required = true
description = "Formal DSL model following System Modeling Protocol"
validation = [
  "File exists",
  "Valid Lisp syntax",
  "Contains :state-schema with required fields",
  "Contains :accepts with at least one message type",
  "FSM defined if component_type requires state transitions"
]

[[steps.quality_gates]]
gate = "user_approval"
description = "User must approve specifications before parallel development"
blocking = true

# =============================================================================
# Phase 2a: Test Suite Development (P0) - Team Mode Only
# Agent: @agent-dev-tester
# Outputs: .test.js
# Runs in parallel with implementation (isolation enforced)
# =============================================================================

[[steps]]
id = "test-suite"
title = "Create specification-based test suite"
needs = ["specifications"]
agent = "@agent-dev-tester"
parallel_with = ["implementation"]
isolation = true
condition = "development_mode == 'team'"
description = """
Create comprehensive test suite from specifications ONLY:

Input Specifications:
- {{output_dir}}/{{component_name}}.spec.md
- {{output_dir}}/{{component_name}}.model.lisp

CRITICAL CONSTRAINTS:
- NEVER access implementation file
- NEVER coordinate with @agent-dev-coder
- Tests MUST fail when dependencies missing - NO skipping
- Test the contract, not implementation details

Agent workflow:
1. Read and analyze specifications (spec.md + model.lisp)
2. Extract all testable requirements
3. Design test structure by specification categories
4. Implement comprehensive test suite
5. Verify quality checklist completion
6. Commit: `git add {{output_dir}}/{{component_name}}.test.js && git commit -m "feat: Add tests for {{component_name}}"`
7. Close bead: `bd close <bead-id>`
"""

[[steps.outputs]]
artifact = "{{component_name}}.test.js"
path = "{{output_dir}}/{{component_name}}.test.js"
type = "test-suite"
required = true
description = "Comprehensive test suite validating all specification requirements"
validation = [
  "File exists",
  "Every requirement from spec.md has a test",
  "Every element from model.lisp is validated",
  "No implementation details assumed",
  "Tests are based purely on specifications",
  "NO test skipping (conditional returns, silent warnings)",
  "Proper test documentation linking to specs"
]

# =============================================================================
# Phase 2b: Implementation Development (P0) - Team Mode Only
# Agent: @agent-dev-coder
# Outputs: .js
# Runs in parallel with test-suite (isolation enforced)
# =============================================================================

[[steps]]
id = "implementation"
title = "Create specification-compliant implementation"
needs = ["specifications"]
agent = "@agent-dev-coder"
parallel_with = ["test-suite"]
isolation = true
condition = "development_mode == 'team'"
description = """
Create specification-compliant implementation from specifications ONLY:

Input Specifications:
- {{output_dir}}/{{component_name}}.spec.md
- {{output_dir}}/{{component_name}}.model.lisp

CRITICAL CONSTRAINTS:
- NEVER access test file
- NEVER coordinate with @agent-dev-tester
- Implement specification exactly as defined
- All state fields from state-schema initialized
- All message types handled

Agent workflow:
1. Read and analyze specifications (spec.md + model.lisp)
2. Design implementation structure matching specs
3. Implement complete specification-compliant component
4. Verify quality checklist completion
5. Commit: `git add {{output_dir}}/{{component_name}}.js && git commit -m "feat: Implement {{component_name}}"`
6. Close bead: `bd close <bead-id>`
"""

[[steps.outputs]]
artifact = "{{component_name}}.js"
path = "{{output_dir}}/{{component_name}}.js"
type = "implementation"
required = true
description = "Working implementation satisfying all specification requirements"
validation = [
  "File exists",
  "All state fields from state-schema initialized",
  "All message types from :accepts are handled",
  "All validation rules enforced",
  "FSM logic correctly implemented (if applicable)",
  "Integration contracts satisfied",
  "No TODO or FIXME comments in production code"
]

# =============================================================================
# Phase 2c: Solo Development (P0) - Solo Mode Only
# Agent: @agent-dev-solo
# Outputs: .test.js + .js (sequential)
# Alternative to parallel team development
# =============================================================================

[[steps]]
id = "solo-development"
title = "Complete test and implementation development (sequential)"
needs = ["specifications"]
agent = "@agent-dev-solo"
condition = "development_mode == 'solo'"
description = """
Continue from Phase 3 with completed specifications:

Input Specifications:
- {{output_dir}}/{{component_name}}.spec.md
- {{output_dir}}/{{component_name}}.model.lisp

Development approach: Sequential (tests first, then implementation)

Agent workflow:
1. Start from Phase 3 of solo workflow (specs already created)
2. Create test suite from specifications
3. Create implementation from specifications
4. Run tests and iterate until passing
5. Commit both files
6. Close bead: `bd close <bead-id>`
"""

[[steps.outputs]]
artifact = "{{component_name}}.test.js"
path = "{{output_dir}}/{{component_name}}.test.js"
type = "test-suite"
required = true
description = "Test suite created sequentially before implementation"
validation = [
  "File exists",
  "Complete specification coverage",
  "NO test skipping"
]

[[steps.outputs]]
artifact = "{{component_name}}.js"
path = "{{output_dir}}/{{component_name}}.js"
type = "implementation"
required = true
description = "Implementation created after tests, validated by test execution"
validation = [
  "File exists",
  "All specification requirements satisfied",
  "Tests pass"
]

# =============================================================================
# Phase 3: Independent Validation (P0)
# Agent: @agent-dev-validator
# Inputs: All 4 files from System Modeling Quad
# Outputs: Validation report
# =============================================================================

[[steps]]
id = "validation"
title = "Validate all artifacts against specifications"
needs = ["test-suite", "implementation", "solo-development"]
needs_any = true  # Either parallel completion OR solo completion
agent = "@agent-dev-validator"
description = """
Independent third-party validation of all development artifacts:

Files to Validate:
- {{output_dir}}/{{component_name}}.spec.md (specification)
- {{output_dir}}/{{component_name}}.model.lisp (formal model)
- {{output_dir}}/{{component_name}}.test.js (tests)
- {{output_dir}}/{{component_name}}.js (implementation)

Validation Level: {{validation_level}}

CRITICAL CONSTRAINTS:
- Cannot modify any files
- Cannot auto-approve results
- Must report all discrepancies
- Must require user approval

Validation process:
1. Specification analysis (extract all requirements)
2. Test suite validation (coverage, quality, structure)
3. Implementation validation (interface, state, messages)
4. Cross-validation (run tests, analyze results)
5. Report generation (comprehensive findings)

Agent workflow:
1. Read all 4 files
2. Build validation checklist from specifications
3. Validate test coverage and quality
4. Validate implementation compliance
5. Run test suite: `bun test {{output_dir}}/{{component_name}}.test.js`
6. Analyze test failures and categorize
7. Generate comprehensive validation report
8. Present report to user for decision
9. Wait for user approval (APPROVE/REQUEST_FIXES/RESTART)
10. Close bead based on decision: `bd close <bead-id>`
"""

# Validation reads existing artifacts
[[steps.inputs]]
artifact = "{{component_name}}.spec.md"
path = "{{output_dir}}/{{component_name}}.spec.md"
type = "documentation"
required = true

[[steps.inputs]]
artifact = "{{component_name}}.model.lisp"
path = "{{output_dir}}/{{component_name}}.model.lisp"
type = "formal-spec"
required = true

[[steps.inputs]]
artifact = "{{component_name}}.test.js"
path = "{{output_dir}}/{{component_name}}.test.js"
type = "test-suite"
required = true

[[steps.inputs]]
artifact = "{{component_name}}.js"
path = "{{output_dir}}/{{component_name}}.js"
type = "implementation"
required = true

# Validation produces report
[[steps.outputs]]
artifact = "{{component_name}}-validation-report.md"
path = "{{output_dir}}/{{component_name}}-validation-report.md"
type = "validation-report"
required = true
description = "Comprehensive validation report with findings and recommendations"
validation = [
  "File exists",
  "Specification compliance analysis complete",
  "Test coverage analysis complete",
  "Implementation compliance analysis complete",
  "Test execution results included",
  "All discrepancies categorized",
  "Specific recommendations provided",
  "User decision recorded (APPROVE/REQUEST_FIXES/RESTART)"
]

[[steps.quality_gates]]
gate = "validation_thresholds"
description = "Validation must meet quality thresholds for {{validation_level}} level"
blocking = true
thresholds = "quality_gates.{{validation_level}}"

[[steps.quality_gates]]
gate = "user_approval"
description = "User must approve validation results"
blocking = true

# =============================================================================
# Phase 4a: Resolution - Approved (P1)
# Finalize and integrate approved component
# =============================================================================

[[steps]]
id = "resolution-approved"
title = "Finalize and integrate approved component"
needs = ["validation"]
condition = "validation_result == 'APPROVED'"
description = """
Component approved - finalize and integrate:

Artifacts:
- {{output_dir}}/{{component_name}}.spec.md ✓
- {{output_dir}}/{{component_name}}.model.lisp ✓
- {{output_dir}}/{{component_name}}.test.js ✓
- {{output_dir}}/{{component_name}}.js ✓

Tasks:
1. Archive specifications as authoritative
2. Add component to integration tests
3. Update component registry
4. Generate usage documentation
5. Document lessons learned

**Component development complete!**
"""

[[steps.outputs]]
artifact = "{{component_name}}-integration.md"
path = "{{output_dir}}/{{component_name}}-integration.md"
type = "documentation"
required = true
description = "Integration guide and usage documentation"
validation = [
  "File exists",
  "Usage examples included",
  "Integration patterns documented",
  "Component registry updated"
]

# =============================================================================
# Phase 4b: Resolution - Fixes Required (P1)
# Apply targeted fixes based on validation findings
# =============================================================================

[[steps]]
id = "resolution-fixes"
title = "Apply fixes based on validation findings"
needs = ["validation"]
condition = "validation_result == 'REQUEST_FIXES'"
description = """
Validation identified issues - apply targeted fixes:

Root cause analysis:
- Specification ambiguity → Re-run @agent-dev-spec-modeler
- Test issues → Re-run @agent-dev-tester
- Implementation issues → Re-run @agent-dev-coder

Process:
1. Identify root cause from validation report
2. Re-launch specific agent(s) with corrections
3. Return to Phase 3 (validation)
4. Iterate until user approval

Note: May require multiple iterations
"""

# =============================================================================
# Phase 4c: Resolution - Restart (P1)
# Restart from specifications with updated requirements
# =============================================================================

[[steps]]
id = "resolution-restart"
title = "Restart from specifications with updated requirements"
needs = ["validation"]
condition = "validation_result == 'RESTART'"
description = """
Fundamental issues require specification redesign:

Process:
1. Analyze validation report for root causes
2. Update requirements based on findings
3. Return to Phase 1 (specifications)
4. Apply lessons learned to prevent recurring issues

Note: This restarts the entire workflow
"""

# =============================================================================
# Workflow Metrics: Observable Outcomes
# =============================================================================

[metrics]
phase_1_duration = "Time from epic creation to specifications approval"
phase_2_duration = "Time from specifications approval to parallel development completion"
phase_3_duration = "Time from development completion to validation completion"
phase_4_duration = "Time from validation to final resolution"
total_duration = "Time from epic creation to resolution"
iteration_count = "Number of validation cycles required"
first_pass_rate = "Percentage approved without fixes"

[metrics.quality]
spec_approval_rate = "Percentage of specifications approved on first review"
test_pass_rate = "Percentage of tests passing on first run"
validation_issues_count = "Number of discrepancies found in validation"
spec_compliance_score = "Percentage of specification requirements satisfied"

[metrics.artifacts]
spec_completeness = "Percentage of required specification sections complete"
test_coverage = "Percentage of specification requirements covered by tests"
implementation_completeness = "Percentage of specification features implemented"
