% ============================================================================
% Actor System - Datalog Facts and Rules
% ============================================================================
% Formal specification of actor system properties using Datalog
% Based on Hewitt Actor Model implementation in tk-agents

% ============================================================================
% 1. STRUCTURAL PROPERTIES
% ============================================================================

% actor(ID, Type) - An actor exists with given ID and type
% Type âˆˆ {deterministic, agent}
actor(ID, Type) :- actor_exists(ID), actor_type(ID, Type).

% Core actor properties
actor_type(ActorID, deterministic) :- deterministic_actor(ActorID).
actor_type(ActorID, agent) :- agent_actor(ActorID).

% Every actor has a receive method (public interface)
has_receive(ActorID) :- actor(ActorID, _).

% Some actors have optional methods
has_stream(ActorID) :- actor_supports_streaming(ActorID).
has_start(ActorID) :- actor_supports_lifecycle(ActorID).
has_stop(ActorID) :- actor_supports_lifecycle(ActorID).

% ============================================================================
% 2. SUPERVISION HIERARCHY
% ============================================================================

% supervises(SupervisorID, ActorID) - Supervisor manages Actor
supervises(SupervisorID, ActorID) :-
    actor(SupervisorID, _),
    actor(ActorID, _),
    registered_in(ActorID, SupervisorID).

% System is a special actor that can supervise other actors
is_system(ActorID) :- actor_type(ActorID, deterministic), actor_id(ActorID, "system").

% System supervises all registered actors
supervises("system", ActorID) :- registered_in(ActorID, "system").

% Transitive supervision (supervisor of supervisor)
supervises_transitively(SupervisorID, ActorID) :- supervises(SupervisorID, ActorID).
supervises_transitively(SupervisorID, ActorID) :-
    supervises(SupervisorID, IntermediateID),
    supervises_transitively(IntermediateID, ActorID).

% Root supervisor (supervises others but is not supervised)
root_supervisor(ActorID) :-
    supervises(ActorID, _),
    \+ supervised_by(ActorID, _).

% Leaf actor (supervised but doesn't supervise others)
leaf_actor(ActorID) :-
    supervised_by(ActorID, _),
    \+ supervises(ActorID, _).

% Helper predicates
supervised_by(ActorID, SupervisorID) :- supervises(SupervisorID, ActorID).
registered_in(ActorID, SystemID) :- actor_registered(ActorID, SystemID).

% ============================================================================
% 3. MESSAGE PASSING RULES
% ============================================================================

% message(ID, Type, Payload, Sender)
message(MsgID, Type, Payload, Sender) :-
    message_exists(MsgID),
    message_type(MsgID, Type),
    message_payload(MsgID, Payload),
    message_sender(MsgID, Sender).

% Actor can receive message of type T
can_receive(ActorID, MessageType) :-
    actor(ActorID, _),
    handles_message_type(ActorID, MessageType).

% All actors can receive ping messages
can_receive(ActorID, "ping") :- actor(ActorID, _).

% System can receive management messages
can_receive(SystemID, "register") :- is_system(SystemID).
can_receive(SystemID, "unregister") :- is_system(SystemID).
can_receive(SystemID, "list") :- is_system(SystemID).
can_receive(SystemID, "route") :- is_system(SystemID).

% Actor can send message to another actor
can_send_to(SenderID, ReceiverID, MessageType) :-
    actor(SenderID, _),
    actor(ReceiverID, _),
    can_receive(ReceiverID, MessageType),
    coordinating_actor(SenderID).

% Coordinating actors can send messages (have system reference)
coordinating_actor(ActorID) :- has_system_reference(ActorID).

% System routes messages between actors
routes_message(SystemID, FromID, ToID, MessageType) :-
    is_system(SystemID),
    supervises(SystemID, FromID),
    supervises(SystemID, ToID),
    can_send_to(FromID, ToID, MessageType).

% Message causality (message M2 caused by message M1)
caused_by(M2, M1) :-
    message(M1, _, _, Sender),
    message(M2, _, _, Sender),
    message_correlation(M2, M1).

% ============================================================================
% 4. BEHAVIORAL INVARIANTS
% ============================================================================

% Invariant: System always responds to ping
must_respond_to_ping(SystemID) :- is_system(SystemID).

% Invariant: All actors respond to ping
must_respond_to_ping(ActorID) :- actor(ActorID, _).

% Invariant: Response has correct structure
valid_response(Response) :-
    has_success_field(Response),
    (response_success(Response) -> has_data_field(Response) ; has_error_field(Response)).

% Invariant: System routes only to registered actors
can_route(SystemID, TargetID) :-
    is_system(SystemID),
    registered_in(TargetID, SystemID).

% Invariant: Actors cannot send without system reference
cannot_send_without_system(ActorID) :-
    actor(ActorID, _),
    \+ has_system_reference(ActorID),
    \+ is_system(ActorID).

% Invariant: Messages preserve sender information
message_has_sender(MsgID) :-
    message(MsgID, _, _, Sender),
    Sender \= undefined.

% Invariant: Coordinating actors are registered with system
coordinating_actor_registered(ActorID) :-
    coordinating_actor(ActorID),
    registered_in(ActorID, SystemID),
    is_system(SystemID).

% Invariant: Supervision is acyclic (no actor supervises itself)
supervision_acyclic :-
    \+ supervises_transitively(ActorID, ActorID).

% Invariant: Every registered actor is reachable from root supervisor
actor_reachable(ActorID) :-
    actor(ActorID, _),
    (root_supervisor(ActorID) ;
     (root_supervisor(RootID), supervises_transitively(RootID, ActorID))).

% ============================================================================
% 5. DERIVED PREDICATES
% ============================================================================

% Actor depth in supervision tree
actor_depth(ActorID, 0) :- root_supervisor(ActorID).
actor_depth(ActorID, Depth) :-
    supervised_by(ActorID, SupervisorID),
    actor_depth(SupervisorID, SupervisorDepth),
    Depth is SupervisorDepth + 1.

% Count supervised actors
supervises_count(SupervisorID, Count) :-
    supervises(SupervisorID, _),
    aggregate_all(count, supervises(SupervisorID, _), Count).
supervises_count(SupervisorID, 0) :-
    actor(SupervisorID, _),
    \+ supervises(SupervisorID, _).

% Message flow path (chain of messages)
message_path(FromID, ToID, [FromID, ToID]) :- can_send_to(FromID, ToID, _).
message_path(FromID, ToID, [FromID | Rest]) :-
    can_send_to(FromID, IntermediateID, _),
    message_path(IntermediateID, ToID, Rest).

% ============================================================================
% 6. CONSISTENCY RULES
% ============================================================================

% No actor can have two different types
:- actor_type(ActorID, Type1), actor_type(ActorID, Type2), Type1 \= Type2.

% No actor can be registered in two systems simultaneously
:- registered_in(ActorID, System1), registered_in(ActorID, System2), System1 \= System2.

% System cannot supervise itself
:- is_system(SystemID), supervises(SystemID, SystemID).

% Message sender must be a valid actor or external source
:- message(_, _, _, Sender), Sender \= "external", \+ actor(Sender, _).

% ============================================================================
% 7. EXAMPLE FACTS (For Testing)
% ============================================================================

% Example actor instances
actor_exists("system").
actor_exists("echo-1").
actor_exists("coordinator").
actor_exists("worker-1").
actor_exists("worker-2").

% Actor types
deterministic_actor("system").
deterministic_actor("echo-1").
deterministic_actor("coordinator").
deterministic_actor("worker-1").
deterministic_actor("worker-2").

% Actor IDs
actor_id("system", "system").
actor_id("echo-1", "echo-1").
actor_id("coordinator", "coordinator").
actor_id("worker-1", "worker-1").
actor_id("worker-2", "worker-2").

% Registration relationships
actor_registered("echo-1", "system").
actor_registered("coordinator", "system").
actor_registered("worker-1", "system").
actor_registered("worker-2", "system").

% System references (for coordinating actors)
has_system_reference("coordinator").

% Message type handlers
handles_message_type("echo-1", "echo").
handles_message_type("coordinator", "coordinate").
handles_message_type("worker-1", "work").
handles_message_type("worker-2", "work").

% Example messages
message_exists("msg-1").
message_type("msg-1", "echo").
message_payload("msg-1", "Hello").
message_sender("msg-1", "external").

message_exists("msg-2").
message_type("msg-2", "coordinate").
message_payload("msg-2", "Task for workers").
message_sender("msg-2", "external").

% ============================================================================
% 8. QUERIES (Examples)
% ============================================================================

% Query: Find all actors supervised by system
% ?- supervises("system", ActorID).

% Query: Find root supervisors
% ?- root_supervisor(ActorID).

% Query: Can actor X send message type T to actor Y?
% ?- can_send_to("coordinator", "worker-1", "work").

% Query: What is the depth of actor X in the supervision tree?
% ?- actor_depth("worker-1", Depth).

% Query: Find all message paths from X to Y
% ?- message_path("coordinator", "worker-1", Path).

% Query: Verify supervision is acyclic
% ?- supervision_acyclic.

% Query: Find all actors that can receive message type T
% ?- can_receive(ActorID, "ping").

% Query: Find all coordinating actors
% ?- coordinating_actor(ActorID).

% ============================================================================
% END
% ============================================================================
