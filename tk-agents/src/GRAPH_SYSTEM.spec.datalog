% ============================================================================
% Graph System Specification - Formal Verification Model
% ============================================================================
% This Datalog specification captures the behavioral requirements and
% invariants of the Graph System for programmatic verification.
%
% The Graph System bridges string-based external interfaces with the
% actor-based internal messaging system, providing bidirectional mapping
% between string IDs and Address objects.

% ============================================================================
% 1. CORE ENTITIES
% ============================================================================

% Graphs exist in the system
graph_exists(GraphID).

% Nodes exist within a graph
node_exists(GraphID, NodeID).

% Edges exist within a graph
edge_exists(GraphID, EdgeID).

% Actor system exists within a graph
system_exists(GraphID, SystemID) :-
    graph_exists(GraphID),
    owns_system(GraphID, SystemID).

% Addresses are internal actor references
address_exists(AddressID).

% Node properties are cached
properties_exist(GraphID, NodeID) :-
    node_exists(GraphID, NodeID).

% ============================================================================
% 2. DUAL IDENTITY MODEL
% ============================================================================

% Every node has a string ID (external)
has_string_id(GraphID, NodeID, StringID) :-
    node_exists(GraphID, NodeID),
    is_string(StringID).

% Every node has an address (internal)
has_address(GraphID, NodeID, AddressID) :-
    node_exists(GraphID, NodeID),
    address_exists(AddressID),
    maps_to_address(GraphID, NodeID, AddressID).

% Bidirectional mapping: string ID <-> address
bidirectional_mapping(GraphID, StringID, AddressID) :-
    has_string_id(GraphID, NodeID, StringID),
    has_address(GraphID, NodeID, AddressID).

% INVARIANT: String ID uniquely identifies node within graph
string_id_unique(GraphID) :-
    forall(
        (has_string_id(GraphID, N1, S), has_string_id(GraphID, N2, S)),
        N1 = N2
    ).

% ============================================================================
% 3. NODE REGISTRATION
% ============================================================================

% Registration creates both mappings
registration_creates_mappings(GraphID, NodeID, StringID, AddressID, Props) :-
    register_node(GraphID, StringID, AddressID, Props),
    has_string_id(GraphID, NodeID, StringID),
    has_address(GraphID, NodeID, AddressID),
    has_properties(GraphID, NodeID, Props).

% Properties are cached at registration
has_properties(GraphID, NodeID, Props) :-
    node_exists(GraphID, NodeID),
    property_cache(GraphID, NodeID, Props).

% Registration requires unique string ID
can_register(GraphID, StringID) :-
    graph_exists(GraphID),
    \+ has_string_id(GraphID, _, StringID).

% INVARIANT: After registration, node has both string ID and address
registration_complete(GraphID, NodeID) :-
    node_exists(GraphID, NodeID),
    has_string_id(GraphID, NodeID, _),
    has_address(GraphID, NodeID, _),
    has_properties(GraphID, NodeID, _).

% ============================================================================
% 4. MESSAGE ROUTING
% ============================================================================

% Send via graph (external API)
graph_send(GraphID, StringID, MessageType, Payload) :-
    graph_exists(GraphID),
    has_string_id(GraphID, NodeID, StringID),
    has_address(GraphID, NodeID, AddressID),
    routes_to_address(GraphID, AddressID, MessageType, Payload).

% Graph looks up address for string ID
routes_to_address(GraphID, AddressID, MessageType, Payload) :-
    address_exists(AddressID),
    forwards_message(AddressID, MessageType, Payload).

% Message forwarded to actor
forwards_message(AddressID, MessageType, Payload) :-
    address_exists(AddressID),
    actor_receives(AddressID, MessageType, Payload).

% INVARIANT: Graph.send produces same result as Address.send
routing_equivalence(GraphID, StringID, Message) :-
    has_address(GraphID, _, AddressID),
    has_string_id(GraphID, _, StringID),
    bidirectional_mapping(GraphID, StringID, AddressID),
    result_equal(graph_send(GraphID, StringID, Message),
                 address_send(AddressID, Message)).

% ============================================================================
% 5. NODE OPERATIONS
% ============================================================================

% Get node address by string ID
get_node(GraphID, StringID, AddressID) :-
    has_string_id(GraphID, NodeID, StringID),
    has_address(GraphID, NodeID, AddressID).

% Get node properties by string ID
get_properties(GraphID, StringID, Props) :-
    has_string_id(GraphID, NodeID, StringID),
    has_properties(GraphID, NodeID, Props).

% Get all node IDs
get_all_node_ids(GraphID, StringIDs) :-
    graph_exists(GraphID),
    findall(S, has_string_id(GraphID, _, S), StringIDs).

% Remove node operation
remove_node(GraphID, StringID) :-
    has_string_id(GraphID, NodeID, StringID),
    remove_connected_edges(GraphID, StringID),
    retract(node_exists(GraphID, NodeID)),
    retract(has_string_id(GraphID, NodeID, StringID)),
    retract(has_address(GraphID, NodeID, _)),
    retract(has_properties(GraphID, NodeID, _)).

% ============================================================================
% 6. EDGE OPERATIONS
% ============================================================================

% Edge structure
edge_connects(GraphID, EdgeID, FromID, ToID, EdgeType) :-
    edge_exists(GraphID, EdgeID),
    edge_from(GraphID, EdgeID, FromID),
    edge_to(GraphID, EdgeID, ToID),
    edge_type(GraphID, EdgeID, EdgeType).

% Edge types enumeration
valid_edge_type(depends_on).
valid_edge_type(requires_knowledge).
valid_edge_type(produces).
valid_edge_type(spawned_by).
valid_edge_type(blocks).
valid_edge_type(references).

% Add edge operation
add_edge(GraphID, FromID, ToID, EdgeType, Props, EdgeID) :-
    graph_exists(GraphID),
    valid_edge_type(EdgeType),
    next_edge_id(GraphID, EdgeID),
    assert(edge_exists(GraphID, EdgeID)),
    assert(edge_from(GraphID, EdgeID, FromID)),
    assert(edge_to(GraphID, EdgeID, ToID)),
    assert(edge_type(GraphID, EdgeID, EdgeType)),
    assert(edge_properties(GraphID, EdgeID, Props)).

% Edge ID generation
next_edge_id(GraphID, EdgeID) :-
    edge_counter(GraphID, Counter),
    NewCounter is Counter + 1,
    retract(edge_counter(GraphID, Counter)),
    assert(edge_counter(GraphID, NewCounter)),
    atom_concat('edge_', NewCounter, EdgeID).

% Remove edge operation
remove_edge(GraphID, EdgeID) :-
    edge_exists(GraphID, EdgeID),
    retract(edge_exists(GraphID, EdgeID)),
    retract(edge_from(GraphID, EdgeID, _)),
    retract(edge_to(GraphID, EdgeID, _)),
    retract(edge_type(GraphID, EdgeID, _)),
    retract(edge_properties(GraphID, EdgeID, _)).

% Get edges from node
get_edges_from(GraphID, NodeID, Edges) :-
    findall(E, edge_from(GraphID, E, NodeID), Edges).

% Get edges to node
get_edges_to(GraphID, NodeID, Edges) :-
    findall(E, edge_to(GraphID, E, NodeID), Edges).

% Get all edges for node
get_all_edges(GraphID, NodeID, Edges) :-
    get_edges_from(GraphID, NodeID, FromEdges),
    get_edges_to(GraphID, NodeID, ToEdges),
    append(FromEdges, ToEdges, AllEdges),
    sort(AllEdges, Edges).

% Get child tasks (spawned_by edges to this node)
get_child_tasks(GraphID, TaskID, Children) :-
    findall(ChildID,
            (edge_type(GraphID, E, spawned_by),
             edge_to(GraphID, E, TaskID),
             edge_from(GraphID, E, ChildID)),
            Children).

% Remove all edges connected to a node
remove_connected_edges(GraphID, NodeID) :-
    forall(
        (edge_from(GraphID, E, NodeID); edge_to(GraphID, E, NodeID)),
        remove_edge(GraphID, E)
    ).

% ============================================================================
% 7. EDGE TYPE SEMANTICS
% ============================================================================

% depends_on: Source needs target complete first
edge_semantic(depends_on, "Source task depends on target task completion").
dependency_relationship(GraphID, SourceID, TargetID) :-
    edge_connects(GraphID, _, SourceID, TargetID, depends_on).

% spawned_by: Child task created by parent
edge_semantic(spawned_by, "Source task was spawned by target task").
parent_child_relationship(GraphID, ChildID, ParentID) :-
    edge_connects(GraphID, _, ChildID, ParentID, spawned_by).

% requires_knowledge: Task needs knowledge node
edge_semantic(requires_knowledge, "Task requires knowledge to proceed").
knowledge_requirement(GraphID, TaskID, KnowledgeID) :-
    edge_connects(GraphID, _, TaskID, KnowledgeID, requires_knowledge).

% produces: Task produces artifact
edge_semantic(produces, "Task produces artifact as output").
production_relationship(GraphID, TaskID, ArtifactID) :-
    edge_connects(GraphID, _, TaskID, ArtifactID, produces).

% blocks: Source is blocking target
edge_semantic(blocks, "Source task is blocking target task").
blocking_relationship(GraphID, BlockerID, BlockedID) :-
    edge_connects(GraphID, _, BlockerID, BlockedID, blocks).

% references: General reference
edge_semantic(references, "General reference between nodes").
reference_relationship(GraphID, SourceID, TargetID) :-
    edge_connects(GraphID, _, SourceID, TargetID, references).

% ============================================================================
% 8. NODE TYPE PROPERTIES
% ============================================================================

% Node types enumeration
valid_node_type(task).
valid_node_type(knowledge).
valid_node_type(artifact).
valid_node_type(pattern).

% Task states enumeration
valid_task_state(created).
valid_task_state(ready).
valid_task_state(active).
valid_task_state(blocked).
valid_task_state(completed).
valid_task_state(failed).

% Node has type
node_has_type(GraphID, NodeID, Type) :-
    has_properties(GraphID, NodeID, Props),
    member(type-Type, Props),
    valid_node_type(Type).

% Task node
is_task_node(GraphID, NodeID) :-
    node_has_type(GraphID, NodeID, task).

% Knowledge node
is_knowledge_node(GraphID, NodeID) :-
    node_has_type(GraphID, NodeID, knowledge).

% ============================================================================
% 9. SERIALIZATION
% ============================================================================

% Dump operation - export state
dump_graph(GraphID, Snapshot) :-
    graph_exists(GraphID),
    findall(Props, has_properties(GraphID, _, Props), NodeProps),
    findall(edge(E, From, To, Type, EProps),
            (edge_exists(GraphID, E),
             edge_from(GraphID, E, From),
             edge_to(GraphID, E, To),
             edge_type(GraphID, E, Type),
             edge_properties(GraphID, E, EProps)),
            Edges),
    Snapshot = snapshot(NodeProps, Edges).

% Set edge counter for restoration
set_edge_counter(GraphID, Counter) :-
    graph_exists(GraphID),
    retractall(edge_counter(GraphID, _)),
    assert(edge_counter(GraphID, Counter)).

% CONSTRAINT: Addresses cannot be serialized (runtime only)
address_not_serializable(AddressID) :-
    address_exists(AddressID).

% Restoration requires factory recreation
requires_factory_recreation(Snapshot) :-
    Snapshot = snapshot(NodeProps, _),
    NodeProps \= [].

% ============================================================================
% 10. FORMAL INVARIANTS
% ============================================================================

% INVARIANT 1: Node ID Uniqueness
invariant_node_id_unique(GraphID) :-
    forall(
        (node_exists(GraphID, N1), node_exists(GraphID, N2),
         has_string_id(GraphID, N1, S), has_string_id(GraphID, N2, S)),
        N1 = N2
    ).

% INVARIANT 2: Bidirectional Mapping Consistency
invariant_bidirectional_consistent(GraphID) :-
    forall(
        node_exists(GraphID, NodeID),
        (has_string_id(GraphID, NodeID, _),
         has_address(GraphID, NodeID, _),
         has_properties(GraphID, NodeID, _))
    ).

% INVARIANT 3: Edge ID Uniqueness
invariant_edge_id_unique(GraphID) :-
    forall(
        (edge_exists(GraphID, E1), edge_exists(GraphID, E2), E1 \= E2),
        true  % Different edge IDs guaranteed by counter
    ).

% INVARIANT 4: Edge Counter Monotonicity
invariant_edge_counter_monotonic(GraphID, OldCounter, NewCounter) :-
    edge_counter(GraphID, OldCounter),
    NewCounter >= OldCounter.

% INVARIANT 5: Cascade Deletion
invariant_cascade_deletion(GraphID, NodeID) :-
    \+ node_exists(GraphID, NodeID),
    \+ edge_from(GraphID, _, NodeID),
    \+ edge_to(GraphID, _, NodeID).

% INVARIANT 6: Routing Equivalence
invariant_routing_equivalence(GraphID, StringID, AddressID) :-
    bidirectional_mapping(GraphID, StringID, AddressID).

% All invariants hold
all_invariants_hold(GraphID) :-
    invariant_node_id_unique(GraphID),
    invariant_bidirectional_consistent(GraphID),
    invariant_edge_id_unique(GraphID).

% ============================================================================
% 11. VERIFICATION QUERIES
% ============================================================================

% Query: Verify node ID uniqueness
% ?- invariant_node_id_unique(GraphID).

% Query: Verify bidirectional consistency
% ?- invariant_bidirectional_consistent(GraphID).

% Query: Find orphaned edges (edges to non-existent nodes)
% ?- find_orphaned_edges(GraphID, OrphanedEdges).
find_orphaned_edges(GraphID, OrphanedEdges) :-
    findall(E,
            (edge_exists(GraphID, E),
             (edge_from(GraphID, E, From), \+ has_string_id(GraphID, _, From));
             (edge_to(GraphID, E, To), \+ has_string_id(GraphID, _, To))),
            OrphanedEdges).

% Query: Verify all registered nodes are complete
% ?- all_nodes_complete(GraphID).
all_nodes_complete(GraphID) :-
    forall(node_exists(GraphID, N), registration_complete(GraphID, N)).

% Query: Find nodes without edges
% ?- find_isolated_nodes(GraphID, IsolatedNodes).
find_isolated_nodes(GraphID, IsolatedNodes) :-
    findall(N,
            (node_exists(GraphID, N),
             has_string_id(GraphID, N, S),
             \+ edge_from(GraphID, _, S),
             \+ edge_to(GraphID, _, S)),
            IsolatedNodes).

% Query: Check graph is well-formed
% ?- graph_well_formed(GraphID).
graph_well_formed(GraphID) :-
    graph_exists(GraphID),
    system_exists(GraphID, _),
    all_invariants_hold(GraphID).

% Query: Find dependency cycles
% ?- has_dependency_cycle(GraphID, Cycle).
has_dependency_cycle(GraphID, Cycle) :-
    dependency_relationship(GraphID, A, B),
    path_exists(GraphID, B, A, depends_on, Path),
    Cycle = [A|Path].

path_exists(GraphID, Start, End, EdgeType, [End]) :-
    edge_connects(GraphID, _, Start, End, EdgeType).
path_exists(GraphID, Start, End, EdgeType, [Next|Path]) :-
    edge_connects(GraphID, _, Start, Next, EdgeType),
    path_exists(GraphID, Next, End, EdgeType, Path).

% ============================================================================
% 12. EXAMPLE FACTS (for testing)
% ============================================================================

% Example graph
graph_exists("test-graph").
owns_system("test-graph", "test-system").
edge_counter("test-graph", 0).

% Example nodes
node_exists("test-graph", "node-1").
node_exists("test-graph", "node-2").
node_exists("test-graph", "node-3").

has_string_id("test-graph", "node-1", "task-1").
has_string_id("test-graph", "node-2", "task-2").
has_string_id("test-graph", "node-3", "knowledge-1").

address_exists("addr-1").
address_exists("addr-2").
address_exists("addr-3").

maps_to_address("test-graph", "node-1", "addr-1").
maps_to_address("test-graph", "node-2", "addr-2").
maps_to_address("test-graph", "node-3", "addr-3").

property_cache("test-graph", "node-1", [id-"task-1", type-task, state-created]).
property_cache("test-graph", "node-2", [id-"task-2", type-task, state-blocked]).
property_cache("test-graph", "node-3", [id-"knowledge-1", type-knowledge]).

% Example edges
edge_exists("test-graph", "edge_1").
edge_from("test-graph", "edge_1", "task-2").
edge_to("test-graph", "edge_1", "task-1").
edge_type("test-graph", "edge_1", depends_on).
edge_properties("test-graph", "edge_1", [reason-"prerequisite"]).

edge_exists("test-graph", "edge_2").
edge_from("test-graph", "edge_2", "task-2").
edge_to("test-graph", "edge_2", "knowledge-1").
edge_type("test-graph", "edge_2", requires_knowledge).
edge_properties("test-graph", "edge_2", []).

% ============================================================================
% 13. COMPLETENESS CHECKS
% ============================================================================

% Check: All core operations are defined
operations_complete :-
    % Node operations
    clause(register_node(_, _, _, _), _),
    clause(remove_node(_, _), _),
    clause(get_node(_, _, _), _),
    clause(get_properties(_, _, _), _),
    clause(get_all_node_ids(_, _), _),
    % Edge operations
    clause(add_edge(_, _, _, _, _, _), _),
    clause(remove_edge(_, _), _),
    clause(get_edges_from(_, _, _), _),
    clause(get_edges_to(_, _, _), _),
    clause(get_all_edges(_, _, _), _),
    clause(get_child_tasks(_, _, _), _),
    % Serialization
    clause(dump_graph(_, _), _),
    clause(set_edge_counter(_, _), _).

% Check: All invariants are defined
invariants_complete :-
    clause(invariant_node_id_unique(_), _),
    clause(invariant_bidirectional_consistent(_), _),
    clause(invariant_edge_id_unique(_), _),
    clause(invariant_edge_counter_monotonic(_, _, _), _),
    clause(invariant_cascade_deletion(_, _), _),
    clause(invariant_routing_equivalence(_, _, _), _).

% Check: All node types covered
node_types_complete :-
    valid_node_type(task),
    valid_node_type(knowledge),
    valid_node_type(artifact),
    valid_node_type(pattern).

% Check: All edge types covered
edge_types_complete :-
    valid_edge_type(depends_on),
    valid_edge_type(requires_knowledge),
    valid_edge_type(produces),
    valid_edge_type(spawned_by),
    valid_edge_type(blocks),
    valid_edge_type(references).

% Full completeness check
specification_complete :-
    operations_complete,
    invariants_complete,
    node_types_complete,
    edge_types_complete.

% ============================================================================
% 14. INTEGRATION WITH ACTOR SYSTEM
% ============================================================================

% Graph owns and wraps actor system
owns_system(GraphID, SystemID) :-
    graph_exists(GraphID),
    system_created_by_graph(GraphID, SystemID).

% All messages route through system
message_routes_through_system(GraphID, StringID, Message) :-
    graph_send(GraphID, StringID, Message, _),
    system_exists(GraphID, SystemID),
    system_receives(SystemID, Message).

% Factory pattern integration
factory_creates_address(FactoryID, SystemID, AddressID) :-
    actor_factory(FactoryID),
    system_exists(_, SystemID),
    address_exists(AddressID).

% Graph stores address returned by factory
graph_stores_factory_result(GraphID, StringID, AddressID) :-
    factory_creates_address(_, _, AddressID),
    has_string_id(GraphID, NodeID, StringID),
    has_address(GraphID, NodeID, AddressID).

% ============================================================================
% END
% ============================================================================
