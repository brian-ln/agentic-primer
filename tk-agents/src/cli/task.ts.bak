#!/usr/bin/env bun

/**
 * Task CLI - Manage task graphs using the Graph/TaskNode system
 *
 * Commands:
 *   task init                              Create tasks.json
 *   task add <goal> [options]              Add a task
 *   task update <id> <action> [args]       Update task (start, complete, block)
 *   task delete <id> [--force]             Delete a task
 *   task list [--status] [--label] [--priority]  List tasks with optional filters
 *   task ready                             Show tasks with no blockers
 *   task show <id>                         Show task details
 *   task graph <id>                        Show dependency tree
 *   task eval <id>                         Evaluate task criteria
 *   task status <id>                       Show task status with blockers
 *   task search <query>                    Search tasks by keyword
 *   task dep add <from> <to> [--type]      Add dependency edge between tasks
 *   task dep remove <edge-id>              Remove dependency edge
 *   task dep list <task-id> [--dir]        List dependencies for a task
 *   task dep show <edge-id>                Show edge details
 */

import { Graph } from "../graph.ts";
import { TaskActor, type CreateTaskOptions, getTaskProperties } from "../task.ts";
import type { Edge, NodeProperties, ObjectiveCriterion, TaskProperties } from "../types.ts";
import { readFileSync, writeFileSync, existsSync } from "fs";
import { resolve } from "path";
import { DualWriteCoordinator, TaskQueryService, CozoReconciler } from "../dual-write-coordinator.ts";
import { EventLog } from "../persistence/event-log.ts";
import { CozoClient } from "../cozo-client.ts";
import { globalEventBus } from "../events/event-bus.ts";
import { EVENT_TYPES } from "../events/task-events.ts";

const TASKS_FILE = "tasks.json";
const EVENT_LOG_FILE = "data/task-events.jsonl";
const COZO_DB_URL = process.env.COZO_URL || "http://127.0.0.1:9070";

// Initialize global event log with EventBus integration
const eventLog = new EventLog(EVENT_LOG_FILE, globalEventBus);

// File format - matches Graph.dump() structure
interface TaskFile {
  nodes: NodeProperties[];
  edges: Edge[];
}

// JSON output format for machine-readable responses
interface JsonResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

// Global CLI options
interface CliOptions {
  json?: boolean;
  yes?: boolean;
  fields?: string[];
}

// Helper to output JSON response
function jsonOutput<T>(success: boolean, data?: T, error?: any): void {
  const response: JsonResponse<T> = { success };
  if (data !== undefined) response.data = data;
  if (error) response.error = error;
  console.log(JSON.stringify(response, null, 2));
}

// Helper to project specific fields from object
function projectFields<T extends object>(obj: T, fields: string[]): Partial<T> {
  const result: any = {};
  for (const field of fields) {
    if (field in obj) {
      result[field as keyof T] = obj[field as keyof T];
    }
  }
  return result;
}

// Initialize DualWriteCoordinator with all three systems
async function initializeCoordinator(filePath: string): Promise<{
  coordinator: DualWriteCoordinator;
  queryService: TaskQueryService;
  graph: Graph;
}> {
  const graph = await loadGraph(filePath);
  const cozoDB = new CozoClient(COZO_DB_URL);

  // Initialize CozoDB schema (idempotent)
  try {
    await cozoDB.run(`
      {:create work {
        id: String =>
        type: String,
        status: String,
        priority: Int?,
        title: String
      }}
    `);

    await cozoDB.run(`
      {:create dependencies {
        task: String,
        dep: String =>
      }}
    `);

    await cozoDB.run(`
      {:create task_labels {
        task: String,
        label: String =>
      }}
    `);
  } catch (error) {
    // Relations already exist, that's fine
  }

  const coordinator = new DualWriteCoordinator(graph, eventLog, cozoDB);
  const queryService = new TaskQueryService(cozoDB);

  return { coordinator, queryService, graph };
}

// Load tasks from file into Graph
async function loadGraph(filePath: string): Promise<Graph> {
  if (!existsSync(filePath)) {
    throw new Error(`Task file not found: ${filePath}`);
  }

  const content = readFileSync(filePath, "utf-8");
  const taskFile: TaskFile = JSON.parse(content);

  const graph = new Graph();

  // Recreate nodes using TaskActor factory
  for (const nodeProps of taskFile.nodes) {
    if (nodeProps.type === "task") {
      const taskProps = nodeProps as TaskProperties;
      const originalId = taskProps.id;

      // Create task actor using factory (this generates a NEW id)
      TaskActor({
        goal: taskProps.goal,
        desiredDeliverables: taskProps.desiredDeliverables,
        objectiveSuccessCriteria: taskProps.objectiveSuccessCriteria,
        subjectiveSuccessCriteria: taskProps.subjectiveSuccessCriteria,
        informationGaps: taskProps.informationGaps,
        toolsAvailable: taskProps.toolsAvailable,
        parentTaskId: taskProps.parentTaskId,
        labels: taskProps.labels,
        priority: taskProps.priority,
        graph,
      });

      // Get the newly created task ID (last one in graph)
      const allIds = graph.getNodeIds();
      const newId = allIds[allIds.length - 1];

      // If the IDs don't match, we need to fix this
      if (newId !== originalId) {
        // Get the node's address and properties
        const address = (graph as any).nodes.get(newId);
        const props = graph.getNodeProperties(newId);

        // Remove the node with wrong ID
        (graph as any).nodes.delete(newId);
        (graph as any).nodeProperties.delete(newId);

        // Re-register with correct ID
        if (address && props) {
          // Update the properties ID to match original
          props.id = originalId;
          (graph as any).nodes.set(originalId, address);
          (graph as any).nodeProperties.set(originalId, props);
        }
      }

      // Restore task state by updating properties in graph (now using correct ID)
      const restoredProps = graph.getNodeProperties(originalId);
      if (restoredProps) {
        Object.assign(restoredProps, taskProps);
      }
    }
  }

  // Recreate edges
  for (const edge of taskFile.edges) {
    // Add edge directly to graph's internal edges map
    const edgeNum = parseInt(edge.id.replace("edge_", ""));
    if (!isNaN(edgeNum)) {
      graph.setEdgeCounter(Math.max(edgeNum, 0));
    }
    graph.addEdge(edge.fromId, edge.toId, edge.type, edge.properties);
  }

  return graph;
}

// Save Graph to file
async function saveGraph(graph: Graph, filePath: string): Promise<void> {
  const dump = graph.dump();

  // Serialize dates as ISO strings
  const serialized = JSON.stringify(dump, (key, value) => {
    if (value instanceof Date) {
      return value.toISOString();
    }
    return value;
  }, 2);

  writeFileSync(filePath, serialized, "utf-8");
}

// Commands

async function cmdInit() {
  const filePath = resolve(TASKS_FILE);

  if (existsSync(filePath)) {
    console.error(`Error: ${TASKS_FILE} already exists`);
    process.exit(1);
  }

  const graph = new Graph();

  // Create an example task using TaskActor
  TaskActor({
    goal: "Example task - getting started",
    desiredDeliverables: ["Understand the task system", "Run first commands"],
    objectiveSuccessCriteria: [
      {
        criterion: "Commands executed",
        measure: "Number of CLI commands run",
        threshold: 3,
      },
    ],
    toolsAvailable: ["CLI"],
    graph,
  });

  // Get the task ID from graph
  const taskId = graph.getNodeIds()[0];

  await saveGraph(graph, filePath);
  console.log(`Created ${TASKS_FILE} with example task`);
  console.log(`Task ID: ${taskId}`);
}

async function cmdList(filters?: { status?: string; label?: string; priority?: number }, options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);
  const graph = await loadGraph(filePath);
  const nodeIds = graph.getNodeIds();

  let tasks = nodeIds.filter((id) => {
    const props = graph.getNodeProperties(id);
    return props?.type === "task";
  });

  // Apply filters (AND logic - all filters must match)
  if (filters) {
    tasks = tasks.filter((id) => {
      const props = graph.getNodeProperties(id) as TaskProperties;

      // Filter by status
      if (filters.status && props.state !== filters.status) {
        return false;
      }

      // Filter by label (match any label)
      if (filters.label) {
        if (!props.labels || !props.labels.some(l => l.toLowerCase() === filters.label!.toLowerCase())) {
          return false;
        }
      }

      // Filter by priority
      if (filters.priority !== undefined && props.priority !== filters.priority) {
        return false;
      }

      return true;
    });
  }

  // Get task properties
  const taskList = tasks.map((id) => {
    const props = graph.getNodeProperties(id) as TaskProperties;
    return { id, ...props };
  });

  // JSON output mode
  if (options?.json) {
    let data = taskList;

    // Apply field projection if requested
    if (options.fields && options.fields.length > 0) {
      data = taskList.map(task => projectFields(task, options.fields!)) as any;
    }

    jsonOutput(true, data);
    return;
  }

  // Human-friendly output
  console.log("\nTasks:");
  console.log("‚îÄ".repeat(80));

  if (tasks.length === 0) {
    console.log("No tasks match the specified filters.");
  } else {
    for (const id of tasks) {
      const props = graph.getNodeProperties(id) as TaskProperties;
      const statusEmoji = {
        created: "‚≠ï",
        ready: "üü°",
        active: "üîÑ",
        blocked: "üö´",
        completed: "‚úÖ",
        failed: "‚ùå",
      }[props.state] || "‚ùì";

      const priorityDisplay = props.priority !== undefined ? `P${props.priority}` : "  ";
      const labelsDisplay = props.labels && props.labels.length > 0 ? `[${props.labels.join(", ")}]` : "";
      const goalPreview = props.goal.length > 50 ? props.goal.slice(0, 47) + "..." : props.goal;
      console.log(`${statusEmoji} ${priorityDisplay} ${id.padEnd(15)} ${props.state.padEnd(10)} ${goalPreview} ${labelsDisplay}`);
    }
  }
  console.log();
}

async function cmdShow(id: string, options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);
  const graph = await loadGraph(filePath);

  const result = await graph.send(id, "get", {});
  const getResponse = result as { id: string; properties: TaskProperties; edges: Edge[] };

  const props = getResponse.properties;

  // JSON output mode
  if (options?.json) {
    let data: any = { id, ...props, edges: getResponse.edges };

    // Apply field projection if requested
    if (options.fields && options.fields.length > 0) {
      data = projectFields(data, options.fields);
    }

    jsonOutput(true, data);
    return;
  }

  // Human-friendly output
  console.log(`\nTask: ${id}`);
  console.log("‚îÄ".repeat(80));
  console.log(`Goal:           ${props.goal}`);
  console.log(`State:          ${props.state}`);
  if (props.priority !== undefined) console.log(`Priority:       P${props.priority}`);
  if (props.labels && props.labels.length > 0) console.log(`Labels:         ${props.labels.join(", ")}`);
  console.log(`Created:        ${props.createdAt}`);
  if (props.startedAt) console.log(`Started:        ${props.startedAt}`);
  if (props.completedAt) console.log(`Completed:      ${props.completedAt}`);

  console.log(`\nDeliverables:`);
  props.desiredDeliverables.forEach((d) => console.log(`  - ${d}`));

  console.log(`\nSuccess Criteria:`);
  props.objectiveSuccessCriteria.forEach((c) => {
    const status = c.passed !== undefined ? (c.passed ? "‚úÖ" : "‚ùå") : "‚è≥";
    console.log(`  ${status} ${c.criterion} (${c.measure} >= ${c.threshold})`);
  });

  if (getResponse.edges.length > 0) {
    console.log(`\nEdges:`);
    getResponse.edges.forEach((e) => {
      console.log(`  ${e.type}: ${e.fromId} ‚Üí ${e.toId}`);
    });
  }

  if (props.informationGaps.length > 0) {
    console.log(`\nInformation Gaps:`);
    props.informationGaps.forEach((gap) => console.log(`  - ${gap}`));
  }

  console.log();
}

async function cmdAdd(goal: string, options: { deliverables?: string[]; criteria?: string; depends?: string; parent?: string; labels?: string[]; priority?: 0 | 1 | 2 | 3 | 4; json?: boolean }) {
  const filePath = resolve(TASKS_FILE);

  if (!existsSync(filePath)) {
    if (options.json) {
      jsonOutput(false, undefined, {
        code: "FILE_NOT_FOUND",
        message: `${TASKS_FILE} not found. Run 'task init' first.`,
      });
      process.exit(1);
    }
    console.error(`Error: ${TASKS_FILE} not found. Run 'task init' first.`);
    process.exit(1);
  }

  const { coordinator, graph } = await initializeCoordinator(filePath);

  // Parse criteria if provided (format: "name:measure:threshold")
  const criteria: ObjectiveCriterion[] = [];
  if (options.criteria) {
    const parts = options.criteria.split(":");
    if (parts.length === 3) {
      criteria.push({
        criterion: parts[0],
        measure: parts[1],
        threshold: parseFloat(parts[2]) || parts[2] === "true",
      });
    }
  }

  const createOptions = {
    goal,
    desiredDeliverables: options.deliverables || ["Task completion"],
    objectiveSuccessCriteria: criteria.length > 0 ? criteria : [
      { criterion: "Task marked complete", measure: "Manual completion", threshold: true }
    ],
    parentTaskId: options.parent,
    toolsAvailable: ["CLI"],
    labels: options.labels,
    priority: options.priority,
  };

  // Create task using DualWriteCoordinator
  const taskId = await coordinator.createTask(createOptions);

  // Add dependency edges
  if (options.depends) {
    const deps = options.depends.split(",");
    for (const depId of deps) {
      await coordinator.addDependency(taskId, depId.trim());
    }
  }

  // Add parent edge (if not already added via parentTaskId)
  if (options.parent) {
    graph.addEdge(taskId, options.parent, "spawned_by");
  }

  await saveGraph(graph, filePath);

  // Emit task_created event
  eventLog.append({
    timestamp: new Date().toISOString(),
    type: EVENT_TYPES.TASK_CREATED,
    nodeId: taskId,
    data: {
      goal,
      deliverables: options.deliverables || ["Task completion"],
      labels: options.labels,
      priority: options.priority,
      parentTaskId: options.parent,
    },
    metadata: {
      triggeredBy: process.env.USER || "unknown",
      labels: options.labels,
      priority: options.priority,
      parentTaskId: options.parent,
    },
  });

  // JSON output mode
  if (options.json) {
    jsonOutput(true, { id: taskId, goal, labels: options.labels, priority: options.priority });
    return;
  }

  // Human-friendly output
  console.log(`Added task: ${taskId}`);
  console.log(`Goal: ${goal}`);
  if (options.labels && options.labels.length > 0) console.log(`Labels: ${options.labels.join(", ")}`);
  if (options.priority !== undefined) console.log(`Priority: P${options.priority}`);
}

async function cmdUpdate(id: string, action: string, options?: CliOptions, ...args: string[]) {
  const filePath = resolve(TASKS_FILE);
  const { coordinator, graph } = await initializeCoordinator(filePath);

  let result: unknown;

  switch (action) {
    case "start": {
      await coordinator.updateTask(id, "start");
      result = "Task started";

      // Emit task_started event
      eventLog.append({
        timestamp: new Date().toISOString(),
        type: EVENT_TYPES.TASK_STARTED,
        nodeId: id,
        data: {},
        metadata: { triggeredBy: process.env.USER || "unknown" },
      });

      if (options?.json) {
        jsonOutput(true, { id, action: "start", result });
        await saveGraph(graph, filePath);
        return;
      }
      console.log(`Started task ${id}`);
      break;
    }

    case "complete": {
      // Get task to set actual values for criteria
      const getResponse = await graph.send(id, "get", {}) as { properties: TaskProperties };
      const props = getResponse.properties;

      // For now, auto-pass all criteria
      for (const criterion of props.objectiveSuccessCriteria) {
        criterion.actual = criterion.threshold;
      }

      await coordinator.updateTask(id, "complete", { result: args[0] || "Task completed" });
      result = "Task completed";
      if (options?.json) {
        jsonOutput(true, { id, action: "complete", result });
        await saveGraph(graph, filePath);
        return;
      }
      console.log(`Completed task ${id}`);
      break;
    }

    case "block": {
      const reason = args[0] || "Blocked by dependency";
      await coordinator.updateTask(id, "block", { reason });
      result = `Task blocked: ${reason}`;
      if (options?.json) {
        jsonOutput(true, { id, action: "block", reason, result });
        await saveGraph(graph, filePath);
        return;
      }
      console.log(`Blocked task ${id}: ${reason}`);
      break;
    }

    default:
      if (options?.json) {
        jsonOutput(false, undefined, {
          code: "INVALID_ACTION",
          message: `Unknown action: ${action}`,
          details: { validActions: ["start", "complete", "block"] },
        });
        process.exit(1);
      }
      console.error(`Unknown action: ${action}`);
      console.error(`Valid actions: start, complete, block`);
      process.exit(1);
  }

  await saveGraph(graph, filePath);
}

async function cmdEval(id: string, options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);
  const graph = await loadGraph(filePath);

  const result = await graph.send(id, "eval", {});

  if (options?.json) {
    jsonOutput(true, { id, evaluation: result });
    return;
  }

  console.log(`\nEvaluation for task ${id}:`);
  console.log(JSON.stringify(result, null, 2));
}

async function cmdStatus(id: string, options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);
  const graph = await loadGraph(filePath);

  const result = await graph.send(id, "query_status", {});

  if (options?.json) {
    jsonOutput(true, { id, status: result });
    return;
  }

  console.log(`\nStatus for task ${id}:`);
  console.log(JSON.stringify(result, null, 2));
}

async function cmdSearch(query: string, options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);
  const graph = await loadGraph(filePath);
  const nodeIds = graph.getNodeIds();

  // Filter for task nodes only
  const tasks = nodeIds.filter((id) => {
    const props = graph.getNodeProperties(id);
    return props?.type === "task";
  });

  // Normalize query for case-insensitive matching
  const normalizedQuery = query.toLowerCase();

  // Search for matching tasks
  const matches: { id: string; props: TaskProperties; matchedIn: string[] }[] = [];

  for (const id of tasks) {
    const props = graph.getNodeProperties(id) as TaskProperties;
    const matchedIn: string[] = [];

    // Search in goal
    if (props.goal.toLowerCase().includes(normalizedQuery)) {
      matchedIn.push("goal");
    }

    // Search in deliverables
    for (const deliverable of props.desiredDeliverables) {
      if (deliverable.toLowerCase().includes(normalizedQuery)) {
        matchedIn.push("deliverables");
        break; // Only count deliverables once
      }
    }

    // Search in objective success criteria
    for (const criterion of props.objectiveSuccessCriteria) {
      if (criterion.criterion.toLowerCase().includes(normalizedQuery)) {
        matchedIn.push("criteria");
        break; // Only count criteria once
      }
    }

    // If any matches found, add to results
    if (matchedIn.length > 0) {
      matches.push({ id, props, matchedIn });
    }
  }

  // JSON output mode
  if (options?.json) {
    const data = matches.map(m => ({ id: m.id, ...m.props, matchedIn: m.matchedIn }));
    jsonOutput(true, data);
    return;
  }

  // Display results
  if (matches.length === 0) {
    console.log(`\nNo tasks found matching "${query}"`);
    console.log();
    return;
  }

  console.log(`\nFound ${matches.length} task(s) matching "${query}":`);
  console.log("‚îÄ".repeat(80));

  for (const match of matches) {
    const statusEmoji = {
      created: "‚≠ï",
      ready: "üü°",
      active: "üîÑ",
      blocked: "üö´",
      completed: "‚úÖ",
      failed: "‚ùå",
    }[match.props.state] || "‚ùì";

    const goalPreview = match.props.goal.length > 50 ? match.props.goal.slice(0, 47) + "..." : match.props.goal;
    const matchInfo = `[${match.matchedIn.join(", ")}]`;
    console.log(`${statusEmoji} ${match.id.padEnd(15)} ${match.props.state.padEnd(10)} ${goalPreview}`);
    console.log(`   ${matchInfo}`);
  }
  console.log();
}

async function cmdDelete(id: string, options?: { force?: boolean; yes?: boolean; json?: boolean }) {
  const filePath = resolve(TASKS_FILE);
  const { coordinator, graph } = await initializeCoordinator(filePath);

  // Check if task exists
  const props = graph.getNodeProperties(id);
  if (!props) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "TASK_NOT_FOUND",
        message: `Task not found: ${id}`,
      });
      process.exit(1);
    }
    console.error(`Error: Task not found: ${id}`);
    process.exit(1);
  }

  // Get connected edges for confirmation message
  const edges = graph.getAllEdges(id);

  // Show what will be deleted (unless forced or yes flag)
  const skipConfirmation = options?.force || options?.yes;

  if (!skipConfirmation) {
    console.log(`\nTask to delete: ${id}`);
    console.log("‚îÄ".repeat(80));
    console.log(`Goal: ${(props as TaskProperties).goal}`);
    console.log(`State: ${(props as TaskProperties).state}`);

    if (edges.length > 0) {
      console.log(`\nConnected edges (${edges.length}):`);
      edges.forEach((e) => {
        console.log(`  ${e.type}: ${e.fromId} ‚Üí ${e.toId}`);
      });
    }

    // Confirmation prompt
    console.log();
    const answer = prompt("Delete this task? (yes/no): ");
    if (answer?.toLowerCase() !== "yes") {
      console.log("Deletion cancelled.");
      process.exit(0);
    }
  }

  // Delete the task using coordinator
  await coordinator.deleteTask(id);

  await saveGraph(graph, filePath);

  if (options?.json) {
    jsonOutput(true, { id, deleted: true, edgesRemoved: edges.length });
    return;
  }

  console.log(`\nDeleted task ${id}`);
  if (edges.length > 0) {
    console.log(`Removed ${edges.length} connected edge(s)`);
  }
}

async function cmdReady(options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);
  const graph = await loadGraph(filePath);
  const nodeIds = graph.getNodeIds();

  // Filter to task nodes only
  const taskIds = nodeIds.filter((id) => {
    const props = graph.getNodeProperties(id);
    return props?.type === "task";
  });

  // Find ready tasks (no blockers)
  const readyTasks: Array<{ id: string; props: TaskProperties }> = [];

  for (const taskId of taskIds) {
    const props = graph.getNodeProperties(taskId) as TaskProperties;

    // Skip completed or failed tasks
    if (props.state === "completed" || props.state === "failed") {
      continue;
    }

    // Skip explicitly blocked tasks
    if (props.state === "blocked") {
      continue;
    }

    // Check dependencies - task is blocked if any dependency is not completed
    const dependencies = graph.getEdgesFrom(taskId).filter((e) => e.type === "depends_on");
    let isBlocked = false;

    for (const dep of dependencies) {
      const depProps = graph.getNodeProperties(dep.toId) as TaskProperties;
      if (depProps && depProps.state !== "completed") {
        isBlocked = true;
        break;
      }
    }

    if (!isBlocked) {
      readyTasks.push({ id: taskId, props });
    }
  }

  // Sort by priority (if available) then by createdAt
  readyTasks.sort((a, b) => {
    // Check if priority field exists (task_3 may add this)
    const priorityA = (a.props as any).priority;
    const priorityB = (b.props as any).priority;

    if (priorityA !== undefined && priorityB !== undefined) {
      // Lower priority number = higher priority (P0 > P1 > P2)
      return priorityA - priorityB;
    }

    // Fall back to createdAt (older tasks first)
    const dateA = new Date(a.props.createdAt).getTime();
    const dateB = new Date(b.props.createdAt).getTime();
    return dateA - dateB;
  });

  // JSON output mode
  if (options?.json) {
    let data = readyTasks.map(t => ({ id: t.id, ...t.props }));

    // Apply field projection if requested
    if (options.fields && options.fields.length > 0) {
      data = data.map(task => projectFields(task, options.fields!)) as any;
    }

    jsonOutput(true, data);
    return;
  }

  // Display results
  console.log("\nReady Tasks (no blockers):");
  console.log("‚îÄ".repeat(80));

  if (readyTasks.length === 0) {
    console.log("No tasks ready to work on.");
  } else {
    for (const { id, props } of readyTasks) {
      const statusEmoji = {
        created: "‚≠ï",
        ready: "üü°",
        active: "üîÑ",
        blocked: "üö´",
        completed: "‚úÖ",
        failed: "‚ùå",
      }[props.state] || "‚ùì";

      const priority = (props as any).priority !== undefined ? `[P${(props as any).priority}]` : "";
      const goalPreview = props.goal.length > 50 ? props.goal.slice(0, 47) + "..." : props.goal;
      console.log(`${statusEmoji} ${id.padEnd(15)} ${priority.padEnd(5)} ${goalPreview}`);
    }
  }
  console.log();
}


async function cmdGraph(id: string, options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);
  const graph = await loadGraph(filePath);

  // Check if task exists
  const props = graph.getNodeProperties(id) as TaskProperties;
  if (!props || props.type !== "task") {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "TASK_NOT_FOUND",
        message: `Task not found: ${id}`,
      });
      process.exit(1);
    }
    throw new Error(`Task not found: ${id}`);
  }

  // Build dependency tree
  interface TreeNode {
    id: string;
    goal: string;
    state: string;
    dependencies: TreeNode[];
    circular?: boolean;
  }

  const visited = new Set<string>();

  function buildTree(taskId: string): TreeNode {
    const taskProps = graph.getNodeProperties(taskId) as TaskProperties;

    if (visited.has(taskId)) {
      return { id: taskId, goal: "", state: "", dependencies: [], circular: true };
    }

    if (!taskProps) {
      return { id: taskId, goal: "not found", state: "unknown", dependencies: [] };
    }

    visited.add(taskId);

    const dependencyEdges = graph.getEdgesFrom(taskId).filter(e => e.type === "depends_on");
    const dependencies = dependencyEdges.map(edge => buildTree(edge.toId));

    visited.delete(taskId);

    return {
      id: taskId,
      goal: taskProps.goal,
      state: taskProps.state,
      dependencies,
    };
  }

  const tree = buildTree(id);

  // JSON output mode
  if (options?.json) {
    jsonOutput(true, tree);
    return;
  }

  // Human-friendly output
  console.log(`\nDependency graph for ${id}:`);
  console.log("‚îÄ".repeat(80));

  const visitedPrint = new Set<string>();

  function printTree(taskId: string, indent: number = 0, prefix: string = "", isLast: boolean = true): void {
    // Detect cycles
    if (visitedPrint.has(taskId)) {
      console.log(`${prefix}‚ö†Ô∏è  (circular dependency detected)`);
      return;
    }
    visitedPrint.add(taskId);

    // Get task properties
    const taskProps = graph.getNodeProperties(taskId) as TaskProperties;
    if (!taskProps) {
      console.log(`${prefix}‚ùì ${taskId} (not found)`);
      return;
    }

    // Get status emoji
    const statusEmoji = {
      created: "‚≠ï",
      ready: "üü°",
      active: "üîÑ",
      blocked: "üö´",
      completed: "‚úÖ",
      failed: "‚ùå",
    }[taskProps.state] || "‚ùì";

    // Print current task
    const goalPreview = taskProps.goal.length > 60 ? taskProps.goal.slice(0, 57) + "..." : taskProps.goal;
    console.log(`${prefix}${statusEmoji} ${taskId}: ${goalPreview}`);

    // Get dependencies (edges FROM this task TO others with type "depends_on")
    const dependencyEdges = graph.getEdgesFrom(taskId).filter(e => e.type === "depends_on");

    if (dependencyEdges.length > 0) {
      // Sort by task ID for consistent output
      const sortedDeps = dependencyEdges.sort((a, b) => a.toId.localeCompare(b.toId));

      sortedDeps.forEach((edge, index) => {
        const isLastDep = index === sortedDeps.length - 1;
        const connector = isLastDep ? "‚îî‚îÄ‚îÄ" : "‚îú‚îÄ‚îÄ";
        const nextPrefix = prefix + (isLast ? "    " : "‚îÇ   ");

        console.log(`${prefix}${connector} depends_on:`);
        printTree(edge.toId, indent + 1, nextPrefix + "    ", isLastDep);
      });
    }

    visitedPrint.delete(taskId); // Allow revisiting in other branches
  }

  printTree(id);
  console.log();
}

// Dependency management commands

/**
 * Add a dependency edge between two tasks
 * Usage: task dep add <from-id> <to-id> [--type depends_on|blocks|spawned_by]
 */
async function cmdDepAdd(fromId: string, toId: string, options?: { type?: string; json?: boolean }) {
  const filePath = resolve(TASKS_FILE);
  const { coordinator, graph } = await initializeCoordinator(filePath);

  // Validate both tasks exist
  const fromProps = graph.getNodeProperties(fromId);
  const toProps = graph.getNodeProperties(toId);

  if (!fromProps || fromProps.type !== "task") {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "TASK_NOT_FOUND",
        message: `Source task not found: ${fromId}`,
      });
      process.exit(1);
    }
    console.error(`Error: Source task not found: ${fromId}`);
    process.exit(1);
  }

  if (!toProps || toProps.type !== "task") {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "TASK_NOT_FOUND",
        message: `Target task not found: ${toId}`,
      });
      process.exit(1);
    }
    console.error(`Error: Target task not found: ${toId}`);
    process.exit(1);
  }

  // Determine edge type (default: depends_on)
  const edgeType = (options?.type || "depends_on") as any;

  // Validate edge type
  const validTypes = ["depends_on", "blocks", "spawned_by", "requires_knowledge", "produces", "references"];
  if (!validTypes.includes(edgeType)) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "INVALID_EDGE_TYPE",
        message: `Invalid edge type: ${edgeType}`,
        details: { validTypes },
      });
      process.exit(1);
    }
    console.error(`Error: Invalid edge type: ${edgeType}`);
    console.error(`Valid types: ${validTypes.join(", ")}`);
    process.exit(1);
  }

  // Add the edge using coordinator (only for depends_on type)
  let edgeId: string;
  if (edgeType === "depends_on") {
    edgeId = await coordinator.addDependency(fromId, toId);
  } else {
    // Other edge types go directly to graph
    const edge = graph.addEdge(fromId, toId, edgeType);
    edgeId = edge.id;
  }

  // Save changes
  await saveGraph(graph, filePath);

  if (options?.json) {
    jsonOutput(true, { edge: { id: edgeId, fromId, toId, type: edgeType } });
    return;
  }

  console.log(`Added ${edgeType} edge:`);
  console.log(`  ${edgeId}: ${fromId} ‚Üí ${toId}`);
}

/**
 * Remove a dependency edge by ID
 * Usage: task dep remove <edge-id>
 */
async function cmdDepRemove(edgeId: string, options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);
  const graph = await loadGraph(filePath);

  // Check if edge exists
  const dump = graph.dump();
  const edge = dump.edges.find(e => e.id === edgeId);

  if (!edge) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "EDGE_NOT_FOUND",
        message: `Edge not found: ${edgeId}`,
      });
      process.exit(1);
    }
    console.error(`Error: Edge not found: ${edgeId}`);
    process.exit(1);
  }

  // Remove the edge
  const removed = graph.removeEdge(edgeId);

  if (!removed) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "REMOVE_FAILED",
        message: `Failed to remove edge: ${edgeId}`,
      });
      process.exit(1);
    }
    console.error(`Error: Failed to remove edge: ${edgeId}`);
    process.exit(1);
  }

  // Save changes
  await saveGraph(graph, filePath);

  if (options?.json) {
    jsonOutput(true, { edgeId, removed: true });
    return;
  }

  console.log(`Removed edge ${edgeId}:`);
  console.log(`  ${edge.type}: ${edge.fromId} ‚Üí ${edge.toId}`);
}

/**
 * List all dependencies for a task
 * Usage: task dep list <task-id> [--incoming|--outgoing]
 */
async function cmdDepList(taskId: string, options?: { direction?: "incoming" | "outgoing"; json?: boolean; fields?: string[] }) {
  const filePath = resolve(TASKS_FILE);
  const graph = await loadGraph(filePath);

  // Validate task exists
  const props = graph.getNodeProperties(taskId);
  if (!props || props.type !== "task") {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "TASK_NOT_FOUND",
        message: `Task not found: ${taskId}`,
      });
      process.exit(1);
    }
    console.error(`Error: Task not found: ${taskId}`);
    process.exit(1);
  }

  // Get edges based on direction
  let edges: Edge[];
  if (options?.direction === "incoming") {
    edges = graph.getEdgesTo(taskId);
  } else if (options?.direction === "outgoing") {
    edges = graph.getEdgesFrom(taskId);
  } else {
    edges = graph.getAllEdges(taskId);
  }

  // JSON output mode
  if (options?.json) {
    let data = edges;

    // Apply field projection if requested
    if (options.fields && options.fields.length > 0) {
      data = edges.map(edge => projectFields(edge, options.fields!)) as any;
    }

    jsonOutput(true, { taskId, direction: options?.direction || "all", edges: data });
    return;
  }

  // Human-friendly output
  const directionLabel = options?.direction === "incoming" ? "Incoming" :
                         options?.direction === "outgoing" ? "Outgoing" : "All";
  console.log(`\n${directionLabel} dependencies for ${taskId}:`);
  console.log("‚îÄ".repeat(80));

  if (edges.length === 0) {
    console.log("No dependencies found.");
  } else {
    for (const edge of edges) {
      const direction = edge.fromId === taskId ? "‚Üí" : "‚Üê";
      const otherTaskId = edge.fromId === taskId ? edge.toId : edge.fromId;
      const otherProps = graph.getNodeProperties(otherTaskId) as TaskProperties;
      const goalPreview = otherProps?.goal ?
        (otherProps.goal.length > 50 ? otherProps.goal.slice(0, 47) + "..." : otherProps.goal) :
        "unknown";

      console.log(`  ${edge.id.padEnd(12)} [${edge.type.padEnd(20)}] ${direction} ${otherTaskId.padEnd(15)} ${goalPreview}`);
    }
  }
  console.log();
}

/**
 * Show details of a specific edge
 * Usage: task dep show <edge-id>
 */
async function cmdDepShow(edgeId: string, options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);
  const graph = await loadGraph(filePath);

  // Find the edge
  const dump = graph.dump();
  const edge = dump.edges.find(e => e.id === edgeId);

  if (!edge) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "EDGE_NOT_FOUND",
        message: `Edge not found: ${edgeId}`,
      });
      process.exit(1);
    }
    console.error(`Error: Edge not found: ${edgeId}`);
    process.exit(1);
  }

  // Get task details
  const fromProps = graph.getNodeProperties(edge.fromId) as TaskProperties;
  const toProps = graph.getNodeProperties(edge.toId) as TaskProperties;

  // JSON output mode
  if (options?.json) {
    let data: any = {
      ...edge,
      from: { id: edge.fromId, goal: fromProps?.goal },
      to: { id: edge.toId, goal: toProps?.goal },
    };

    // Apply field projection if requested
    if (options.fields && options.fields.length > 0) {
      data = projectFields(data, options.fields);
    }

    jsonOutput(true, data);
    return;
  }

  // Human-friendly output
  console.log(`\nEdge: ${edge.id}`);
  console.log("‚îÄ".repeat(80));
  console.log(`Type:           ${edge.type}`);
  console.log(`Direction:      ${edge.fromId} ‚Üí ${edge.toId}`);
  console.log();
  console.log(`From Task:      ${edge.fromId}`);
  console.log(`  Goal:         ${fromProps?.goal || "unknown"}`);
  console.log(`  State:        ${fromProps?.state || "unknown"}`);
  console.log();
  console.log(`To Task:        ${edge.toId}`);
  console.log(`  Goal:         ${toProps?.goal || "unknown"}`);
  console.log(`  State:        ${toProps?.state || "unknown"}`);

  if (edge.properties && Object.keys(edge.properties).length > 0) {
    console.log();
    console.log("Properties:");
    for (const [key, value] of Object.entries(edge.properties)) {
      console.log(`  ${key}: ${JSON.stringify(value)}`);
    }
  }
  console.log();
}


// CozoDB Query Commands

/**
 * Query ready tasks using CozoDB Datalog
 * Usage: task cozo-ready
 */
async function cmdCozoReady(options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);

  if (!existsSync(filePath)) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "FILE_NOT_FOUND",
        message: `${TASKS_FILE} not found. Run 'task init' first.`,
      });
      process.exit(1);
    }
    console.error(`Error: ${TASKS_FILE} not found. Run 'task init' first.`);
    process.exit(1);
  }

  const { queryService } = await initializeCoordinator(filePath);

  try {
    const readyTasks = await queryService.findReadyTasks();

    if (options?.json) {
      jsonOutput(true, readyTasks);
      return;
    }

    console.log("\nReady Tasks (CozoDB Query):");
    console.log("‚îÄ".repeat(80));

    if (readyTasks.length === 0) {
      console.log("No tasks ready to work on.");
    } else {
      for (const task of readyTasks) {
        const priority = task.priority !== null ? `[P${task.priority}]` : "";
        const titlePreview = task.title.length > 50 ? task.title.slice(0, 47) + "..." : task.title;
        console.log(`üü° ${task.id.padEnd(15)} ${priority.padEnd(5)} ${titlePreview}`);
      }
    }
    console.log();
  } catch (error) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "QUERY_FAILED",
        message: `CozoDB query failed: ${error instanceof Error ? error.message : String(error)}`,
      });
      process.exit(1);
    }
    console.error(`Error: CozoDB query failed: ${error instanceof Error ? error.message : String(error)}`);
    process.exit(1);
  }
}

/**
 * Query blocked tasks using CozoDB Datalog
 * Usage: task cozo-blocked
 */
async function cmdCozoBlocked(options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);

  if (!existsSync(filePath)) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "FILE_NOT_FOUND",
        message: `${TASKS_FILE} not found. Run 'task init' first.`,
      });
      process.exit(1);
    }
    console.error(`Error: ${TASKS_FILE} not found. Run 'task init' first.`);
    process.exit(1);
  }

  const { queryService } = await initializeCoordinator(filePath);

  try {
    const blockedTasks = await queryService.findBlockedTasks();

    if (options?.json) {
      jsonOutput(true, blockedTasks);
      return;
    }

    console.log("\nBlocked Tasks (CozoDB Query):");
    console.log("‚îÄ".repeat(80));

    if (blockedTasks.length === 0) {
      console.log("No blocked tasks.");
    } else {
      for (const task of blockedTasks) {
        console.log(`üö´ ${task.id.padEnd(15)} ${task.title}`);
        console.log(`   Blocked by:`);
        for (const blocker of task.blockers) {
          console.log(`     - ${blocker.id}: ${blocker.title} (${blocker.status})`);
        }
      }
    }
    console.log();
  } catch (error) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "QUERY_FAILED",
        message: `CozoDB query failed: ${error instanceof Error ? error.message : String(error)}`,
      });
      process.exit(1);
    }
    console.error(`Error: CozoDB query failed: ${error instanceof Error ? error.message : String(error)}`);
    process.exit(1);
  }
}

/**
 * Search tasks using CozoDB Datalog
 * Usage: task cozo-search <keyword>
 */
async function cmdCozoSearch(keyword: string, options?: CliOptions) {
  const filePath = resolve(TASKS_FILE);

  if (!existsSync(filePath)) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "FILE_NOT_FOUND",
        message: `${TASKS_FILE} not found. Run 'task init' first.`,
      });
      process.exit(1);
    }
    console.error(`Error: ${TASKS_FILE} not found. Run 'task init' first.`);
    process.exit(1);
  }

  const { queryService } = await initializeCoordinator(filePath);

  try {
    const results = await queryService.searchTasks(keyword);

    if (options?.json) {
      jsonOutput(true, results);
      return;
    }

    console.log(`\nSearch Results for "${keyword}" (CozoDB Query):`);
    console.log("‚îÄ".repeat(80));

    if (results.length === 0) {
      console.log("No tasks found.");
    } else {
      for (const task of results) {
        const statusEmoji = {
          created: "‚≠ï",
          ready: "üü°",
          active: "üîÑ",
          blocked: "üö´",
          completed: "‚úÖ",
          failed: "‚ùå",
        }[task.status] || "‚ùì";

        console.log(`${statusEmoji} ${task.id.padEnd(15)} ${task.status.padEnd(10)} ${task.title}`);
      }
    }
    console.log();
  } catch (error) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "QUERY_FAILED",
        message: `CozoDB query failed: ${error instanceof Error ? error.message : String(error)}`,
      });
      process.exit(1);
    }
    console.error(`Error: CozoDB query failed: ${error instanceof Error ? error.message : String(error)}`);
    process.exit(1);
  }
}

// Batch operations

interface BatchTaskSpec {
  goal: string;
  deliverables?: string[];
  criteria?: ObjectiveCriterion[];
  depends?: string[];
  parent?: string;
  labels?: string[];
  priority?: 0 | 1 | 2 | 3 | 4;
}

interface BatchUpdateSpec {
  id: string;
  action: "start" | "complete" | "block";
  reason?: string;
  result?: string;
}

async function cmdBatchAdd(filePath: string, options?: CliOptions) {
  const tasksFilePath = resolve(TASKS_FILE);

  if (!existsSync(tasksFilePath)) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "FILE_NOT_FOUND",
        message: `${TASKS_FILE} not found. Run 'task init' first.`,
      });
      process.exit(1);
    }
    console.error(`Error: ${TASKS_FILE} not found. Run 'task init' first.`);
    process.exit(1);
  }

  // Read batch specs from file
  let specs: BatchTaskSpec[];
  try {
    const content = readFileSync(filePath, "utf-8");
    specs = JSON.parse(content);
  } catch (err) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "INVALID_JSON",
        message: "Failed to parse batch task specs file",
        details: err instanceof Error ? err.message : String(err),
      });
      process.exit(1);
    }
    console.error(`Error: Failed to parse batch task specs file: ${err instanceof Error ? err.message : String(err)}`);
    process.exit(1);
  }

  // Validate array
  if (!Array.isArray(specs)) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "INVALID_INPUT",
        message: "Batch task specs must be an array",
      });
      process.exit(1);
    }
    console.error("Error: Batch task specs must be an array");
    process.exit(1);
  }

  // Load graph once
  const graph = await loadGraph(tasksFilePath);

  const created: string[] = [];
  const errors: Array<{ index: number; error: string }> = [];

  // Create all tasks in single graph
  for (let i = 0; i < specs.length; i++) {
    const spec = specs[i];

    try {
      // Validate required fields
      if (!spec.goal) {
        throw new Error("Missing required field: goal");
      }

      const createOptions: CreateTaskOptions = {
        goal: spec.goal,
        desiredDeliverables: spec.deliverables || ["Task completion"],
        objectiveSuccessCriteria: spec.criteria || [
          { criterion: "Task marked complete", measure: "Manual completion", threshold: true }
        ],
        parentTaskId: spec.parent,
        toolsAvailable: ["CLI"],
        labels: spec.labels,
        priority: spec.priority,
      };

      // Create task using TaskActor factory
      TaskActor({ ...createOptions, graph });

      // Get the new task ID (last one added)
      const allIds = graph.getNodeIds();
      const taskId = allIds[allIds.length - 1];

      // Add dependency edges
      if (spec.depends && spec.depends.length > 0) {
        for (const depId of spec.depends) {
          graph.addEdge(taskId, depId, "depends_on");
        }
      }

      // Add parent edge
      if (spec.parent) {
        graph.addEdge(taskId, spec.parent, "spawned_by");
      }

      created.push(taskId);
    } catch (err) {
      errors.push({
        index: i,
        error: err instanceof Error ? err.message : String(err),
      });
    }
  }

  // Save graph once
  await saveGraph(graph, tasksFilePath);

  // Output results
  if (options?.json) {
    jsonOutput(true, { created, errors });
    return;
  }

  console.log(`\nBatch task creation completed:`);
  console.log(`Created: ${created.length} task(s)`);
  if (created.length > 0) {
    created.forEach(id => console.log(`  - ${id}`));
  }
  if (errors.length > 0) {
    console.log(`\nErrors: ${errors.length}`);
    errors.forEach(e => console.log(`  [${e.index}]: ${e.error}`));
  }
}

async function cmdBatchUpdate(filePath: string, options?: CliOptions) {
  const tasksFilePath = resolve(TASKS_FILE);

  if (!existsSync(tasksFilePath)) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "FILE_NOT_FOUND",
        message: `${TASKS_FILE} not found. Run 'task init' first.`,
      });
      process.exit(1);
    }
    console.error(`Error: ${TASKS_FILE} not found. Run 'task init' first.`);
    process.exit(1);
  }

  // Read batch specs from file
  let specs: BatchUpdateSpec[];
  try {
    const content = readFileSync(filePath, "utf-8");
    specs = JSON.parse(content);
  } catch (err) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "INVALID_JSON",
        message: "Failed to parse batch update specs file",
        details: err instanceof Error ? err.message : String(err),
      });
      process.exit(1);
    }
    console.error(`Error: Failed to parse batch update specs file: ${err instanceof Error ? err.message : String(err)}`);
    process.exit(1);
  }

  // Validate array
  if (!Array.isArray(specs)) {
    if (options?.json) {
      jsonOutput(false, undefined, {
        code: "INVALID_INPUT",
        message: "Batch update specs must be an array",
      });
      process.exit(1);
    }
    console.error("Error: Batch update specs must be an array");
    process.exit(1);
  }

  // Load graph once
  const graph = await loadGraph(tasksFilePath);

  const updated: string[] = [];
  const errors: Array<{ index: number; id: string; error: string }> = [];

  // Update all tasks
  for (let i = 0; i < specs.length; i++) {
    const spec = specs[i];

    try {
      // Validate required fields
      if (!spec.id) {
        throw new Error("Missing required field: id");
      }
      if (!spec.action) {
        throw new Error("Missing required field: action");
      }

      // Execute action
      switch (spec.action) {
        case "start":
          await graph.send(spec.id, "start", {});
          break;

        case "complete": {
          // Get task to set actual values for criteria
          const getResponse = await graph.send(spec.id, "get", {}) as { properties: TaskProperties };
          const props = getResponse.properties;

          // For now, auto-pass all criteria
          for (const criterion of props.objectiveSuccessCriteria) {
            criterion.actual = criterion.threshold;
          }

          await graph.send(spec.id, "complete", { result: spec.result || "Task completed" });
          break;
        }

        case "block":
          await graph.send(spec.id, "block", { reason: spec.reason || "Blocked by dependency" });
          break;

        default:
          throw new Error(`Invalid action: ${spec.action}`);
      }

      updated.push(spec.id);
    } catch (err) {
      errors.push({
        index: i,
        id: spec.id || "unknown",
        error: err instanceof Error ? err.message : String(err),
      });
    }
  }

  // Save graph once
  await saveGraph(graph, tasksFilePath);

  // Output results
  if (options?.json) {
    jsonOutput(true, { updated, errors });
    return;
  }

  console.log(`\nBatch task update completed:`);
  console.log(`Updated: ${updated.length} task(s)`);
  if (updated.length > 0) {
    updated.forEach(id => console.log(`  - ${id}`));
  }
  if (errors.length > 0) {
    console.log(`\nErrors: ${errors.length}`);
    errors.forEach(e => console.log(`  [${e.index}] ${e.id}: ${e.error}`));
  }
}

// Main CLI

async function main() {
  const args = process.argv.slice(2);

  // Parse global flags
  const globalOptions: CliOptions = {
    json: args.includes("--json"),
    yes: args.includes("--yes"),
  };

  // Parse --fields flag
  const fieldsIndex = args.indexOf("--fields");
  if (fieldsIndex >= 0 && args[fieldsIndex + 1]) {
    globalOptions.fields = args[fieldsIndex + 1].split(",").map(f => f.trim());
  }

  // Remove global flags from args for command parsing
  const cleanArgs = args.filter(arg =>
    arg !== "--json" &&
    arg !== "--yes" &&
    arg !== "--fields" &&
    (fieldsIndex < 0 || arg !== args[fieldsIndex + 1])
  );

  const command = cleanArgs[0];

  switch (command) {
    case "init":
      await cmdInit();
      break;

    case "list": {
      const filters: { status?: string; label?: string; priority?: number } = {};

      for (let i = 1; i < cleanArgs.length; i++) {
        if (cleanArgs[i] === "--status" && cleanArgs[i + 1]) {
          filters.status = cleanArgs[i + 1];
          i++;
        } else if (cleanArgs[i] === "--label" && cleanArgs[i + 1]) {
          filters.label = cleanArgs[i + 1];
          i++;
        } else if (cleanArgs[i] === "--priority" && cleanArgs[i + 1]) {
          const priorityStr = cleanArgs[i + 1].toUpperCase();
          const priorityMatch = priorityStr.match(/^P?([0-4])$/);
          if (priorityMatch) {
            filters.priority = parseInt(priorityMatch[1]);
          } else {
            console.error(`Error: Invalid priority "${cleanArgs[i + 1]}". Use P0-P4 or 0-4 (where 0 is highest).`);
            process.exit(1);
          }
          i++;
        }
      }

      await cmdList(Object.keys(filters).length > 0 ? filters : undefined, globalOptions);
      break;
    }

    case "show":
      if (cleanArgs.length < 2) {
        console.error("Usage: task show <id> [--json] [--fields field1,field2]");
        process.exit(1);
      }
      await cmdShow(cleanArgs[1], globalOptions);
      break;

    case "add": {
      if (cleanArgs.length < 2) {
        console.error("Usage: task add <goal> [--deliverables d1,d2] [--criteria name:measure:threshold] [--depends id1,id2] [--parent id] [--labels tag1,tag2] [--priority P0] [--json]");
        process.exit(1);
      }

      const goal = cleanArgs[1];
      const options: any = { json: globalOptions.json };

      for (let i = 2; i < cleanArgs.length; i++) {
        if (cleanArgs[i] === "--deliverables" && cleanArgs[i + 1]) {
          options.deliverables = cleanArgs[i + 1].split(",");
          i++;
        } else if (cleanArgs[i] === "--criteria" && cleanArgs[i + 1]) {
          options.criteria = cleanArgs[i + 1];
          i++;
        } else if (cleanArgs[i] === "--depends" && cleanArgs[i + 1]) {
          options.depends = cleanArgs[i + 1];
          i++;
        } else if (cleanArgs[i] === "--parent" && cleanArgs[i + 1]) {
          options.parent = cleanArgs[i + 1];
          i++;
        } else if (cleanArgs[i] === "--labels" && cleanArgs[i + 1]) {
          options.labels = cleanArgs[i + 1].split(",").map(l => l.trim());
          i++;
        } else if (cleanArgs[i] === "--priority" && cleanArgs[i + 1]) {
          const priorityStr = cleanArgs[i + 1].toUpperCase();
          const priorityMatch = priorityStr.match(/^P?([0-4])$/);
          if (priorityMatch) {
            options.priority = parseInt(priorityMatch[1]) as 0 | 1 | 2 | 3 | 4;
          } else {
            console.error(`Error: Invalid priority "${cleanArgs[i + 1]}". Use P0-P4 or 0-4 (where 0 is highest).`);
            process.exit(1);
          }
          i++;
        }
      }

      await cmdAdd(goal, options);
      break;
    }

    case "update":
      if (cleanArgs.length < 3) {
        console.error("Usage: task update <id> <action> [args...] [--json]");
        console.error("Actions: start, complete, block");
        process.exit(1);
      }
      await cmdUpdate(cleanArgs[1], cleanArgs[2], globalOptions, ...cleanArgs.slice(3));
      break;

    case "eval":
      if (cleanArgs.length < 2) {
        console.error("Usage: task eval <id> [--json]");
        process.exit(1);
      }
      await cmdEval(cleanArgs[1], globalOptions);
      break;

    case "status":
      if (cleanArgs.length < 2) {
        console.error("Usage: task status <id> [--json]");
        process.exit(1);
      }
      await cmdStatus(cleanArgs[1], globalOptions);
      break;

    case "search":
      if (cleanArgs.length < 2) {
        console.error("Usage: task search <query> [--json]");
        process.exit(1);
      }
      await cmdSearch(cleanArgs[1], globalOptions);
      break;

    case "delete": {
      if (cleanArgs.length < 2) {
        console.error("Usage: task delete <id> [--force|--yes] [--json]");
        process.exit(1);
      }

      const taskId = cleanArgs[1];
      const force = args.includes("--force");

      await cmdDelete(taskId, { force, yes: globalOptions.yes, json: globalOptions.json });
      break;
    }

    case "ready":
      await cmdReady(globalOptions);
      break;

    case "graph":
      if (cleanArgs.length < 2) {
        console.error("Usage: task graph <id> [--json]");
        process.exit(1);
      }
      await cmdGraph(cleanArgs[1], globalOptions);
      break;

    case "batch-add": {
      if (cleanArgs.length < 2 || cleanArgs[1] !== "--file" || !cleanArgs[2]) {
        console.error("Usage: task batch-add --file <path.json> [--json]");
        process.exit(1);
      }
      await cmdBatchAdd(cleanArgs[2], globalOptions);
      break;
    }

    case "batch-update": {
      if (cleanArgs.length < 2 || cleanArgs[1] !== "--file" || !cleanArgs[2]) {
        console.error("Usage: task batch-update --file <path.json> [--json]");
        process.exit(1);
      }
      await cmdBatchUpdate(cleanArgs[2], globalOptions);
      break;
    }

    case "cozo-ready":
      await cmdCozoReady(globalOptions);
      break;

    case "cozo-blocked":
      await cmdCozoBlocked(globalOptions);
      break;

    case "cozo-search":
      if (cleanArgs.length < 2) {
        console.error("Usage: task cozo-search <keyword> [--json]");
        process.exit(1);
      }
      await cmdCozoSearch(cleanArgs[1], globalOptions);
      break;

    case "dep": {
      const subcommand = cleanArgs[1];

      switch (subcommand) {
        case "add": {
          if (cleanArgs.length < 4) {
            console.error("Usage: task dep add <from-id> <to-id> [--type edge_type] [--json]");
            process.exit(1);
          }

          const fromId = cleanArgs[2];
          const toId = cleanArgs[3];
          const options: any = { json: globalOptions.json };

          // Parse --type flag
          const typeIndex = cleanArgs.indexOf("--type");
          if (typeIndex >= 0 && cleanArgs[typeIndex + 1]) {
            options.type = cleanArgs[typeIndex + 1];
          }

          await cmdDepAdd(fromId, toId, options);
          break;
        }

        case "remove": {
          if (cleanArgs.length < 3) {
            console.error("Usage: task dep remove <edge-id> [--json]");
            process.exit(1);
          }

          await cmdDepRemove(cleanArgs[2], globalOptions);
          break;
        }

        case "list": {
          if (cleanArgs.length < 3) {
            console.error("Usage: task dep list <task-id> [--incoming|--outgoing] [--json] [--fields field1,field2]");
            process.exit(1);
          }

          const taskId = cleanArgs[2];
          const options: any = { json: globalOptions.json, fields: globalOptions.fields };

          // Parse direction flags
          if (cleanArgs.includes("--incoming")) {
            options.direction = "incoming";
          } else if (cleanArgs.includes("--outgoing")) {
            options.direction = "outgoing";
          }

          await cmdDepList(taskId, options);
          break;
        }

        case "show": {
          if (cleanArgs.length < 3) {
            console.error("Usage: task dep show <edge-id> [--json] [--fields field1,field2]");
            process.exit(1);
          }

          await cmdDepShow(cleanArgs[2], globalOptions);
          break;
        }

        default:
          console.error("Unknown dep subcommand:", subcommand);
          console.error("\nDependency Management Commands:");
          console.error("  task dep add <from> <to> [--type type]     Add dependency edge");
          console.error("  task dep remove <edge-id>                  Remove dependency edge");
          console.error("  task dep list <task-id> [--dir]            List dependencies");
          console.error("  task dep show <edge-id>                    Show edge details");
          console.error("\nEdge types: depends_on, blocks, spawned_by, requires_knowledge, produces, references");
          process.exit(1);
      }
      break;
    }

    default:
      console.log("Task CLI - Manage task graphs using the Graph/TaskNode system\n");
      console.log("Commands:");
      console.log("  task init                              Create tasks.json");
      console.log("  task add <goal> [options]              Add a task");
      console.log("    --deliverables d1,d2                 Deliverables (comma-separated)");
      console.log("    --criteria name:measure:threshold    Success criterion");
      console.log("    --depends id1,id2                    Dependencies (comma-separated)");
      console.log("    --parent id                          Parent task");
      console.log("    --labels tag1,tag2                   Labels (comma-separated)");
      console.log("    --priority P0|P1|P2|P3|P4            Priority (P0 is highest)");
      console.log("  task update <id> <action>              Update task");
      console.log("    start                                Start the task");
      console.log("    complete [result]                    Complete the task");
      console.log("    block [reason]                       Block the task");
      console.log("  task delete <id> [--force|--yes]       Delete a task and its edges");
      console.log("  task list [options]                    List all tasks");
      console.log("    --status <state>                     Filter by state (created, active, blocked, completed)");
      console.log("    --label <label>                      Filter by label (match any)");
      console.log("    --priority P0|P1|P2|P3|P4            Filter by priority");
      console.log("  task ready                             Show tasks with no blockers");
      console.log("  task show <id>                         Show task details");
      console.log("  task graph <id>                        Show dependency tree for a task");
      console.log("  task eval <id>                         Evaluate task criteria");
      console.log("  task status <id>                       Show task status with blockers");
      console.log("  task search <query>                    Search tasks by keyword");
      console.log("  task batch-add --file <path.json>      Create multiple tasks from JSON file");
      console.log("  task batch-update --file <path.json>   Update multiple tasks from JSON file");
      console.log("\nDependency Management:");
      console.log("  task dep add <from> <to> [options]     Add dependency edge between tasks");
      console.log("    --type edge_type                     Edge type (default: depends_on)");
      console.log("  task dep remove <edge-id>              Remove dependency edge");
      console.log("  task dep list <task-id> [options]      List dependencies for a task");
      console.log("    --incoming                           Show only incoming edges");
      console.log("    --outgoing                           Show only outgoing edges");
      console.log("  task dep show <edge-id>                Show edge details");
      console.log("\nEdge Types:");
      console.log("  depends_on, blocks, spawned_by, requires_knowledge, produces, references");
      console.log("\nGlobal Options:");
      console.log("  --json                                 Output in JSON format (machine-readable)");
      console.log("  --yes                                  Skip confirmation prompts (non-interactive)");
      console.log("  --fields field1,field2                 Project only specified fields (with --json)");
      process.exit(command ? 1 : 0);
  }
}

main().catch((err) => {
  console.error("Error:", err.message);
  process.exit(1);
});
