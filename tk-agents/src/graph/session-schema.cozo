# CozoDB Schema for Actor Model Session Management
#
# This schema defines the graph structure for projects, sessions, and agents
# following the Actor model pattern.

# ============================================================================
# NODES
# ============================================================================

# Project nodes - represent top-level projects
# Fields: id, name, path, created_at
{:create project {
  id: String,
  name: String,
  path: String,
  created_at: String,
  =>
  id
}}

# Session nodes - represent Claude sessions within projects
# Fields: id, project_id, started_at, ended_at (optional), status
{:create session {
  id: String,
  project_id: String,
  started_at: String,
  ended_at: String default null,
  status: String default "active",
  =>
  id
}}

# Agent nodes - represent background agents/tasks
# Fields: id, session_id, task_id, command, status, started_at, ended_at
{:create agent {
  id: String,
  session_id: String,
  task_id: String default null,
  command: String,
  status: String default "running",
  priority: String default "P2",
  started_at: String,
  ended_at: String default null,
  output_path: String default null,
  =>
  id
}}

# ============================================================================
# EDGES
# ============================================================================

# belongs_to - sessions belong to projects
{:create belongs_to {
  from: String,
  to: String,
  relationship: String default "session_of_project",
  =>
  from, to
}}

# spawned_by - agents spawned by sessions or other agents
{:create spawned_by {
  child: String,
  parent: String,
  relationship: String default "agent_spawned_by",
  spawned_at: String,
  =>
  child, parent
}}

# depends_on - agents that depend on other agents
{:create depends_on {
  dependent: String,
  dependency: String,
  relationship: String default "blocks_on",
  created_at: String,
  =>
  dependent, dependency
}}

# ============================================================================
# INDEXES
# ============================================================================

# Index for fast project lookups
::index create project:by_path {
  path
}

# Index for session status queries
::index create session:by_status {
  status
}

# Index for agent status queries
::index create agent:by_status {
  status
}

# Index for agent priority queries
::index create agent:by_priority {
  priority
}

# ============================================================================
# COMMON QUERIES (as stored queries)
# ============================================================================

# List all sessions for a project
{:create_query sessions_for_project
  ?[session_id, started_at, status] :=
    *project{id: $project_id},
    *belongs_to{from: session_id, to: $project_id},
    *session{id: session_id, started_at, status}
}

# List all agents for a session
{:create_query agents_for_session
  ?[agent_id, command, status, started_at] :=
    *session{id: $session_id},
    *spawned_by{child: agent_id, parent: $session_id},
    *agent{id: agent_id, command, status, started_at}
}

# Find blocked agents (those with dependencies)
{:create_query blocked_agents
  ?[agent_id, command, blocking_on] :=
    *agent{id: agent_id, command, status: "blocked"},
    *depends_on{dependent: agent_id, dependency: blocking_on}
}

# Find active agents
{:create_query active_agents
  ?[agent_id, session_id, command, priority, started_at] :=
    *agent{id: agent_id, session_id, command, priority, started_at, status},
    status in ["running", "active"],
    *spawned_by{child: agent_id, parent: session_id}
}

# Agent dependency graph (recursive)
{:create_query agent_dependencies
  ?[agent_id, depends_on, depth] :=
    *depends_on{dependent: $root_agent_id, dependency: depends_on},
    depth = 1

  ?[agent_id, depends_on, depth] :=
    agent_dependencies[agent_id, intermediate, d1],
    *depends_on{dependent: intermediate, dependency: depends_on},
    depth = d1 + 1
}

# Session timeline - all events for a session
{:create_query session_timeline
  ?[event_type, entity_id, timestamp] :=
    *session{id: $session_id, started_at},
    event_type = "session_started",
    entity_id = $session_id,
    timestamp = started_at

  ?[event_type, entity_id, timestamp] :=
    *spawned_by{child: agent_id, parent: $session_id, spawned_at},
    *agent{id: agent_id},
    event_type = "agent_spawned",
    entity_id = agent_id,
    timestamp = spawned_at

  ?[event_type, entity_id, timestamp] :=
    *spawned_by{child: agent_id, parent: $session_id},
    *agent{id: agent_id, ended_at},
    ended_at != null,
    event_type = "agent_completed",
    entity_id = agent_id,
    timestamp = ended_at
}
