# Messaging Rules

# Subscriptions: topic_id, consumer_id, filter
:create topic_subscription {
    topic_id: uuid,
    consumer_id: uuid,
    =>
    filter: any
}

# Queue Workers: queue_id, worker_id, status
:create queue_worker {
    queue_id: uuid,
    worker_id: uuid,
    =>
    status: string # 'idle', 'busy'
}

# Routing: Who receives a message published to a topic?
receives_broadcast(topic_id, consumer_id) :-
    topic_subscription{topic_id: topic_id, consumer_id: consumer_id}

# Bottleneck Detection: Find queues with a large backlog and few workers
queue_bottleneck(queue_id, backlog_size) :-
    property{node_id: queue_id, key: 'backlog_count', value: backlog_size},
    count(worker_id : queue_worker{queue_id: queue_id, status: 'idle'}) == 0,
    backlog_size > 100

# Dead Letter Detection: Messages that have been NACKed multiple times
dead_letter(msg_id, queue_id) :-
    property{node_id: queue_id, key: 'retry_count', value: R},
    R > 5
