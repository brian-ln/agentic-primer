#!/bin/zsh

PORT=3000
SEAG_DIR="${0:A:h}"
LOG_FILE="$SEAG_DIR/server_$PORT.log"
PID_FILE="$SEAG_DIR/server_$PORT.pid"
URL="http://localhost:$PORT"

# Ensure required commands exist
for cmd in lsof curl ps awk tail; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo "Required command '$cmd' is missing. Please install it and try again." >&2
        exit 1
    fi
done

# Function to check if server is running by checking the PID file and verifying the command
is_running() {
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        # Check if a process with this PID exists
        if ps -p "$PID" > /dev/null 2>&1; then
            CMD=$(ps -p "$PID" -o args= 2>/dev/null || true)
            # Ensure the process looks like our server (bun running main.ts)
            if echo "$CMD" | grep -q "bun" && echo "$CMD" | grep -q "main.ts"; then
                return 0 # True, our server is running
            else
                return 2 # PID exists but it's not our server
            fi
        else
            return 1 # PID file present but process not running
        fi
    fi
    return 1 # False, it's not running
}

# Function to see if anything is listening on $PORT (TCP LISTEN)
is_bound() {
    if lsof -nP -iTCP:"$PORT" -sTCP:LISTEN >/dev/null 2>&1; then
        return 0 # True, port is bound
    fi
    return 1 # False, port is not bound
}

# Function to check if the process listening on $PORT is our server
is_our_server() {
    if ! is_bound; then
        return 1
    fi

    SERVER_PID=""
    if [ -f "$PID_FILE" ]; then
        SERVER_PID=$(cat "$PID_FILE")
    fi

    for pid in $(lsof -tiTCP:"$PORT" -sTCP:LISTEN 2>/dev/null || true); do
        if [ -n "$SERVER_PID" ] && [ "$pid" -eq "$SERVER_PID" ]; then
            return 0
        fi
        # If no PID file or mismatch, try checking the command line for our fingerprint
        CMD=$(ps -p "$pid" -o args= 2>/dev/null || true)
        if echo "$CMD" | grep -q "bun" && echo "$CMD" | grep -q "main.ts"; then
            return 0
        fi
    done
    return 1
}

# Helper: return bound PIDs (list) for $PORT
get_bound_pids() {
    lsof -tiTCP:"$PORT" -sTCP:LISTEN 2>/dev/null || true
}

# Helper: print processes listening on the port with details
who_is_on_port() {
    if ! is_bound; then
        echo "No process is listening on port $PORT."
        return
    fi
    echo "Processes listening on port $PORT:"
    lsof -nP -iTCP:"$PORT" -sTCP:LISTEN 2>/dev/null | awk '{printf "%s %s %s %s\n", $1, $2, $3, $9}'
    for pid in $(get_bound_pids); do
        echo "  -> PID $pid: $(ps -p $pid -o user= -o args= 2>/dev/null)"
    done
}

# Gracefully kill a list of PIDs, escalate to SIGKILL if needed
kill_pids_gracefully() {
    if [ $# -eq 0 ]; then
        echo "No PIDs provided to kill."
        return 1
    fi
    PIDS=($@)
    for pid in "${PIDS[@]}"; do
        if [ -z "$pid" ]; then continue; fi
        if ! ps -p "$pid" > /dev/null 2>&1; then
            echo "PID $pid is not running."
            continue
        fi
        echo "Terminating PID $pid..."
        kill "$pid" 2>/dev/null || true
    done

    # Wait up to 5s for processes to exit gracefully
    for i in {1..5}; do
        sleep 1
        still_running=()
        for pid in "${PIDS[@]}"; do
            if ps -p "$pid" > /dev/null 2>&1; then
                still_running+=("$pid")
            fi
        done
        if [ ${#still_running[@]} -eq 0 ]; then
            echo "Processes terminated."
            return 0
        fi
        echo "Waiting for processes to exit: ${still_running[*]}"
    done

    echo "Killing remaining processes with -9: ${still_running[*]}"
    kill -9 ${still_running[*]} 2>/dev/null || true
    # Give them a moment to die and recheck
    sleep 2
    final_still=()
    for pid in "${still_running[@]}"; do
        if ps -p "$pid" > /dev/null 2>&1; then
            final_still+=("$pid")
        fi
    done
    if [ ${#final_still[@]} -gt 0 ]; then
        echo "Failed to kill PIDs: ${final_still[*]}"
        return 1
    fi
    echo "Processes terminated."
    return 0
}

# Wait for port to be freed (returns 0 if freed within timeout in seconds)
wait_for_port_free() {
    local timeout=${1:-10}
    local waited=0
    while is_bound; do
        if [ "$waited" -ge "$timeout" ]; then
            return 1
        fi
        sleep 1
        waited=$((waited+1))
    done
    return 0
}

# Ensure port is free, attempt escalation (sudo kill -9) if necessary
ensure_port_free() {
    local timeout=${1:-10}
    if ! is_bound; then
        return 0
    fi
    echo "Attempting to free port $PORT..."
    PIDS=$(get_bound_pids)
    if [ -n "$PIDS" ]; then
        kill_pids_gracefully $PIDS || true
    fi
    if wait_for_port_free "$timeout"; then
        return 0
    fi

    # Escalate using sudo if available
    ESC_PIDS=$(get_bound_pids)
    if [ -n "$ESC_PIDS" ] && command -v sudo >/dev/null 2>&1; then
        echo "Escalating: attempting 'sudo kill -9' on $ESC_PIDS"
        sudo kill -9 $ESC_PIDS 2>/dev/null || true
        sleep 2
        if wait_for_port_free 5; then
            return 0
        fi
    fi

    echo "Port $PORT still bound after escalation."
    return 1
}

start() {
    FORCE=false
    WATCH=false
    
    # Simple argument parsing
    for arg in "$@"; do
        case $arg in
            --force|-f) FORCE=true ;; 
            --watch|-w) WATCH=true ;; 
        esac
    done

    # Handle stale or bad PID file
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        if ps -p "$PID" > /dev/null 2>&1; then
            CMD=$(ps -p "$PID" -o args= 2>/dev/null || true)
            if echo "$CMD" | grep -q "bun" && echo "$CMD" | grep -q "main.ts"; then
                echo "SEAG is already running with PID $PID." >&2
                return 0
            else
                echo "PID file points to PID $PID which is not our server; removing stale PID file."
                rm -f "$PID_FILE"
            fi
        else
            echo "Stale PID file found (PID $PID not running). Removing..."
            rm -f "$PID_FILE"
        fi
    fi

    # Check port binding
    if is_bound; then
        if is_our_server; then
            echo "SEAG process is already listening on port $PORT."
            return 0
        fi

        echo "Port $PORT is already bound. Details:"
        who_is_on_port

        if [ "$FORCE" = "true" ]; then
            echo "Force: attempting to free port $PORT"
            if ! ensure_port_free 10; then
                echo "Failed to free port $PORT. Aborting start."
                return 1
            fi
        else
            echo "Use '$0 start --force' to kill the process listening on port $PORT and start SEAG."
            return 1
        fi
    fi

    WATCH_FLAG=""
    if [ "$WATCH" = "true" ]; then
        WATCH_FLAG="--watch"
        echo "--- Starting server in background (WATCH MODE) ---"
    else
        echo "--- Starting server in background ---"
    fi

    cd "$SEAG_DIR" || exit 1
    nohup bun $WATCH_FLAG run main.ts > "$LOG_FILE" 2>&1 &
    SERVER_PID=$!
    echo $SERVER_PID > "$PID_FILE"
    echo "Server started with PID $SERVER_PID. Logs at $LOG_FILE"

    echo "--- Waiting for server to start (5 seconds) ---"
    sleep 5

    status # Run status check after starting
}

dev() {
    echo "--- Starting SEAG in Interactive Dev Mode (Watch + Hot) ---"
    cd "$SEAG_DIR" || exit 1
    bun --watch run main.ts
}

stop() {
    FORCE=false
    if [ "$1" = "--force" ] || [ "$1" = "-f" ]; then FORCE=true; fi

    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        if ps -p "$PID" > /dev/null 2>&1; then
            echo "--- Stopping server (PID: $PID) ---"
            kill_pids_gracefully "$PID"
            rm -f "$PID_FILE"
            echo "Server stopped."
            return
        else
            echo "PID file present but process $PID is not running. Removing PID file."
            rm -f "$PID_FILE"
        fi
    fi

    if is_bound; then
        echo "Something is listening on port $PORT:"
        who_is_on_port
        if [ "$FORCE" = "true" ]; then
            PIDS=$(get_bound_pids)
            if [ -n "$PIDS" ]; then
                kill_pids_gracefully $PIDS
                echo "Killed processes listening on port $PORT."
            fi
        else
            echo "Use '$0 stop --force' to kill the process(es) listening on port $PORT."
        fi
    else
        echo "Server is not running."
    fi
}

status() {
    echo "--- Checking server status ---"
    is_running
    RUN_RES=$?
    if [ "$RUN_RES" -eq 0 ]; then
        HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL/health")
        if [ "$HEALTH_STATUS" -eq 200 ]; then
            echo "Server is RUNNING on $URL (PID: $(cat $PID_FILE)). Health check PASSED."
        else
            echo "Server process is RUNNING (PID: $(cat $PID_FILE)) but health check FAILED with status: $HEALTH_STATUS."
            echo "--- Last 5 lines of log ---"
            tail -n 5 "$LOG_FILE"
        fi
    elif [ "$RUN_RES" -eq 2 ]; then
        echo "PID file points to a running process that is not our server. See details:"
        who_is_on_port
    else
        echo "Server is STOPPED."
        if is_bound; then
            echo "Port $PORT is bound by another process:" 
            who_is_on_port
        fi
    fi
}

open_url() {
    echo "Opening $URL in your default browser..."
    open "$URL"
}

case "$1" in
    start)
        shift
        start "$@"
        ;;
    dev)
        dev
        ;;
    stop)
        shift
        stop "$@"
        ;;
    restart)
        shift
        stop --force
        start "$@"
        ;;
    status)
        status
        ;;
    port)
        who_is_on_port
        ;;
    open)
        open_url
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status|port|open|dev} [--force] [--watch]"
        exit 1
        ;;
esac

exit 0