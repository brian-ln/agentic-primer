{
  "concepts": [
    {
      "id": "actor-model",
      "label": "Actor Model",
      "domains": ["computer-science", "concurrency"],
      "tags": ["concurrency", "message-passing", "isolation", "distributed-systems"],
      "description": "A computational model where actors are the fundamental units of computation. Actors process messages sequentially, maintain private state, and can create new actors. Inspired by physics and used in Erlang/OTP.",
      "references": ["erlang-otp", "message-passing", "supervision-tree", "process-isolation"]
    },
    {
      "id": "message-passing",
      "label": "Message Passing",
      "domains": ["computer-science", "concurrency"],
      "tags": ["communication", "asynchronous", "actors", "distributed-systems"],
      "description": "Communication mechanism where entities exchange data via messages rather than shared memory. Can be synchronous or asynchronous. Core primitive in actor systems and distributed computing.",
      "references": ["actor-model", "mailbox", "erlang-otp", "smalltalk"]
    },
    {
      "id": "erlang-otp",
      "label": "Erlang/OTP",
      "domains": ["computer-science", "system-design"],
      "tags": ["erlang", "fault-tolerance", "distributed-systems", "telecom"],
      "description": "Erlang Open Telecom Platform - a battle-tested framework for building fault-tolerant distributed systems. Features supervision trees, gen_server behaviors, and 'let it crash' philosophy.",
      "references": ["actor-model", "supervision-tree", "gen-server", "beam-vm", "let-it-crash"]
    },
    {
      "id": "supervision-tree",
      "label": "Supervision Tree",
      "domains": ["computer-science", "system-design"],
      "tags": ["fault-tolerance", "hierarchical", "recovery", "erlang"],
      "description": "Hierarchical organization of processes where supervisors monitor workers and restart them on failure. Provides fault isolation and automatic recovery with configurable restart strategies.",
      "references": ["erlang-otp", "let-it-crash", "fault-tolerance", "actor-model"]
    },
    {
      "id": "gen-server",
      "label": "gen_server Behavior",
      "domains": ["computer-science", "design-patterns"],
      "tags": ["erlang", "otp", "server", "lifecycle"],
      "description": "Generic server behavior in Erlang/OTP providing standardized lifecycle hooks (init, handle_call, handle_cast, terminate). Separates synchronous calls from asynchronous casts.",
      "references": ["erlang-otp", "behavior-pattern", "lifecycle-hooks", "call-cast"]
    },
    {
      "id": "gen-statem",
      "label": "gen_statem Behavior",
      "domains": ["computer-science", "design-patterns"],
      "tags": ["state-machine", "erlang", "otp", "transitions"],
      "description": "Generic state machine behavior in Erlang/OTP for actors with explicit state transitions. Each state has its own message handler function, enforcing valid transition logic.",
      "references": ["erlang-otp", "state-machine", "behavior-pattern", "finite-automata"]
    },
    {
      "id": "mailbox",
      "label": "Mailbox (Message Queue)",
      "domains": ["computer-science", "concurrency"],
      "tags": ["queue", "asynchronous", "actors", "message-passing"],
      "description": "FIFO queue for incoming messages in actor systems. Allows selective receive via pattern matching. Can grow unbounded, requiring backpressure mechanisms.",
      "references": ["message-passing", "actor-model", "pattern-matching", "backpressure"]
    },
    {
      "id": "let-it-crash",
      "label": "Let It Crash Philosophy",
      "domains": ["system-design", "software-engineering"],
      "tags": ["fault-tolerance", "erlang", "recovery", "simplicity"],
      "description": "Design philosophy: don't defensively handle every error, let processes crash and be restarted by supervisors. Simplifies code and improves reliability through recovery rather than prevention.",
      "references": ["erlang-otp", "supervision-tree", "fault-tolerance", "error-handling"]
    },
    {
      "id": "smalltalk",
      "label": "Smalltalk",
      "domains": ["computer-science", "programming-languages"],
      "tags": ["object-oriented", "message-passing", "reflection", "images"],
      "description": "Pure object-oriented language where 'everything is an object' and all computation is message sending. Influential on modern OOP, GUIs, and agile methodologies.",
      "references": ["message-passing", "object-oriented", "alan-kay", "reflection"]
    },
    {
      "id": "state-machine",
      "label": "State Machine",
      "domains": ["computer-science", "mathematics"],
      "tags": ["formal-methods", "transitions", "automata", "modeling"],
      "description": "Mathematical model of computation with a finite set of states and transitions between them. Used to model behavior, protocols, and lifecycle management.",
      "references": ["finite-automata", "transition-function", "gen-statem", "formal-verification"]
    },
    {
      "id": "graph-protocol",
      "label": "Graph Protocol",
      "domains": ["computer-science", "data-structures"],
      "tags": ["graphs", "protocol", "message-passing", "routing"],
      "description": "Protocol for interacting with nodes in a graph via message passing. Nodes are actors, edges are relationships, and all interactions happen through SEND primitive.",
      "references": ["actor-model", "message-passing", "graph-theory", "routing"]
    },
    {
      "id": "task-graph",
      "label": "Task Graph",
      "domains": ["computer-science", "system-design"],
      "tags": ["tasks", "dependencies", "workflow", "dag"],
      "description": "Graph representing tasks and their dependencies. Tasks are nodes with lifecycle states, edges represent relationships (depends_on, spawned_by, blocks).",
      "references": ["graph-protocol", "state-machine", "dag", "workflow-engine"]
    },
    {
      "id": "knowledge-graph",
      "label": "Knowledge Graph",
      "domains": ["computer-science", "knowledge-management"],
      "tags": ["knowledge", "semantic", "graph", "reasoning"],
      "description": "Graph structure for representing knowledge with entities as nodes and relationships as edges. Enables semantic search, inference, and knowledge synthesis.",
      "references": ["graph-theory", "semantic-web", "ontology", "reasoning"]
    },
    {
      "id": "memory-reconsolidation",
      "label": "Memory Reconsolidation",
      "domains": ["neuroscience", "cognitive-science"],
      "tags": ["memory", "neuroscience", "learning", "plasticity"],
      "description": "Process where retrieved memories become labile and must be re-stored. Allows memories to be updated or strengthened. Key mechanism in learning and therapy.",
      "references": ["memory-consolidation", "synaptic-plasticity", "learning", "cognitive-science"]
    },
    {
      "id": "access-pattern",
      "label": "Access Pattern",
      "domains": ["computer-science", "cognitive-science"],
      "tags": ["memory", "retrieval", "optimization", "caching"],
      "description": "Pattern of how data or memories are accessed over time. Informs caching strategies, memory organization, and retrieval mechanisms in both computers and brains.",
      "references": ["cache-hierarchy", "working-memory", "memory-reconsolidation", "temporal-locality"]
    },
    {
      "id": "event-sourcing",
      "label": "Event Sourcing",
      "domains": ["computer-science", "system-design"],
      "tags": ["architecture", "persistence", "cqrs", "audit"],
      "description": "Architectural pattern storing state changes as immutable events. Enables time travel, audit logs, replay, and event-driven architectures.",
      "references": ["cqrs", "append-only-log", "time-travel", "audit-trail"]
    },
    {
      "id": "time-travel-debugging",
      "label": "Time Travel Debugging",
      "domains": ["computer-science", "debugging"],
      "tags": ["debugging", "replay", "determinism", "history"],
      "description": "Debugging technique that records program execution and allows stepping backward through history. Requires deterministic replay or full state snapshots.",
      "references": ["event-sourcing", "replay", "determinism", "debugging"]
    },
    {
      "id": "category-theory",
      "label": "Category Theory",
      "domains": ["mathematics", "computer-science"],
      "tags": ["abstraction", "composition", "functors", "morphisms"],
      "description": "Branch of mathematics studying abstract structures through objects, morphisms, and composition. Provides theoretical foundation for functional programming and type systems.",
      "references": ["functors", "monads", "morphisms", "composition", "functional-programming"]
    },
    {
      "id": "lambda-calculus",
      "label": "Lambda Calculus",
      "domains": ["mathematics", "computer-science"],
      "tags": ["computation", "functions", "theory", "functional-programming"],
      "description": "Formal system for expressing computation based on function abstraction and application. Foundation of functional programming and type theory.",
      "references": ["functional-programming", "church-encoding", "recursion", "computation-theory"]
    },
    {
      "id": "set-theory",
      "label": "Set Theory",
      "domains": ["mathematics"],
      "tags": ["foundations", "logic", "collections", "cardinality"],
      "description": "Mathematical theory of sets and their properties. Foundation of modern mathematics, providing framework for defining numbers, functions, and structures.",
      "references": ["logic", "zfc", "cardinality", "relations"]
    },
    {
      "id": "functional-programming",
      "label": "Functional Programming",
      "domains": ["computer-science", "programming-paradigms"],
      "tags": ["immutability", "pure-functions", "composition", "declarative"],
      "description": "Programming paradigm treating computation as evaluation of mathematical functions. Emphasizes immutability, first-class functions, and declarative style.",
      "references": ["lambda-calculus", "immutability", "pure-functions", "higher-order-functions"]
    },
    {
      "id": "fault-tolerance",
      "label": "Fault Tolerance",
      "domains": ["system-design", "distributed-systems"],
      "tags": ["reliability", "recovery", "redundancy", "resilience"],
      "description": "System's ability to continue operating correctly despite component failures. Achieved through redundancy, replication, error detection, and recovery mechanisms.",
      "references": ["supervision-tree", "let-it-crash", "replication", "circuit-breaker"]
    },
    {
      "id": "process-isolation",
      "label": "Process Isolation",
      "domains": ["computer-science", "operating-systems"],
      "tags": ["isolation", "memory", "security", "fault-containment"],
      "description": "Separation of process memory spaces preventing cross-contamination. Critical for security and fault isolation in multi-process systems.",
      "references": ["actor-model", "operating-systems", "memory-protection", "erlang-otp"]
    },
    {
      "id": "behavior-pattern",
      "label": "OTP Behavior Pattern",
      "domains": ["software-engineering", "design-patterns"],
      "tags": ["contracts", "lifecycle", "standardization", "otp"],
      "description": "Standardized contract for actor implementations in Erlang/OTP. Defines lifecycle hooks and message handling patterns (gen_server, gen_statem, supervisor).",
      "references": ["gen-server", "gen-statem", "erlang-otp", "design-patterns"]
    },
    {
      "id": "pattern-matching",
      "label": "Pattern Matching",
      "domains": ["computer-science", "programming-languages"],
      "tags": ["destructuring", "dispatch", "functional", "erlang"],
      "description": "Language feature for matching data structures against patterns. Core to functional programming and Erlang's selective receive mechanism.",
      "references": ["functional-programming", "erlang-otp", "mailbox", "algebraic-types"]
    },
    {
      "id": "backpressure",
      "label": "Backpressure",
      "domains": ["computer-science", "system-design"],
      "tags": ["flow-control", "queues", "overload", "reactive"],
      "description": "Mechanism to slow down message producers when consumers can't keep up. Prevents queue overflow and resource exhaustion in streaming systems.",
      "references": ["mailbox", "flow-control", "reactive-streams", "bounded-queues"]
    },
    {
      "id": "circuit-breaker",
      "label": "Circuit Breaker Pattern",
      "domains": ["system-design", "design-patterns"],
      "tags": ["fault-tolerance", "resilience", "failure-detection", "cascading"],
      "description": "Design pattern preventing cascading failures by detecting faults and temporarily blocking operations to failing services. Three states: closed, open, half-open.",
      "references": ["fault-tolerance", "resilience", "cascading-failure", "health-check"]
    },
    {
      "id": "dag",
      "label": "Directed Acyclic Graph (DAG)",
      "domains": ["mathematics", "computer-science"],
      "tags": ["graph-theory", "dependencies", "ordering", "scheduling"],
      "description": "Directed graph with no cycles. Used to represent dependencies, task scheduling, version control (git), and computation graphs.",
      "references": ["graph-theory", "topological-sort", "task-graph", "dependency-resolution"]
    },
    {
      "id": "graph-theory",
      "label": "Graph Theory",
      "domains": ["mathematics", "computer-science"],
      "tags": ["graphs", "nodes", "edges", "algorithms"],
      "description": "Mathematical study of graphs (nodes and edges). Provides algorithms for traversal, shortest paths, connectivity, and optimization.",
      "references": ["dag", "graph-protocol", "knowledge-graph", "algorithms"]
    },
    {
      "id": "beam-vm",
      "label": "BEAM Virtual Machine",
      "domains": ["computer-science", "runtime-systems"],
      "tags": ["vm", "erlang", "concurrency", "scheduler"],
      "description": "Erlang's virtual machine optimized for massive concurrency, low-latency, and fault tolerance. Features preemptive scheduling and lightweight processes.",
      "references": ["erlang-otp", "green-threads", "scheduler", "concurrent-vm"]
    },
    {
      "id": "green-threads",
      "label": "Green Threads (Lightweight Processes)",
      "domains": ["computer-science", "concurrency"],
      "tags": ["concurrency", "user-space", "scheduler", "erlang"],
      "description": "User-space threads scheduled by runtime rather than OS. Enables massive concurrency (millions of processes in Erlang) with low overhead.",
      "references": ["beam-vm", "erlang-otp", "scheduler", "concurrency"]
    },
    {
      "id": "homoiconicity",
      "label": "Homoiconicity",
      "domains": ["computer-science", "programming-languages"],
      "tags": ["lisp", "metaprogramming", "code-as-data", "reflection"],
      "description": "Property where code and data have the same representation. Enables powerful metaprogramming (macros, code generation). Core to Lisp family.",
      "references": ["lisp", "macros", "metaprogramming", "reflection"]
    },
    {
      "id": "lisp",
      "label": "Lisp",
      "domains": ["computer-science", "programming-languages"],
      "tags": ["functional", "symbolic", "ai", "homoiconic"],
      "description": "Family of programming languages with fully parenthesized prefix notation. Known for homoiconicity, powerful macros, and influence on AI research.",
      "references": ["homoiconicity", "functional-programming", "lambda-calculus", "symbolic-ai"]
    },
    {
      "id": "determinism",
      "label": "Determinism",
      "domains": ["computer-science", "mathematics"],
      "tags": ["reproducibility", "testing", "replay", "predictability"],
      "description": "Property where same input always produces same output. Critical for testing, debugging, and replay. Challenged by concurrency and external I/O.",
      "references": ["time-travel-debugging", "pure-functions", "reproducibility", "testing"]
    },
    {
      "id": "immutability",
      "label": "Immutability",
      "domains": ["computer-science", "functional-programming"],
      "tags": ["functional", "concurrency", "safety", "persistence"],
      "description": "Property where data cannot be modified after creation. Simplifies reasoning, enables safe concurrency, and supports time-travel debugging.",
      "references": ["functional-programming", "persistent-data-structures", "concurrency", "event-sourcing"]
    },
    {
      "id": "pure-functions",
      "label": "Pure Functions",
      "domains": ["computer-science", "functional-programming"],
      "tags": ["determinism", "referential-transparency", "testing", "functional"],
      "description": "Functions with no side effects that always return same output for same input. Enables equational reasoning, memoization, and parallelization.",
      "references": ["functional-programming", "referential-transparency", "determinism", "testing"]
    },
    {
      "id": "composition",
      "label": "Function Composition",
      "domains": ["mathematics", "computer-science"],
      "tags": ["functional", "combinators", "modularity", "category-theory"],
      "description": "Combining simple functions to build complex ones. Core principle in functional programming and category theory. Enables modular design.",
      "references": ["functional-programming", "category-theory", "combinator", "pipeline"]
    },
    {
      "id": "type-system",
      "label": "Type System",
      "domains": ["computer-science", "programming-languages"],
      "tags": ["types", "safety", "verification", "static-analysis"],
      "description": "System for classifying values and expressions by type. Enables compile-time error detection, optimization, and documentation. Ranges from weak to strong typing.",
      "references": ["type-theory", "static-typing", "type-inference", "dependent-types"]
    },
    {
      "id": "polymorphism",
      "label": "Polymorphism",
      "domains": ["computer-science", "programming-languages"],
      "tags": ["generics", "abstraction", "reuse", "types"],
      "description": "Ability to write code that works with multiple types. Includes parametric (generics), ad-hoc (overloading), and subtype polymorphism.",
      "references": ["type-system", "generics", "interfaces", "abstraction"]
    },
    {
      "id": "reactive-systems",
      "label": "Reactive Systems",
      "domains": ["system-design", "distributed-systems"],
      "tags": ["responsive", "resilient", "elastic", "message-driven"],
      "description": "Systems designed to be responsive, resilient, elastic, and message-driven (Reactive Manifesto). Built on asynchronous message passing.",
      "references": ["message-passing", "backpressure", "fault-tolerance", "elasticity"]
    },
    {
      "id": "cqrs",
      "label": "CQRS (Command Query Responsibility Segregation)",
      "domains": ["system-design", "architecture"],
      "tags": ["architecture", "separation", "scalability", "event-sourcing"],
      "description": "Pattern separating read and write operations. Enables independent scaling, optimization, and consistency models for commands vs queries.",
      "references": ["event-sourcing", "eventual-consistency", "read-model", "write-model"]
    },
    {
      "id": "workflow-engine",
      "label": "Workflow Engine",
      "domains": ["system-design", "business-logic"],
      "tags": ["orchestration", "tasks", "dependencies", "automation"],
      "description": "System for executing multi-step workflows with dependencies, conditions, and error handling. Examples: Airflow, Temporal, Step Functions.",
      "references": ["task-graph", "dag", "orchestration", "state-machine"]
    },
    {
      "id": "semantic-web",
      "label": "Semantic Web",
      "domains": ["computer-science", "knowledge-representation"],
      "tags": ["rdf", "ontology", "linked-data", "w3c"],
      "description": "Extension of the web enabling machines to understand data meaning through standards like RDF, OWL, and SPARQL. Enables data integration and reasoning.",
      "references": ["knowledge-graph", "ontology", "rdf", "reasoning"]
    },
    {
      "id": "ontology",
      "label": "Ontology",
      "domains": ["philosophy", "knowledge-representation"],
      "tags": ["concepts", "relationships", "taxonomy", "formal"],
      "description": "Formal representation of knowledge domains defining concepts, properties, and relationships. Used in AI, semantic web, and knowledge management.",
      "references": ["semantic-web", "knowledge-graph", "taxonomy", "reasoning"]
    },
    {
      "id": "cognitive-architecture",
      "label": "Cognitive Architecture",
      "domains": ["cognitive-science", "ai"],
      "tags": ["cognition", "ai", "memory", "learning"],
      "description": "Framework for understanding or simulating cognitive processes (perception, memory, learning, reasoning). Examples: ACT-R, SOAR, CLARION.",
      "references": ["cognitive-science", "memory-systems", "learning", "reasoning"]
    },
    {
      "id": "working-memory",
      "label": "Working Memory",
      "domains": ["cognitive-science", "neuroscience"],
      "tags": ["memory", "cognition", "attention", "capacity"],
      "description": "Limited-capacity system for temporarily holding and manipulating information. Critical for reasoning, comprehension, and learning. ~7 items capacity.",
      "references": ["memory-systems", "cognitive-load", "attention", "prefrontal-cortex"]
    },
    {
      "id": "synaptic-plasticity",
      "label": "Synaptic Plasticity",
      "domains": ["neuroscience", "biology"],
      "tags": ["learning", "memory", "neurons", "ltp-ltd"],
      "description": "Ability of synapses to strengthen or weaken over time in response to activity. Basis of learning and memory in biological neural networks.",
      "references": ["memory-reconsolidation", "ltp-ltd", "learning", "hebbian-learning"]
    },
    {
      "id": "distributed-systems",
      "label": "Distributed Systems",
      "domains": ["computer-science", "system-design"],
      "tags": ["distribution", "consensus", "cap-theorem", "replication"],
      "description": "Systems where components run on networked computers and coordinate via message passing. Challenges: consistency, availability, partition tolerance (CAP theorem).",
      "references": ["message-passing", "consensus", "cap-theorem", "replication"]
    },
    {
      "id": "consensus",
      "label": "Consensus Algorithms",
      "domains": ["computer-science", "distributed-systems"],
      "tags": ["agreement", "raft", "paxos", "distributed"],
      "description": "Algorithms enabling distributed nodes to agree on shared state despite failures. Examples: Paxos, Raft, Byzantine consensus.",
      "references": ["distributed-systems", "raft", "paxos", "fault-tolerance"]
    },
    {
      "id": "alan-kay",
      "label": "Alan Kay",
      "domains": ["computer-science", "history"],
      "tags": ["smalltalk", "oop", "dynabook", "visionary"],
      "description": "Computer scientist who pioneered object-oriented programming (Smalltalk), GUIs, and personal computing. Coined 'The best way to predict the future is to invent it.'",
      "references": ["smalltalk", "object-oriented", "xerox-parc", "personal-computing"]
    }
  ]
}
