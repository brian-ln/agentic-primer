#!/usr/bin/env bun
/**
 * Router Hierarchical Routing Tests
 *
 * Tests for MessageRouter's hierarchical routing support.
 * Validates integration between router and supervisor-based delegation.
 */

import { describe, test, expect, beforeEach } from 'bun:test';
import { MessageRouter } from '../router';
import { SupervisorBase, LeafActor } from '../supervisor-base';
import { address, createMessage, generateCorrelationId } from '../message';
import GraphStore from '../../graph';
import { ProgramManager } from '../../entities/program';

describe('MessageRouter - Hierarchical Routing', () => {
  let store: GraphStore;
  let programManager: ProgramManager;
  let router: MessageRouter;

  beforeEach(() => {
    store = new GraphStore();
    programManager = new ProgramManager(store);
    router = new MessageRouter(store, programManager);
  });

  describe('Router Integration', () => {
    test('registers supervisor with router', () => {
      const supervisor = new SupervisorBase('domain', router);

      router.registerActor('domain', supervisor);

      // Should not throw
      expect(true).toBe(true);
    });

    test('routes hierarchical message through registered supervisor', async () => {
      const root = new SupervisorBase('root', router);
      const inference = new LeafActor('inference', router, async (msg) => ({
        actor: 'inference',
        payload: msg.payload,
      }));

      root.addChild('inference', inference);
      router.registerActor('root', root);

      const message = createMessage(
        address('root/inference'),
        'process',
        { input: 'test' },
        {
          pattern: 'ask',
          from: address('client'),
          correlationId: generateCorrelationId(),
        }
      );

      const response = await router.ask(message);

      expect(response.success).toBe(true);
      expect(response.payload.actor).toBe('inference');
      expect(response.payload.payload).toEqual({ input: 'test' });
    });

    test('routes through multi-level hierarchy via router', async () => {
      const root = new SupervisorBase('root', router);
      const domain = new SupervisorBase('domain', router);
      const services = new SupervisorBase('services', router);
      const llm = new LeafActor('llm', router, async (msg) => ({
        service: 'llm',
        depth: 3,
        data: msg.payload,
      }));

      services.addChild('llm', llm);
      domain.addChild('services', services);
      root.addChild('domain', domain);

      router.registerActor('root', root);

      const message = createMessage(
        address('root/domain/services/llm'),
        'inference',
        { prompt: 'hello' },
        {
          pattern: 'ask',
          from: address('client'),
        }
      );

      const response = await router.ask(message);

      expect(response.success).toBe(true);
      expect(response.payload.service).toBe('llm');
      expect(response.payload.depth).toBe(3);
      expect(response.payload.data).toEqual({ prompt: 'hello' });
    });

    test('returns error if root supervisor not registered', async () => {
      const message = createMessage(
        address('unregistered/child'),
        'test',
        {},
        {
          pattern: 'ask',
          from: address('client'),
        }
      );

      const response = await router.ask(message);

      expect(response.success).toBe(false);
      expect(response.error).toContain('Root supervisor not found');
      expect(response.error).toContain('unregistered');
    });
  });

  describe('Mixed Routing (Flat + Hierarchical)', () => {
    test('routes flat ID messages (legacy)', async () => {
      // Create a program node
      const programNode = store.create('program', {
        label: 'Program',
        properties: {
          impl: 'return { result: "flat routing works" };',
        },
      });

      const message = createMessage(
        address(programNode.id),
        'execute',
        {},
        {
          pattern: 'ask',
          from: address('client'),
        }
      );

      const response = await router.ask(message);

      expect(response.success).toBe(true);
      expect(response.payload.result).toBe('flat routing works');
    });

    test('routes hierarchical path messages (new)', async () => {
      const root = new SupervisorBase('root', router);
      const leaf = new LeafActor('leaf', router, async () => ({
        result: 'hierarchical routing works',
      }));

      root.addChild('leaf', leaf);
      router.registerActor('root', root);

      const message = createMessage(
        address('root/leaf'),
        'execute',
        {},
        {
          pattern: 'ask',
          from: address('client'),
        }
      );

      const response = await router.ask(message);

      expect(response.success).toBe(true);
      expect(response.payload.result).toBe('hierarchical routing works');
    });

    test('handles both routing modes in same session', async () => {
      // Set up flat routing (program node)
      const programNode = store.create('program', {
        label: 'Program',
        properties: {
          impl: 'return { source: "flat" };',
        },
      });

      // Set up hierarchical routing (supervisor)
      const root = new SupervisorBase('root', router);
      const leaf = new LeafActor('leaf', router, async () => ({
        source: 'hierarchical',
      }));

      root.addChild('leaf', leaf);
      router.registerActor('root', root);

      // Route flat message
      const flatMsg = createMessage(
        address(programNode.id),
        'test',
        {},
        { pattern: 'ask', correlationId: generateCorrelationId(), 'ask', from: address('client') }
      );

      const flatResponse = await router.ask(flatMsg);
      expect(flatResponse.success).toBe(true);
      expect(flatResponse.payload.source).toBe('flat');

      // Route hierarchical message
      const hierMsg = createMessage(
        address('root/leaf'),
        'test',
        {},
        { pattern: 'ask', correlationId: generateCorrelationId(), 'ask', from: address('client') }
      );

      const hierResponse = await router.ask(hierMsg);
      expect(hierResponse.success).toBe(true);
      expect(hierResponse.payload.source).toBe('hierarchical');
    });
  });

  describe('Tell Pattern', () => {
    test('routes tell messages hierarchically', async () => {
      const root = new SupervisorBase('root', router);
      let messageReceived = false;
      let receivedPayload: any = null;

      const leaf = new LeafActor('leaf', router, async (msg) => {
        messageReceived = true;
        receivedPayload = msg.payload;
        return { ok: true };
      });

      root.addChild('leaf', leaf);
      router.registerActor('root', root);

      const message = createMessage(
        address('root/leaf'),
        'notify',
        { data: 'test notification' },
        {
          pattern: 'tell',
          from: address('client'),
        }
      );

      await router.tell(message);

      // Give async processing time to complete
      await new Promise(resolve => setTimeout(resolve, 10));

      expect(messageReceived).toBe(true);
      expect(receivedPayload).toEqual({ data: 'test notification' });
    });
  });

  describe('Error Handling', () => {
    test('propagates error from leaf actor', async () => {
      const root = new SupervisorBase('root', router);
      const failingLeaf = new LeafActor('failing', router, async () => {
        throw new Error('Leaf actor failed');
      });

      root.addChild('failing', failingLeaf);
      router.registerActor('root', root);

      const message = createMessage(
        address('root/failing'),
        'test',
        {},
        { pattern: 'ask', correlationId: generateCorrelationId(), 'ask', from: address('client') }
      );

      const response = await router.ask(message);

      expect(response.success).toBe(false);
      expect(response.error).toBe('Leaf actor failed');
    });

    test('returns error for non-existent child', async () => {
      const root = new SupervisorBase('root', router);
      router.registerActor('root', root);

      const message = createMessage(
        address('root/nonexistent'),
        'test',
        {},
        { pattern: 'ask', correlationId: generateCorrelationId(), 'ask', from: address('client') }
      );

      const response = await router.ask(message);

      expect(response.success).toBe(false);
      expect(response.error).toContain('Child not found: nonexistent');
    });
  });

  describe('Performance', () => {
    test('handles concurrent hierarchical requests', async () => {
      const root = new SupervisorBase('root', router);
      const domain = new SupervisorBase('domain', router);

      // Add multiple leaf actors
      for (let i = 0; i < 5; i++) {
        const leaf = new LeafActor(`worker-${i}`, router, async (msg) => ({
          worker: i,
          payload: msg.payload,
        }));
        domain.addChild(`worker-${i}`, leaf);
      }

      root.addChild('domain', domain);
      router.registerActor('root', root);

      // Send concurrent messages
      const promises = [];
      for (let i = 0; i < 50; i++) {
        const workerId = i % 5;
        const message = createMessage(
          address(`root/domain/worker-${workerId}`),
          'work',
          { task: i },
          { pattern: 'ask', correlationId: generateCorrelationId(), 'ask', from: address('client') }
        );
        promises.push(router.ask(message));
      }

      const responses = await Promise.all(promises);

      // All should succeed
      expect(responses.length).toBe(50);
      for (let i = 0; i < 50; i++) {
        expect(responses[i].success).toBe(true);
        expect(responses[i].payload.worker).toBe(i % 5);
        expect(responses[i].payload.payload.task).toBe(i);
      }
    });
  });
});
