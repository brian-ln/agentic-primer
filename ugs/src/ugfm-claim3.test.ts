import { describe, it, expect, beforeEach } from 'bun:test';
import GraphStore from './graph';
import { generateActorBoilerplate, generateActorBoilerplatePython } from './ugfm-claim3';
import { writeFileSync } from 'node:fs';
import { mkdtempSync, rmSync } from 'node:fs';
import { join } from 'node:path';
import { tmpdir } from 'node:os';

describe('UGFM Claim 3: Actor Graph → TypeScript Boilerplate Generation', () => {
  let store: GraphStore;

  beforeEach(() => {
    store = new GraphStore(':memory:');
  });

  describe('3.1 Simple actor graph: 2 actors, 1 message channel', () => {
    beforeEach(async () => {
      // Actor nodes
      await store.addNode('orchestrator', 'Actor', { name: 'orchestrator', role: 'coordinator' });
      await store.addNode('worker', 'Actor', { name: 'worker', role: 'executor' });
      // Message channel edge
      await store.addEdge('chan-0', 'orchestrator', 'worker', 'MessageChannel', { messageType: 'RunTask' });
    });

    it('generates one class per actor node', () => {
      const result = generateActorBoilerplate(store);
      expect(result.actorCount).toBe(2);
      expect(result.actors.map(a => a.className)).toContain('OrchestratorActor');
      expect(result.actors.map(a => a.className)).toContain('WorkerActor');
    });

    it('preserves role property in generated class', () => {
      const result = generateActorBoilerplate(store);
      const orchestrator = result.actors.find(a => a.className === 'OrchestratorActor')!;
      expect(orchestrator.role).toBe('coordinator');
    });

    it('generates handleMessage with correct message type case arm', () => {
      const result = generateActorBoilerplate(store);
      const orchestrator = result.actors.find(a => a.className === 'OrchestratorActor')!;
      expect(orchestrator.source).toContain("case 'RunTask'");
      expect(orchestrator.messageTypes).toContain('RunTask');
    });

    it('combined source is valid TypeScript structure', () => {
      const result = generateActorBoilerplate(store);
      expect(result.combinedSource).toContain('export class OrchestratorActor');
      expect(result.combinedSource).toContain('export class WorkerActor');
      expect(result.combinedSource).toContain('handleMessage(message: Message)');
    });

    it('can write generated source to disk', () => {
      const result = generateActorBoilerplate(store);
      // Demonstrates the projection produces a real file artifact
      writeFileSync('/tmp/ugfm-generated-actors.ts', result.combinedSource, 'utf-8');
      const { readFileSync } = require('node:fs');
      const written = readFileSync('/tmp/ugfm-generated-actors.ts', 'utf-8');
      expect(written).toContain('OrchestratorActor');
      expect(written).toContain('Generated by UGFM Claim 3');
    });
  });

  describe('3.2 Multi-actor system: agentic-primer actor topology', () => {
    beforeEach(async () => {
      // 4-actor system modeled after agentic-primer
      await store.addNode('router',   'Actor', { name: 'router',   role: 'dispatcher' });
      await store.addNode('logger',   'Actor', { name: 'logger',   role: 'observer' });
      await store.addNode('worker-1', 'Actor', { name: 'worker-1', role: 'executor' });
      await store.addNode('worker-2', 'Actor', { name: 'worker-2', role: 'executor' });
      await store.addEdge('c0', 'router',   'worker-1', 'MessageChannel', { messageType: 'Task' });
      await store.addEdge('c1', 'router',   'worker-2', 'MessageChannel', { messageType: 'Task' });
      await store.addEdge('c2', 'router',   'logger',   'MessageChannel', { messageType: 'Log' });
      await store.addEdge('c3', 'worker-1', 'logger',   'MessageChannel', { messageType: 'Log' });
    });

    it('generates correct actor count', () => {
      const result = generateActorBoilerplate(store);
      expect(result.actorCount).toBe(4);
    });

    it('router has 2 distinct message types (Task and Log)', () => {
      const result = generateActorBoilerplate(store);
      const router = result.actors.find(a => a.className === 'RouterActor')!;
      expect(router.messageTypes).toHaveLength(3);
      expect(router.messageTypes).toContain('Task');
      expect(router.messageTypes).toContain('Log');
    });

    it('worker with no outgoing channels generates no case arms', () => {
      const result = generateActorBoilerplate(store);
      const w2 = result.actors.find(a => a.className === 'Worker2Actor')!;
      // worker-2 has no outgoing message channels
      expect(w2.messageTypes).toHaveLength(0);
      expect(w2.source).toContain('No outgoing message channels defined');
    });

    it('total message type count matches outgoing edge count', () => {
      const result = generateActorBoilerplate(store);
      // router: 3 out (Task, Task, Log), worker-1: 1 out (Log), worker-2: 0, logger: 0
      expect(result.messageTypeCount).toBe(4);
    });
  });

  describe('3.3 Graph IS the specification — projection is deterministic', () => {
    it('same graph produces identical output on repeated calls', async () => {
      await store.addNode('a', 'Actor', { name: 'a', role: 'producer' });
      await store.addNode('b', 'Actor', { name: 'b', role: 'consumer' });
      await store.addEdge('c', 'a', 'b', 'MessageChannel', { messageType: 'Data' });

      const result1 = generateActorBoilerplate(store);
      const result2 = generateActorBoilerplate(store);

      expect(result1.combinedSource).toBe(result2.combinedSource);
    });

    it('adding a node changes the output', async () => {
      await store.addNode('a', 'Actor', { name: 'a', role: 'producer' });
      const before = generateActorBoilerplate(store);

      await store.addNode('b', 'Actor', { name: 'b', role: 'consumer' });
      const after = generateActorBoilerplate(store);

      expect(after.actorCount).toBe(before.actorCount + 1);
      expect(after.combinedSource).toContain('BActor');
    });

    it('non-Actor nodes are excluded from projection', async () => {
      await store.addNode('a', 'Actor', { name: 'a', role: 'producer' });
      await store.addNode('meta', 'Config', { name: 'meta', role: 'config' });
      const result = generateActorBoilerplate(store);
      // Only Actor nodes are projected
      expect(result.actorCount).toBe(1);
      expect(result.actors.map(a => a.className)).not.toContain('MetaConfig');
    });

    it('MessageChannel edges are projected; other edge types are ignored', async () => {
      await store.addNode('a', 'Actor', { name: 'a', role: 'producer' });
      await store.addNode('b', 'Actor', { name: 'b', role: 'consumer' });
      await store.addEdge('c1', 'a', 'b', 'MessageChannel', { messageType: 'Data' });
      await store.addEdge('c2', 'a', 'b', 'DependsOn', { blocking: true });  // not MessageChannel
      const result = generateActorBoilerplate(store);
      const a = result.actors.find(ac => ac.className === 'AActor')!;
      // Only the MessageChannel edge contributes a case arm
      expect(a.messageTypes).toHaveLength(1);
      expect(a.messageTypes).toContain('Data');
    });
  });
});

describe('UGFM Claim 3: Python Projection — same graph, different target language', () => {
  let store: GraphStore;

  beforeEach(() => {
    store = new GraphStore(':memory:');
  });

  describe('3.X Python projection', () => {
    beforeEach(async () => {
      await store.addNode('orchestrator', 'Actor', { name: 'orchestrator', role: 'coordinator' });
      await store.addNode('worker', 'Actor', { name: 'worker', role: 'executor' });
      await store.addEdge('chan-0', 'orchestrator', 'worker', 'MessageChannel', { messageType: 'RunTask' });
    });

    it('generates Python class definitions for each actor', () => {
      const result = generateActorBoilerplatePython(store);
      expect(result).toContain('class OrchestratorActor');
      expect(result).toContain('class WorkerActor');
    });

    it('contains Python header with dataclass imports', () => {
      const result = generateActorBoilerplatePython(store);
      expect(result).toContain('from dataclasses import dataclass');
      expect(result).toContain('class Message:');
      expect(result).toContain('Generated by UGFM Claim 3');
    });

    it('generates handle_message method on each actor class', () => {
      const result = generateActorBoilerplatePython(store);
      expect(result).toContain('def handle_message(self, message: Message) -> None:');
      expect(result).toContain('def get_state(self) -> dict:');
    });

    it('generates message type conditional arms for outgoing channels', () => {
      const result = generateActorBoilerplatePython(store);
      // orchestrator has an outgoing RunTask channel
      expect(result).toContain("if message.type == 'RunTask'");
    });

    it('actor with no outgoing channels gets a pass comment', () => {
      const result = generateActorBoilerplatePython(store);
      expect(result).toContain('No outgoing message channels defined');
    });

    it('Python output passes py_compile syntax validation', async () => {
      const result = generateActorBoilerplatePython(store);
      const dir = mkdtempSync(join(tmpdir(), 'ugfm-py-'));
      const pyFile = join(dir, 'actors.py');
      try {
        writeFileSync(pyFile, result, 'utf-8');
        const proc = Bun.spawn(['python3', '-m', 'py_compile', pyFile], {
          stdout: 'pipe',
          stderr: 'pipe',
        });
        const exitCode = await proc.exited;
        if (exitCode !== 0) {
          const stderr = await new Response(proc.stderr).text();
          throw new Error(`py_compile failed (exit ${exitCode}): ${stderr}`);
        }
        expect(exitCode).toBe(0);
      } finally {
        rmSync(dir, { recursive: true, force: true });
      }
    });

    it('single graph spec produces both TypeScript and Python — proves language-agnostic model', async () => {
      // Key claim: same GraphStore → valid TypeScript AND valid Python
      const tsResult = generateActorBoilerplate(store);
      const pyResult = generateActorBoilerplatePython(store);

      // TypeScript output is valid structure
      expect(tsResult.combinedSource).toContain('export class OrchestratorActor');
      expect(tsResult.combinedSource).toContain('handleMessage(message: Message)');
      expect(tsResult.actorCount).toBe(2);

      // Python output is valid structure
      expect(pyResult).toContain('class OrchestratorActor');
      expect(pyResult).toContain('def handle_message(self, message: Message)');

      // Both derived from the same spec — actor names are consistent
      expect(tsResult.actors.map(a => a.className)).toContain('OrchestratorActor');
      expect(pyResult).toContain('class OrchestratorActor');

      // Python output also passes syntax validation
      const dir = mkdtempSync(join(tmpdir(), 'ugfm-py-dual-'));
      const pyFile = join(dir, 'actors_dual.py');
      try {
        writeFileSync(pyFile, pyResult, 'utf-8');
        const proc = Bun.spawn(['python3', '-m', 'py_compile', pyFile], {
          stdout: 'pipe',
          stderr: 'pipe',
        });
        const exitCode = await proc.exited;
        expect(exitCode).toBe(0);
      } finally {
        rmSync(dir, { recursive: true, force: true });
      }
    });
  });
});
