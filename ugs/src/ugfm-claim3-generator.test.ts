import { describe, it, expect, beforeEach } from 'bun:test';
import { writeFile } from 'node:fs/promises';
import GraphStore from './graph';
import { generateActorBoilerplate } from './ugfm-claim3';
import { writeFileSync, readFileSync } from 'node:fs';

/**
 * UGFM Claim 3 Extension: Actor Graph → TypeScript Boilerplate Generator
 *
 * Demonstrates UGFM Claim 3 from an implementation-generation angle:
 * a formal actor graph (nodes + MessageChannel edges) is projected to
 * runnable TypeScript class stubs via generateActorBoilerplate().
 *
 * The graph IS the specification; the projection function IS the translator.
 * Same graph → identical output (deterministic). Graph changes → output changes.
 * Projection produces real file artifacts (written to disk).
 */

describe('UGFM Claim 3 (generation): Actor Graph → TypeScript Boilerplate', () => {
  let store: GraphStore;

  beforeEach(() => {
    store = new GraphStore(':memory:');
  });

  describe('3G.1 Simple actor graph: 2 actors, 1 message channel', () => {
    beforeEach(async () => {
      await store.addNode('orchestrator', 'Actor', { name: 'orchestrator', role: 'coordinator' });
      await store.addNode('worker', 'Actor', { name: 'worker', role: 'executor' });
      await store.addEdge('chan-0', 'orchestrator', 'worker', 'MessageChannel', { messageType: 'RunTask' });
    });

    it('generates one class per actor node', () => {
      const result = generateActorBoilerplate(store);
      expect(result.actorCount).toBe(2);
      expect(result.actors.map(a => a.className)).toContain('OrchestratorActor');
      expect(result.actors.map(a => a.className)).toContain('WorkerActor');
    });

    it('preserves role property in generated class', () => {
      const result = generateActorBoilerplate(store);
      const orchestrator = result.actors.find(a => a.className === 'OrchestratorActor')!;
      expect(orchestrator.role).toBe('coordinator');
    });

    it('generates handleMessage with correct message type case arm', () => {
      const result = generateActorBoilerplate(store);
      const orchestrator = result.actors.find(a => a.className === 'OrchestratorActor')!;
      expect(orchestrator.source).toContain("case 'RunTask'");
      expect(orchestrator.messageTypes).toContain('RunTask');
    });

    it('combined source is valid TypeScript structure', () => {
      const result = generateActorBoilerplate(store);
      expect(result.combinedSource).toContain('export class OrchestratorActor');
      expect(result.combinedSource).toContain('export class WorkerActor');
      expect(result.combinedSource).toContain('handleMessage(message: Message)');
    });

    it('can write generated source to disk (projection produces real file artifacts)', () => {
      const result = generateActorBoilerplate(store);
      writeFileSync('/tmp/ugfm-generated-actors.ts', result.combinedSource, 'utf-8');
      const written = readFileSync('/tmp/ugfm-generated-actors.ts', 'utf-8');
      expect(written).toContain('OrchestratorActor');
      expect(written).toContain('Generated by UGFM Claim 3');
    });
  });

  describe('3G.2 Multi-actor system: agentic-primer actor topology', () => {
    beforeEach(async () => {
      await store.addNode('router',   'Actor', { name: 'router',   role: 'dispatcher' });
      await store.addNode('logger',   'Actor', { name: 'logger',   role: 'observer' });
      await store.addNode('worker-1', 'Actor', { name: 'worker-1', role: 'executor' });
      await store.addNode('worker-2', 'Actor', { name: 'worker-2', role: 'executor' });
      // router → worker-1: Task
      await store.addEdge('c0', 'router',   'worker-1', 'MessageChannel', { messageType: 'Task' });
      // router → worker-2: Task
      await store.addEdge('c1', 'router',   'worker-2', 'MessageChannel', { messageType: 'Task' });
      // router → logger: Log
      await store.addEdge('c2', 'router',   'logger',   'MessageChannel', { messageType: 'Log' });
      // worker-1 → logger: Log
      await store.addEdge('c3', 'worker-1', 'logger',   'MessageChannel', { messageType: 'Log' });
    });

    it('generates correct actor count', () => {
      const result = generateActorBoilerplate(store);
      expect(result.actorCount).toBe(4);
    });

    it('router has 3 outgoing message channel edges (Task, Task, Log)', () => {
      const result = generateActorBoilerplate(store);
      const router = result.actors.find(a => a.className === 'RouterActor')!;
      // router has 3 outgoing edges: c0(Task), c1(Task), c2(Log)
      expect(router.messageTypes).toHaveLength(3);
      expect(router.messageTypes).toContain('Task');
      expect(router.messageTypes).toContain('Log');
    });

    it('worker-2 with no outgoing channels generates no case arms', () => {
      const result = generateActorBoilerplate(store);
      const w2 = result.actors.find(a => a.className === 'Worker2Actor')!;
      expect(w2.messageTypes).toHaveLength(0);
      expect(w2.source).toContain('No outgoing message channels defined');
    });

    it('total message type count equals total outgoing MessageChannel edges', () => {
      const result = generateActorBoilerplate(store);
      // router: 3 out, worker-1: 1 out, worker-2: 0, logger: 0 = 4 total
      expect(result.messageTypeCount).toBe(4);
    });
  });

  describe('3G.3 Graph IS the specification — projection is deterministic', () => {
    it('same graph produces identical output on repeated calls', async () => {
      await store.addNode('a', 'Actor', { name: 'a', role: 'producer' });
      await store.addNode('b', 'Actor', { name: 'b', role: 'consumer' });
      await store.addEdge('c', 'a', 'b', 'MessageChannel', { messageType: 'Data' });

      const result1 = generateActorBoilerplate(store);
      const result2 = generateActorBoilerplate(store);

      expect(result1.combinedSource).toBe(result2.combinedSource);
    });

    it('adding a node changes the output', async () => {
      await store.addNode('a', 'Actor', { name: 'a', role: 'producer' });
      const before = generateActorBoilerplate(store);

      await store.addNode('b', 'Actor', { name: 'b', role: 'consumer' });
      const after = generateActorBoilerplate(store);

      expect(after.actorCount).toBe(before.actorCount + 1);
      expect(after.combinedSource).toContain('BActor');
    });

    it('non-Actor nodes are excluded from projection', async () => {
      await store.addNode('a', 'Actor', { name: 'a', role: 'producer' });
      await store.addNode('meta', 'Config', { name: 'meta', role: 'config' });
      const result = generateActorBoilerplate(store);
      expect(result.actorCount).toBe(1);
      expect(result.actors.map(x => x.className)).not.toContain('MetaConfig');
    });

    it('MessageChannel edges are projected; other edge types are ignored', async () => {
      await store.addNode('a', 'Actor', { name: 'a', role: 'producer' });
      await store.addNode('b', 'Actor', { name: 'b', role: 'consumer' });
      await store.addEdge('c1', 'a', 'b', 'MessageChannel', { messageType: 'Data' });
      await store.addEdge('c2', 'a', 'b', 'DependsOn', { blocking: true });
      const result = generateActorBoilerplate(store);
      const a = result.actors.find(ac => ac.className === 'AActor')!;
      expect(a.messageTypes).toHaveLength(1);
      expect(a.messageTypes).toContain('Data');
    });
  });

  describe('3.5 Runnable generation', () => {
    beforeEach(async () => {
      await store.addNode('runner', 'Actor', { name: 'runner', role: 'executor' });
      await store.addNode('scheduler', 'Actor', { name: 'scheduler', role: 'coordinator' });
      await store.addEdge('chan-run', 'runner', 'scheduler', 'MessageChannel', { messageType: 'RunTask' });
    });

    it('generated file executes cleanly with bun', async () => {
      // 1. Generate the actors file
      const result = generateActorBoilerplate(store);
      await writeFile('/tmp/ugfm-generated-actors.ts', result.combinedSource, 'utf-8');

      // 2. Create a small runner script that imports and instantiates the actors
      const stubRouter = `{
        tell: async () => {},
        ask: async () => ({ id: crypto.randomUUID(), correlationId: 'c', from: '@(stub)', to: undefined, success: true, timestamp: Date.now() }),
        registerActor: () => {},
        unregisterActor: () => {},
        getActor: () => undefined,
        listActors: () => [],
        cacheActor: () => {},
        invalidatePath: () => {},
      }`;

      const runnerScript = `
import { RunnerActor } from '/tmp/ugfm-generated-actors.ts';
const actor = new RunnerActor('runner', ${stubRouter});
const resp = await actor.handleMessage({
  id: 'msg-1',
  pattern: 'tell',
  type: 'RunTask',
  payload: {},
  correlationId: 'c-1',
  from: '@(test)',
  to: '@(runner)',
  timestamp: Date.now(),
});
if (!resp.success) throw new Error('Actor returned failure');
console.log('Actor executed successfully');
`;
      await writeFile('/tmp/ugfm-runner-test.ts', runnerScript, 'utf-8');

      // 3. Execute with bun
      const proc = Bun.spawn(['bun', '/tmp/ugfm-runner-test.ts'], {
        stdout: 'pipe',
        stderr: 'pipe',
      });
      const exitCode = await proc.exited;
      if (exitCode !== 0) {
        const stderr = await new Response(proc.stderr).text();
        const stdout = await new Response(proc.stdout).text();
        throw new Error(`bun exited with code ${exitCode}\nstdout: ${stdout}\nstderr: ${stderr}`);
      }
      expect(exitCode).toBe(0);
    });
  });
});
