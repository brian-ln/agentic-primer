#!/usr/bin/env bun
/**
 * KnowledgeExtractor - Batch processing pipeline for session knowledge extraction
 * Epic: agentic-primer-9ad
 * Phase: agentic-primer-9ad.3
 *
 * Two-stage pipeline:
 * 1. Stage 1: Fast candidate detection (parallel, heuristic-based)
 * 2. Stage 2: LLM classification of candidates only (rate-limited, parallel)
 *
 * Stores results in:
 * - session_decisions table
 * - session_learnings table
 * - session_errors table
 */

import { createClient, type Client } from '@libsql/client';
import { join } from 'path';
import { randomUUID } from 'crypto';
import { EmbeddingGenerator } from '../embeddings/EmbeddingGenerator';
import { SemanticMessageClassifier } from '../classification/SemanticMessageClassifier';

const INDEX_DIR = join(process.env.HOME!, '.claude/index');
const DB_PATH = join(INDEX_DIR, 'sessions-libsql.db');
const SESSION_DIR_PREFIX = join(process.env.HOME!, '.claude/projects');

export interface ExtractionResult {
  sessionId: string;
  messageCount: number;
  candidatesDetected: number;
  decisionsExtracted: number;
  learningsExtracted: number;
  errorsExtracted: number;
  processingTimeMs: number;
}

export interface MessageWithEmbedding {
  messageId: string;
  sessionId: string;
  content: string;
  embedding: Float32Array;
  timestamp: number;
}

export interface CandidateMessage {
  messageId: string;
  content: string;
  timestamp: number;
  categories: string[]; // ['decision', 'learning', 'error']
}

export interface Decision {
  id: string;
  sessionId: string;
  messageId: string;
  timestamp: number;
  decision: string;
  reasoning: string;
  alternatives: string;
  context: string;
  confidence: number;
}

export interface Learning {
  id: string;
  sessionId: string;
  messageId: string;
  timestamp: number;
  learning: string;
  category: string;
  evidence: string;
  application: string;
  confidence: number;
}

export interface SessionError {
  id: string;
  sessionId: string;
  messageId: string;
  timestamp: number;
  toolName: string | null;
  errorType: string | null;
  errorMessage: string;
  resolution: string;
  prevention: string;
  confidence: number;
}

/**
 * Stage 1: Fast candidate detection using heuristics
 * Filters messages to find potential decisions, learnings, and errors
 */
class MessageCandidateDetector {
  // Decision indicators
  private static DECISION_PATTERNS = [
    /\b(decided|chosen|selected|opted|going with|will use|chose)\b/i,
    /\b(instead of|rather than|over|vs\.?)\b/i,
    /\b(decision|choice|option|approach)\b/i,
  ];

  // Learning indicators
  private static LEARNING_PATTERNS = [
    /\b(learned|discovered|found|realized|insight|key finding)\b/i,
    /\b(turns out|it appears|we see that)\b/i,
    /\b(important to note|worth noting)\b/i,
  ];

  // Error indicators
  private static ERROR_PATTERNS = [
    /\b(error|failed|failure|exception|crash)\b/i,
    /\b(fix|resolution|workaround|solved)\b/i,
    /\btool_use_error\b/i,
  ];

  /**
   * Detect if a message is a candidate for any category
   */
  static detectCandidates(message: MessageWithEmbedding): CandidateMessage | null {
    const categories: string[] = [];
    const content = message.content.toLowerCase();

    // Check for decision indicators
    if (this.DECISION_PATTERNS.some(pattern => pattern.test(content))) {
      categories.push('decision');
    }

    // Check for learning indicators
    if (this.LEARNING_PATTERNS.some(pattern => pattern.test(content))) {
      categories.push('learning');
    }

    // Check for error indicators
    if (this.ERROR_PATTERNS.some(pattern => pattern.test(content))) {
      categories.push('error');
    }

    if (categories.length === 0) {
      return null;
    }

    return {
      messageId: message.messageId,
      content: message.content,
      timestamp: message.timestamp,
      categories,
    };
  }

  /**
   * Batch detect candidates from messages
   */
  static detectBatch(messages: MessageWithEmbedding[]): CandidateMessage[] {
    return messages
      .map(msg => this.detectCandidates(msg))
      .filter((candidate): candidate is CandidateMessage => candidate !== null);
  }
}

/**
 * Stage 2: LLM-based semantic classification
 * Only processes candidates from Stage 1
 */
class SemanticMessageClassifier {
  private llm: LocalLLMClient;

  constructor() {
    this.llm = new LocalLLMClient();
  }

  /**
   * Classify a decision message
   */
  async classifyDecision(message: CandidateMessage): Promise<Decision | null> {
    const systemPrompt = `You are analyzing a conversation message to extract decisions.

A decision is when the user or assistant chooses a specific approach, technology, or solution.

Extract:
- decision: The choice that was made (concise, 1 sentence)
- reasoning: Why this choice was made
- alternatives: What other options were considered
- context: Relevant background information
- confidence: 0.0-1.0 score of how certain this is a decision

Respond with valid JSON only.`;

    const userPrompt = `Analyze this message for decisions:\n\n${message.content}`;

    try {
      const result = await this.llm.chatJSON<{
        is_decision: boolean;
        decision: string;
        reasoning: string;
        alternatives: string;
        context: string;
        confidence: number;
      }>([
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ]);

      if (!result.is_decision || result.confidence < 0.5) {
        return null;
      }

      return {
        id: randomUUID(),
        sessionId: '',
        messageId: message.messageId,
        timestamp: message.timestamp,
        decision: result.decision,
        reasoning: result.reasoning,
        alternatives: result.alternatives,
        context: result.context,
        confidence: result.confidence,
      };
    } catch (error) {
      console.error(`Failed to classify decision: ${error}`);
      return null;
    }
  }

  /**
   * Classify a learning message
   */
  async classifyLearning(message: CandidateMessage): Promise<Learning | null> {
    const systemPrompt = `You are analyzing a conversation message to extract learnings.

A learning is an insight, discovery, or key finding about how something works.

Extract:
- learning: The insight or discovery (concise, 1-2 sentences)
- category: Type of learning (technical, architectural, tooling, performance, etc.)
- evidence: What showed us this learning
- application: How this can be applied in the future
- confidence: 0.0-1.0 score of how certain this is a learning

Respond with valid JSON only.`;

    const userPrompt = `Analyze this message for learnings:\n\n${message.content}`;

    try {
      const result = await this.llm.chatJSON<{
        is_learning: boolean;
        learning: string;
        category: string;
        evidence: string;
        application: string;
        confidence: number;
      }>([
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ]);

      if (!result.is_learning || result.confidence < 0.5) {
        return null;
      }

      return {
        id: randomUUID(),
        sessionId: '',
        messageId: message.messageId,
        timestamp: message.timestamp,
        learning: result.learning,
        category: result.category,
        evidence: result.evidence,
        application: result.application,
        confidence: result.confidence,
      };
    } catch (error) {
      console.error(`Failed to classify learning: ${error}`);
      return null;
    }
  }

  /**
   * Classify an error message
   */
  async classifyError(message: CandidateMessage): Promise<SessionError | null> {
    const systemPrompt = `You are analyzing a conversation message to extract errors and their resolutions.

An error is a problem, failure, or exception that occurred and was resolved.

Extract:
- tool_name: Tool that caused the error (if applicable)
- error_type: Type/category of error
- error_message: The error that occurred
- resolution: How it was fixed
- prevention: How to prevent it in the future
- confidence: 0.0-1.0 score of how certain this is an error

Respond with valid JSON only.`;

    const userPrompt = `Analyze this message for errors:\n\n${message.content}`;

    try {
      const result = await this.llm.chatJSON<{
        is_error: boolean;
        tool_name: string | null;
        error_type: string | null;
        error_message: string;
        resolution: string;
        prevention: string;
        confidence: number;
      }>([
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ]);

      if (!result.is_error || result.confidence < 0.5) {
        return null;
      }

      return {
        id: randomUUID(),
        sessionId: '',
        messageId: message.messageId,
        timestamp: message.timestamp,
        toolName: result.tool_name,
        errorType: result.error_type,
        errorMessage: result.error_message,
        resolution: result.resolution,
        prevention: result.prevention,
        confidence: result.confidence,
      };
    } catch (error) {
      console.error(`Failed to classify error: ${error}`);
      return null;
    }
  }
}

/**
 * Main extractor - orchestrates two-stage pipeline
 */
export class KnowledgeExtractor {
  private client: Client;
  private classifier: SemanticMessageClassifier;

  constructor(dbPath: string = DB_PATH) {
    this.client = createClient({ url: `file:${dbPath}` });
    this.classifier = new SemanticMessageClassifier();
  }

  /**
   * Extract knowledge from a single session
   */
  async extractSession(sessionId: string): Promise<ExtractionResult> {
    const startTime = Date.now();

    console.log(`\nüîç Extracting knowledge from session ${sessionId.slice(0, 8)}...`);

    // Load messages with embeddings
    const messages = await this.loadSessionMessages(sessionId);
    console.log(`  Found ${messages.length} messages with embeddings`);

    if (messages.length === 0) {
      return {
        sessionId,
        messageCount: 0,
        candidatesDetected: 0,
        decisionsExtracted: 0,
        learningsExtracted: 0,
        errorsExtracted: 0,
        processingTimeMs: Date.now() - startTime,
      };
    }

    // Stage 1: Fast candidate detection (parallel, heuristic-based)
    const candidates = MessageCandidateDetector.detectBatch(messages);
    console.log(`  Stage 1: Detected ${candidates.length} candidates (${((candidates.length / messages.length) * 100).toFixed(1)}% of messages)`);

    if (candidates.length === 0) {
      return {
        sessionId,
        messageCount: messages.length,
        candidatesDetected: 0,
        decisionsExtracted: 0,
        learningsExtracted: 0,
        errorsExtracted: 0,
        processingTimeMs: Date.now() - startTime,
      };
    }

    // Stage 2: LLM classification (rate-limited, parallel with batching)
    console.log(`  Stage 2: Classifying ${candidates.length} candidates...`);

    let decisionsExtracted = 0;
    let learningsExtracted = 0;
    let errorsExtracted = 0;

    // Process candidates in parallel with rate limiting (5 at a time)
    const batchSize = 5;
    for (let i = 0; i < candidates.length; i += batchSize) {
      const batch = candidates.slice(i, i + batchSize);

      // Classify in parallel within batch
      const results = await Promise.all(
        batch.map(async (candidate) => {
          const classifications = await Promise.all([
            candidate.categories.includes('decision')
              ? this.classifier.classifyDecision(candidate)
              : null,
            candidate.categories.includes('learning')
              ? this.classifier.classifyLearning(candidate)
              : null,
            candidate.categories.includes('error')
              ? this.classifier.classifyError(candidate)
              : null,
          ]);

          return {
            decision: classifications[0],
            learning: classifications[1],
            error: classifications[2],
          };
        })
      );

      // Store results
      for (const result of results) {
        if (result.decision) {
          result.decision.sessionId = sessionId;
          await this.storeDecision(result.decision);
          decisionsExtracted++;
        }
        if (result.learning) {
          result.learning.sessionId = sessionId;
          await this.storeLearning(result.learning);
          learningsExtracted++;
        }
        if (result.error) {
          result.error.sessionId = sessionId;
          await this.storeError(result.error);
          errorsExtracted++;
        }
      }

      console.log(`    Processed ${Math.min(i + batchSize, candidates.length)}/${candidates.length} candidates`);
    }

    const processingTimeMs = Date.now() - startTime;

    console.log(`  ‚úì Extracted: ${decisionsExtracted} decisions, ${learningsExtracted} learnings, ${errorsExtracted} errors (${processingTimeMs}ms)`);

    return {
      sessionId,
      messageCount: messages.length,
      candidatesDetected: candidates.length,
      decisionsExtracted,
      learningsExtracted,
      errorsExtracted,
      processingTimeMs,
    };
  }

  /**
   * Extract knowledge from all unprocessed sessions
   */
  async extractAll(): Promise<number> {
    const sessions = await this.client.execute(`
      SELECT DISTINCT s.id
      FROM sessions s
      INNER JOIN message_embeddings me ON s.id = me.session_id
      WHERE NOT EXISTS (
        SELECT 1 FROM session_decisions sd WHERE sd.session_id = s.id
      )
      AND NOT EXISTS (
        SELECT 1 FROM session_learnings sl WHERE sl.session_id = s.id
      )
      AND NOT EXISTS (
        SELECT 1 FROM session_errors se WHERE se.session_id = s.id
      )
      ORDER BY s.modified DESC
    `);

    const sessionIds = sessions.rows.map(row => row.id as string);
    console.log(`\nüìö Extracting knowledge from ${sessionIds.length} unprocessed sessions...\n`);

    let totalExtracted = 0;

    for (const sessionId of sessionIds) {
      const result = await this.extractSession(sessionId);
      totalExtracted += result.decisionsExtracted + result.learningsExtracted + result.errorsExtracted;
    }

    return totalExtracted;
  }

  /**
   * Extract knowledge from sessions in a date range
   */
  async extractRange(startDate: Date, endDate: Date): Promise<number> {
    const sessions = await this.client.execute({
      sql: `
        SELECT DISTINCT s.id
        FROM sessions s
        INNER JOIN message_embeddings me ON s.id = me.session_id
        WHERE s.created >= ? AND s.created <= ?
        ORDER BY s.modified DESC
      `,
      args: [startDate.getTime(), endDate.getTime()],
    });

    const sessionIds = sessions.rows.map(row => row.id as string);
    console.log(`\nüìö Extracting knowledge from ${sessionIds.length} sessions in date range...\n`);

    let totalExtracted = 0;

    for (const sessionId of sessionIds) {
      const result = await this.extractSession(sessionId);
      totalExtracted += result.decisionsExtracted + result.learningsExtracted + result.errorsExtracted;
    }

    return totalExtracted;
  }

  /**
   * Load messages with embeddings for a session
   */
  private async loadSessionMessages(sessionId: string): Promise<MessageWithEmbedding[]> {
    const result = await this.client.execute({
      sql: `
        SELECT message_id, session_id, content, embedding, timestamp
        FROM message_embeddings
        WHERE session_id = ?
        ORDER BY timestamp ASC
      `,
      args: [sessionId],
    });

    return result.rows.map((row: any) => ({
      messageId: row.message_id,
      sessionId: row.session_id,
      content: row.content,
      embedding: row.embedding as Float32Array,
      timestamp: row.timestamp,
    }));
  }

  /**
   * Store a decision in the database
   */
  private async storeDecision(decision: Decision): Promise<void> {
    await this.client.execute({
      sql: `
        INSERT INTO session_decisions
        (id, session_id, message_id, timestamp, decision, reasoning, alternatives, context, confidence)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(id) DO UPDATE SET
          decision = excluded.decision,
          reasoning = excluded.reasoning,
          alternatives = excluded.alternatives,
          context = excluded.context,
          confidence = excluded.confidence
      `,
      args: [
        decision.id,
        decision.sessionId,
        decision.messageId,
        decision.timestamp,
        decision.decision,
        decision.reasoning,
        decision.alternatives,
        decision.context,
        decision.confidence,
      ],
    });
  }

  /**
   * Store a learning in the database
   */
  private async storeLearning(learning: Learning): Promise<void> {
    await this.client.execute({
      sql: `
        INSERT INTO session_learnings
        (id, session_id, message_id, timestamp, learning, category, evidence, application, confidence)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(id) DO UPDATE SET
          learning = excluded.learning,
          category = excluded.category,
          evidence = excluded.evidence,
          application = excluded.application,
          confidence = excluded.confidence
      `,
      args: [
        learning.id,
        learning.sessionId,
        learning.messageId,
        learning.timestamp,
        learning.learning,
        learning.category,
        learning.evidence,
        learning.application,
        learning.confidence,
      ],
    });
  }

  /**
   * Store an error in the database
   */
  private async storeError(error: SessionError): Promise<void> {
    await this.client.execute({
      sql: `
        INSERT INTO session_errors
        (id, session_id, message_id, timestamp, tool_name, error_type, error_message, resolution, prevention, confidence)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(id) DO UPDATE SET
          tool_name = excluded.tool_name,
          error_type = excluded.error_type,
          error_message = excluded.error_message,
          resolution = excluded.resolution,
          prevention = excluded.prevention,
          confidence = excluded.confidence
      `,
      args: [
        error.id,
        error.sessionId,
        error.messageId,
        error.timestamp,
        error.toolName,
        error.errorType,
        error.errorMessage,
        error.resolution,
        error.prevention,
        error.confidence,
      ],
    });
  }

  async close(): Promise<void> {
    this.client.close();
  }
}

// CLI entry point
if (import.meta.main) {
  const extractor = new KnowledgeExtractor();

  try {
    const arg = process.argv[2];

    if (!arg) {
      console.error('Usage: extract-knowledge [session-id | today | yesterday | all]');
      process.exit(1);
    }

    if (arg === 'all') {
      const count = await extractor.extractAll();
      console.log(`\n‚úì Extracted ${count} total items across all sessions\n`);
    } else if (arg === 'today') {
      const start = new Date();
      start.setHours(0, 0, 0, 0);
      const end = new Date();
      end.setHours(23, 59, 59, 999);
      const count = await extractor.extractRange(start, end);
      console.log(`\n‚úì Extracted ${count} total items from today's sessions\n`);
    } else if (arg === 'yesterday') {
      const start = new Date();
      start.setDate(start.getDate() - 1);
      start.setHours(0, 0, 0, 0);
      const end = new Date();
      end.setDate(end.getDate() - 1);
      end.setHours(23, 59, 59, 999);
      const count = await extractor.extractRange(start, end);
      console.log(`\n‚úì Extracted ${count} total items from yesterday's sessions\n`);
    } else {
      // Treat as session ID
      const result = await extractor.extractSession(arg);
      console.log(`
üìä Extraction Summary

Session: ${result.sessionId}
Messages: ${result.messageCount}
Candidates: ${result.candidatesDetected}
Decisions: ${result.decisionsExtracted}
Learnings: ${result.learningsExtracted}
Errors: ${result.errorsExtracted}
Time: ${result.processingTimeMs}ms
      `.trim());
    }
  } catch (error) {
    console.error('Error:', error instanceof Error ? error.message : error);
    process.exit(1);
  } finally {
    await extractor.close();
  }
}
