// ugfm-claim3.ts
// UGFM Claim 3 demonstration: actor graph → TypeScript actor boilerplate generator
// This is a projection function: it reads graph structure and synthesizes code.
// The graph IS the specification; this function IS the projection.

import { GraphStore } from './graph';

export interface GeneratedActor {
  className: string;
  role: string;
  messageTypes: string[];
  source: string;  // TypeScript source code for this actor
}

export interface GenerationResult {
  actors: GeneratedActor[];
  combinedSource: string;  // All actors in one TypeScript module
  actorCount: number;
  messageTypeCount: number;
}

/**
 * Project an actor graph to TypeScript class stubs.
 *
 * Reads Actor nodes and MessageChannel edges from the GraphStore and
 * generates a TypeScript module with one class per actor. Each class
 * has a handleMessage(type, payload) method with switch-case arms
 * for each outgoing MessageChannel edge type.
 *
 * This is a pure function: same graph → identical output (deterministic).
 * No side effects beyond the returned GenerationResult.
 *
 * API notes (graph.ts):
 *   - store.getByType('Actor')  → Node[]  (sync)
 *   - store.adjacencyOut.get(nodeId)  → Array<{ to, edgeId, type, weight }>
 *   - store.edges.get(edgeId)  → Edge (has .properties Map<string, any>)
 *   - Node.properties  → Map<string, any>
 */
export function generateActorBoilerplate(store: GraphStore): GenerationResult {
  const actorNodes = store.getByType('Actor');

  const actors: GeneratedActor[] = [];

  for (const node of actorNodes) {
    const name = String(node.properties.get('name') ?? node.id);
    const role = String(node.properties.get('role') ?? 'unknown');
    const className = toPascalCase(name) + 'Actor';

    // Resolve outgoing edges via adjacencyOut (public Map on GraphStore)
    // adjacencyOut entries: { to, edgeId, type, weight }
    const outAdjacency = store.adjacencyOut.get(node.id) ?? [];
    const messageChannelEdges = outAdjacency.filter(adj => adj.type === 'MessageChannel');

    const messageTypes = messageChannelEdges.map(adj => {
      const edge = store.edges.get(adj.edgeId);
      return String(edge?.properties.get('messageType') ?? 'UnknownMessage');
    });

    const source = renderActorClass(className, role, messageTypes);
    actors.push({ className, role, messageTypes, source });
  }

  const combinedSource = renderModule(actors);

  return {
    actors,
    combinedSource,
    actorCount: actors.length,
    messageTypeCount: actors.reduce((n, a) => n + a.messageTypes.length, 0),
  };
}

function toPascalCase(str: string): string {
  return str
    .replace(/[-_\s]+(.)/g, (_, c: string) => c.toUpperCase())
    .replace(/^(.)/, (c: string) => c.toUpperCase());
}

function renderActorClass(className: string, role: string, messageTypes: string[]): string {
  const cases = messageTypes.length > 0
    ? messageTypes
        .map(mt => `      case '${mt}':\n        // TODO: handle ${mt}\n        break;`)
        .join('\n')
    : '      // No outgoing message channels defined';

  return `/** Generated actor: role=${role} */
export class ${className} {
  readonly role = '${role}';

  handleMessage(type: string, payload: unknown): void {
    switch (type) {
${cases}
      default:
        throw new Error(\`${className}: unknown message type: \${type}\`);
    }
  }
}`;
}

function renderModule(actors: GeneratedActor[]): string {
  const header = `// Generated by UGFM Claim 3 demonstration — actor graph → TypeScript boilerplate
// This file is auto-generated. Do not edit manually.
// Source: ugfm-claim3.ts generateActorBoilerplate()

`;
  return header + actors.map(a => a.source).join('\n\n') + '\n';
}
