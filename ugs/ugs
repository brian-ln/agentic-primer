#!/usr/bin/env bun
/**
 * UGS - Universal Graph System CLI
 * Agent-first design with human-friendly mode available
 */

import GraphStore, { Node, Edge, Address, $ } from './src/graph.ts';
import { ProgramManager } from './src/entities/program.ts';
import { ProviderManager } from './src/entities/provider.ts';
import { ModelManager } from './src/entities/model.ts';
import { InformationManager } from './src/entities/information.ts';
import { HumanManager, HumanState } from './src/entities/human.ts';
import { TaskManager, TaskState, TaskPriority, TaskEventEntry, ExportFilter } from './src/entities/task.ts';
import { SessionManager, SessionState } from './src/entities/session.ts';
import { AgentManager, AgentState } from './src/entities/agent.ts';
import { EmbeddingManager } from './src/entities/embedding.ts';
import { EpicManager, EpicLifecycle } from './src/entities/epic.ts';
import { ProjectManager, ProjectStatus } from './src/entities/project.ts';
import { createContextFromEnv, runWithContextAsync } from './src/context.ts';
import { join } from 'node:path';
import { existsSync } from 'node:fs';

interface OutputFormat {
  isAgent: boolean;
  structured: boolean;
  verbose: boolean;
}

interface HelpTopic {
  name: string;
  description: string;
  details?: string[];
  examples?: string[];
  seeAlso?: string[];
}

class UGSCLI {
  private store: GraphStore;
  private programManager: ProgramManager;
  private providerManager: ProviderManager;
  private modelManager: ModelManager;
  private informationManager: InformationManager;
  private humanManager: HumanManager;
  private taskManager: TaskManager;
  private sessionManager: SessionManager;
  private agentManager: AgentManager;
  private embeddingManager: EmbeddingManager;
  private epicManager: EpicManager;
  private projectManager: ProjectManager;
  private commands: Map<string, any> = new Map();
  private helpTopics: Map<string, HelpTopic> = new Map();
  private dataDir: string;
  private outputFormat: OutputFormat;

  constructor(dataDir?: string) {
    this.dataDir = dataDir || process.env.UGS_DATA_DIR || './data';
    this.store = new GraphStore(this.dataDir);
    this.programManager = new ProgramManager(this.store);
    this.providerManager = new ProviderManager(this.store);
    this.modelManager = new ModelManager(this.store, this.providerManager);
    this.informationManager = new InformationManager(this.store);
    this.humanManager = new HumanManager(this.store);
    this.taskManager = new TaskManager(this.store);
    this.sessionManager = new SessionManager(this.store, this.modelManager, this.dataDir);
    this.agentManager = new AgentManager(this.store, this.taskManager, this.modelManager);
    this.embeddingManager = new EmbeddingManager(this.store);
    this.epicManager = new EpicManager(this.store);
    this.projectManager = new ProjectManager(this.store);

    // Determine actor type and output format
    this.outputFormat = this.determineOutputFormat();

    this.setupCommands();
    this.setupHelpTopics();
  }

  private determineOutputFormat(): OutputFormat {
    const args = process.argv;
    
    // Explicit flags take precedence
    if (args.includes('--human')) {
      return { isAgent: false, structured: false, verbose: true };
    }
    if (args.includes('--agent')) {
      return { isAgent: true, structured: true, verbose: false };
    }
    
    // Environment variable
    const actor = process.env.UGS_ACTOR?.toLowerCase();
    if (actor === 'human') {
      return { isAgent: false, structured: false, verbose: true };
    }
    
    // Default to agent-optimized (actor === 'agent' or undefined)
    return { isAgent: true, structured: true, verbose: false };
  }

  private output(data: any, humanMessage?: string): void {
    if (this.outputFormat.isAgent) {
      // Agent-optimized: structured, parseable output
      if (typeof data === 'object') {
        console.log(JSON.stringify(data, null, 0)); // Compact JSON
      } else {
        console.log(data);
      }
    } else {
      // Human-friendly: verbose, descriptive output  
      if (humanMessage) {
        console.log(humanMessage);
      } else if (typeof data === 'object') {
        console.log(JSON.stringify(data, null, 2)); // Pretty JSON
      } else {
        console.log(data);
      }
    }
  }

  private log(message: string): void {
    if (!this.outputFormat.isAgent) {
      console.log(message);
    }
    // Agents get no logging noise unless it's structured data
  }

  private error(message: string, code: number = 1): void {
    if (this.outputFormat.isAgent) {
      console.error(JSON.stringify({ error: message, code }));
    } else {
      console.error(`‚ùå Error: ${message}`);
    }
    process.exit(code);
  }

  private success(message: string, data?: any): void {
    if (this.outputFormat.isAgent) {
      this.output({ success: true, message, data });
    } else {
      console.log(`‚úì ${message}`);
      if (data) this.output(data);
    }
  }

  private setupHelpTopics(): void {
    // Core Concepts
    this.helpTopics.set('concepts', {
      name: 'Core Concepts',
      description: 'What UGS is and how it works',
      details: [
        'UGS is a graph database: nodes (entities) connected by edges (relationships)',
        'Nodes have IDs, types, and properties (key-value pairs)',
        'Edges are directional with optional types and weights', 
        'Event sourcing: all changes logged, snapshots for performance',
        'Indexing: fast lookups by type, property, or full-text search',
        'Addressing: @(id) notation for referencing any element'
      ],
      examples: [
        './ugs add-node alice person name=Alice,team=engineering',
        './ugs add-edge reports_to alice bob manages',
        './ugs get alice     # Get node by ID',
        './ugs search Alice  # Full-text search'
      ],
      seeAlso: ['getting-started', 'workflow', 'addressing']
    });

    this.helpTopics.set('getting-started', {
      name: 'Getting Started Guide',
      description: 'Step-by-step introduction to UGS',
      details: [
        '1. Load demo data: ./ugs load-demo',
        '2. Explore graph: ./ugs stats',
        '3. Search nodes: ./ugs search <term>',
        '4. Find paths: ./ugs path <from> <to>',
        '5. Traverse graph: ./ugs traverse <start>',
        '6. Create snapshot: ./ugs snapshot',
        '7. For automation: set UGS_ACTOR=agent'
      ],
      examples: [
        './ugs load-demo                    # Load sample data',
        './ugs stats                        # See graph overview',
        './ugs search alice                 # Find Alice',
        './ugs path alice auth_proj         # Path from Alice to project',
        './ugs traverse alice 2             # Explore from Alice'
      ],
      seeAlso: ['concepts', 'workflow', 'examples']
    });

    this.helpTopics.set('workflow', {
      name: 'Common Workflows',
      description: 'How to use UGS effectively for different tasks',
      details: [
        'Knowledge Mapping: model domains with typed nodes and relationships',
        'Project Management: tasks, people, dependencies, and assignments',
        'Network Analysis: find paths, measure connectivity, detect communities',
        'Content Organization: hierarchical and cross-linked structures',
        'Process Modeling: workflows with states, transitions, and actors',
        'Research: citations, topics, authors, and collaboration networks'
      ],
      examples: [
        '# Knowledge base: ./ugs add-node concept1 topic describes=\"AI Ethics\"',
        '# Project mgmt: ./ugs add-edge task1 milestone1 belongs_to',
        '# Network: ./ugs path person1 person2  # Connection analysis',
        '# Content: ./ugs traverse document1 3 both  # Related content'
      ],
      seeAlso: ['examples', 'patterns', 'integration']
    });

    this.helpTopics.set('addressing', {
      name: 'Addressing System',
      description: 'Universal @(id) notation for referencing elements',
      details: [
        'Every node and edge has a unique ID for direct access',
        '@(id) syntax provides universal addressing across contexts',
        'Future: temporal addressing @(id:version) for versioned access',
        'IDs can be meaningful (alice, task_1) or generated (uuid)',
        'Case-sensitive and must be unique across entire graph'
      ],
      examples: [
        './ugs get @(alice)         # Direct node access',
        './ugs add-edge e1 @(task1) @(project1) belongs_to',
        '# Future: ./ugs get @(alice:2023-01-15)  # Temporal'
      ],
      seeAlso: ['concepts', 'temporal', 'integration']
    });

    this.helpTopics.set('patterns', {
      name: 'Design Patterns',
      description: 'Proven approaches for modeling with graphs',
      details: [
        'Hub-and-spoke: central nodes connected to many others',
        'Hierarchy: parent-child relationships with tree structure',
        'Many-to-many: complex relationship networks',
        'State machines: nodes as states, edges as transitions',
        'Dependency graphs: task/component ordering and prerequisites',
        'Tagging: flexible categorization with tag nodes'
      ],
      examples: [
        '# Hub: ./ugs add-edge user1 project1 member_of',
        '# Hierarchy: ./ugs add-edge child parent parent_child',
        '# State: ./ugs add-edge todo doing transition weight=1',
        '# Tags: ./ugs add-edge post1 tag_ai tagged_with'
      ],
      seeAlso: ['workflow', 'examples', 'best-practices']
    });

    this.helpTopics.set('integration', {
      name: 'Integration & Automation',
      description: 'Using UGS with scripts, agents, and other tools',
      details: [
        'Agent-first design: structured JSON output by default',
        'Batch operations: ./ugs command args for single operations',
        'Interactive mode: ./ugs session for exploration',
        'Scripting: parse JSON responses for automation',
        'Environment config: UGS_ACTOR, UGS_DATA_DIR variables',
        'Pipeline integration: stdin/stdout compatible'
      ],
      examples: [
        'UGS_ACTOR=agent ./ugs stats | jq .nodes      # Extract node count',
        'echo "search alice" | ./ugs session          # Pipe commands',
        'for user in users.txt; do ./ugs add-node $user person; done'
      ],
      seeAlso: ['actor-model', 'automation', 'scripting']
    });

    this.helpTopics.set('examples', {
      name: 'Real-world Examples',
      description: 'Complete examples for common use cases',
      details: [
        'Build a project management graph with teams, tasks, and dependencies',
        'Create a knowledge base with topics, documents, and citations',
        'Model an organization with people, roles, and reporting structure',
        'Track research with papers, authors, and collaboration networks',
        'Organize content with hierarchical categories and cross-references'
      ],
      examples: [
        './ugs load-demo                                    # See demo data',
        './ugs add-node paper1 research title=\"AI Safety\"   # Research node',
        './ugs add-edge paper1 author1 written_by           # Authorship',
        './ugs path author1 topic1                          # Research connections'
      ],
      seeAlso: ['getting-started', 'workflow', 'patterns']
    });

    this.helpTopics.set('actor-model', {
      name: 'Actor Model',
      description: 'Agent-first design with human mode override',
      details: [
        'Default: Agent-optimized (structured, parseable output)',
        'Human mode: Verbose, descriptive output with emojis',
        'Controlled by UGS_ACTOR environment variable or flags',
        'Agent output: Compact JSON, no logging noise',
        'Human output: Pretty formatting, helpful messages'
      ],
      examples: [
        'UGS_ACTOR=agent ./ugs stats     # Structured output',
        'UGS_ACTOR=human ./ugs stats     # Verbose output', 
        './ugs --agent stats             # Force agent mode',
        './ugs --human stats             # Force human mode'
      ],
      seeAlso: ['integration', 'automation', 'scripting']
    });

    this.helpTopics.set('best-practices', {
      name: 'Best Practices',
      description: 'Guidelines for effective graph modeling',
      details: [
        'Use meaningful IDs when possible (alice vs uuid-4829)',
        'Choose consistent node types (person, task, document)',
        'Leverage properties for rich metadata and searchability',
        'Model relationships explicitly rather than embedding in properties',
        'Use edge weights for ranking, priority, or distance',
        'Regular snapshots for performance on large graphs',
        'Consider bidirectional relationships (friend_of vs friends)'
      ],
      examples: [
        './ugs add-node alice person name=Alice,role=dev,team=backend',
        './ugs add-edge e1 alice task1 assigned_to priority=high',
        './ugs snapshot                    # Regular state saves'
      ],
      seeAlso: ['patterns', 'workflow', 'performance']
    });

    this.helpTopics.set('performance', {
      name: 'Performance & Scaling',
      description: 'Optimizing UGS for large graphs',
      details: [
        'Snapshots reduce startup time on large graphs (10k+ nodes)',
        'Indexing provides O(1) lookups by type and properties',
        'Full-text search automatically indexes node content',
        'Event log enables point-in-time recovery and audit trails',
        'Configurable data directory for storage optimization',
        'Batch operations faster than individual commands'
      ],
      examples: [
        './ugs snapshot                         # Force snapshot creation',
        'UGS_DATA_DIR=/fast-ssd/data ./ugs      # Custom storage location',
        './ugs events 100                       # Check recent activity'
      ],
      seeAlso: ['best-practices', 'persistence', 'automation']
    });
  }

  private setupCommands(): void {
    this.commands.set('add-node', {
      description: 'Add a new node: add-node <id> [type] [key=value,key=value...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.error('Missing required argument: id');
        }
        
        const [id, type, propsStr] = args;
        const properties = this.parseProperties(propsStr);
        const node = await this.store.addNode(id, type || null, properties);
        
        this.success(`Added node: ${node.id} (${node.type || 'untyped'})`, {
          operation: 'add-node',
          id: node.id,
          type: node.type,
          properties: Object.fromEntries(node.properties)
        });
      }
    });

    this.commands.set('add-edge', {
      description: 'Add a new edge: add-edge <id> <from> <to> [type] [weight]',
      handler: async (args: string[]) => {
        if (args.length < 3) {
          this.error('Missing required arguments: id, from, to');
        }
        
        const [id, from, to, type, weightStr] = args;
        const weight = weightStr ? parseFloat(weightStr) : 1;
        const edge = await this.store.addEdge(id, from, to, type || null, {}, weight);
        
        this.success(`Added edge: ${edge.from} -[${edge.type || 'untyped'}]-> ${edge.to}`, {
          operation: 'add-edge',
          id: edge.id,
          from: edge.from,
          to: edge.to,
          type: edge.type,
          weight: edge.weight
        });
      }
    });

    this.commands.set('get', {
      description: 'Get node or edge by ID: get <id>',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.error('Missing required argument: id');
        }
        
        const element = this.store.get(args[0]);
        if (element) {
          this.output(element.toJSON(), `Found ${element instanceof Node ? 'node' : 'edge'}: ${element.id}`);
        } else {
          if (this.outputFormat.isAgent) {
            this.output({ found: false, id: args[0] });
          } else {
            console.log(`‚ùå Not found: ${args[0]}`);
          }
        }
      }
    });

    this.commands.set('update-node', {
      description: 'Update node properties: update-node <id> [key=value,key=value...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.error('Missing required argument: id');
        }
        
        const [id, propsStr] = args;
        const node = this.store.get(id);
        
        if (!node || !(node instanceof Node)) {
          this.error(`Node not found: ${id}`);
        }
        
        if (!propsStr) {
          this.error('Missing properties to update');
        }
        
        // Parse new properties
        const updates = this.parseProperties(propsStr);
        
        // Update node properties
        for (const [key, value] of Object.entries(updates)) {
          node.properties.set(key, value);
        }
        
        // Update modified timestamp
        node.modified = Date.now();
        
        // Persist the update event
        await this.store.persistEvent({
          type: 'NodeUpdated',
          data: { 
            id: node.id, 
            updates,
            properties: Object.fromEntries(node.properties)
          },
          timestamp: Date.now()
        });
        
        // Update indices if they exist
        this.store.updateNodeIndices(node);
        
        this.success(`Updated node: ${node.id}`, {
          operation: 'update-node',
          id: node.id,
          updates,
          properties: Object.fromEntries(node.properties)
        });
      }
    });

    this.commands.set('set-property', {
      description: 'Set single property: set-property <id> <key> <value>',
      handler: async (args: string[]) => {
        if (args.length < 3) {
          this.error('Usage: set-property <id> <key> <value>');
        }
        
        const [id, key, value] = args;
        const node = this.store.get(id);
        
        if (!node || !(node instanceof Node)) {
          this.error(`Node not found: ${id}`);
        }
        
        // Parse value (try to detect type)
        let parsedValue: any = value;
        if (!isNaN(Number(value))) {
          parsedValue = Number(value);
        } else if (value.toLowerCase() === 'true') {
          parsedValue = true;
        } else if (value.toLowerCase() === 'false') {
          parsedValue = false;
        } else if (value.toLowerCase() === 'null') {
          parsedValue = null;
        }
        
        const oldValue = node.properties.get(key);
        node.properties.set(key, parsedValue);
        node.modified = Date.now();
        
        // Persist the update
        await this.store.persistEvent({
          type: 'NodeUpdated',
          data: { 
            id: node.id,
            property: key,
            oldValue,
            newValue: parsedValue
          },
          timestamp: Date.now()
        });
        
        // Update indices
        this.store.updateNodeIndices(node);
        
        this.success(`Set ${key}=${parsedValue} on ${id}`, {
          operation: 'set-property',
          id: node.id,
          property: key,
          value: parsedValue,
          oldValue
        });
      }
    });

    this.commands.set('remove-property', {
      description: 'Remove property: remove-property <id> <key>',
      handler: async (args: string[]) => {
        if (args.length < 2) {
          this.error('Usage: remove-property <id> <key>');
        }
        
        const [id, key] = args;
        const node = this.store.get(id);
        
        if (!node || !(node instanceof Node)) {
          this.error(`Node not found: ${id}`);
        }
        
        const oldValue = node.properties.get(key);
        if (!node.properties.has(key)) {
          this.error(`Property '${key}' not found on node ${id}`);
        }
        
        node.properties.delete(key);
        node.modified = Date.now();
        
        // Persist the update
        await this.store.persistEvent({
          type: 'NodeUpdated',
          data: { 
            id: node.id,
            removedProperty: key,
            oldValue
          },
          timestamp: Date.now()
        });
        
        // Update indices
        this.store.updateNodeIndices(node);
        
        this.success(`Removed property '${key}' from ${id}`, {
          operation: 'remove-property',
          id: node.id,
          property: key,
          oldValue
        });
      }
    });

    this.commands.set('find-by-property', {
      description: 'Find nodes by property: find-by-property <key> <value>',
      handler: async (args: string[]) => {
        if (args.length < 2) {
          this.error('Missing required arguments: key, value');
        }
        
        const [key, value] = args;
        const nodes = this.store.getByProperty(key, value);
        
        this.output(nodes.map(n => n.toJSON()), `Found ${nodes.length} nodes with ${key}=${value}`);
      }
    });

    this.commands.set('list-properties', {
      description: 'List all property keys in use: list-properties [type]',
      handler: async (args: string[]) => {
        const type = args[0];
        const nodes = type ? this.store.getByType(type) : Array.from(this.store.nodes.values());
        
        const propertyKeys = new Set<string>();
        for (const node of nodes) {
          for (const key of node.properties.keys()) {
            propertyKeys.add(key);
          }
        }
        
        const sortedKeys = Array.from(propertyKeys).sort();
        this.output(sortedKeys, `Found ${sortedKeys.length} property keys${type ? ` in type '${type}'` : ''}`);
      }
    });

    this.commands.set('search', {
      description: 'Full-text search: search <query>',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.error('Missing required argument: query');
        }
        
        const query = args.join(' ');
        const nodes = this.store.search(query);
        
        if (this.outputFormat.isAgent) {
          this.output({
            query,
            results: nodes.map(n => n.toJSON()),
            count: nodes.length
          });
        } else {
          console.log(`üîç Found ${nodes.length} nodes for "${query}":`);
          nodes.forEach(node => {
            const name = node.properties.get('name') || node.properties.get('title') || node.id;
            console.log(`  ‚Ä¢ ${node.id} (${node.type}): ${name}`);
          });
        }
      }
    });

    this.commands.set('list-type', {
      description: 'List all nodes of type: list-type <type>',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.error('Missing required argument: type');
        }
        
        const nodes = this.store.getByType(args[0]);
        
        if (this.outputFormat.isAgent) {
          this.output({
            type: args[0],
            nodes: nodes.map(n => n.toJSON()),
            count: nodes.length
          });
        } else {
          console.log(`üìã Found ${nodes.length} nodes of type '${args[0]}':`);
          nodes.forEach(node => {
            const name = node.properties.get('name') || node.properties.get('title') || node.id;
            console.log(`  ‚Ä¢ ${node.id}: ${name}`);
          });
        }
      }
    });

    this.commands.set('path', {
      description: 'Find shortest path: path <from> <to>',
      handler: async (args: string[]) => {
        if (args.length < 2) {
          this.error('Missing required arguments: from, to');
        }
        
        const [from, to] = args;
        const result = this.store.findShortestPath(from, to);
        
        if (result) {
          if (this.outputFormat.isAgent) {
            this.output({
              from,
              to,
              path: result.path,
              distance: result.distance,
              nodes: result.nodes.map(n => n.toJSON())
            });
          } else {
            console.log(`üó∫Ô∏è  Path from ${from} to ${to} (distance: ${result.distance}):`);
            console.log(`   ${result.path.join(' ‚Üí ')}`);
          }
        } else {
          if (this.outputFormat.isAgent) {
            this.output({ from, to, path: null, found: false });
          } else {
            console.log(`‚ùå No path found from ${from} to ${to}`);
          }
        }
      }
    });

    this.commands.set('traverse', {
      description: 'Traverse from node: traverse <start> [depth] [direction]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.error('Missing required argument: start');
        }
        
        const [start, depthStr, direction] = args;
        const depth = depthStr ? parseInt(depthStr) : 2;
        const results = this.store.traverse(start, { 
          maxDepth: depth, 
          direction: direction || 'both',
          maxResults: 20 
        });
        
        if (this.outputFormat.isAgent) {
          this.output({
            start,
            depth,
            direction: direction || 'both',
            results: results.map(r => ({
              node: r.node.toJSON(),
              depth: r.depth,
              path: r.path
            })),
            count: results.length
          });
        } else {
          console.log(`üåê Traversal from ${start} (depth ${depth}):`);
          results.forEach(({node, depth, path}) => {
            const name = node.properties.get('name') || node.properties.get('title') || node.id;
            console.log(`  Depth ${depth}: ${name} (${node.type}) via ${path.join(' ‚Üí ')}`);
          });
        }
      }
    });

    this.commands.set('stats', {
      description: 'Show graph statistics',
      handler: async () => {
        const stats = {
          dataDirectory: this.dataDir,
          actor: this.outputFormat.isAgent ? 'agent' : 'human',
          nodes: this.store.stats.nodeCount,
          edges: this.store.stats.edgeCount,
          events: this.store.stats.eventCount,
          indices: this.store.stats.indexCount,
          lastSnapshot: this.store.stats.lastSnapshot,
          files: {
            wal: existsSync(join(this.dataDir, 'events.wal')),
            snapshot: existsSync(join(this.dataDir, 'snapshot.json'))
          }
        };

        if (this.outputFormat.isAgent) {
          this.output(stats);
        } else {
          console.log('üìä UGS Graph Statistics:');
          console.log(`  Actor Mode: ${stats.actor}`);
          console.log(`  Data Directory: ${stats.dataDirectory}`);
          console.log(`  Nodes: ${stats.nodes}`);
          console.log(`  Edges: ${stats.edges}`);
          console.log(`  Events: ${stats.events}`);
          console.log(`  Indices: ${stats.indices}`);
          console.log(`  Last Snapshot: Event #${stats.lastSnapshot}`);
          
          // Show most connected in human mode
          const connected = this.store.getMostConnected(5);
          if (connected.length > 0) {
            console.log('\nüîó Most Connected:');
            connected.forEach(({id, total, in: inDeg, out}) => {
              const node = this.store.nodes.get(id);
              const name = node?.properties.get('name') || node?.properties.get('title') || id;
              console.log(`  ${name}: ${total} total (${inDeg} in, ${out} out)`);
            });
          }
        }
      }
    });

    this.commands.set('events', {
      description: 'Show recent events: events [limit]',
      handler: async (args: string[]) => {
        const limit = args[0] ? parseInt(args[0]) : 10;
        const events = this.store.getEventHistory(limit);
        
        if (this.outputFormat.isAgent) {
          this.output({
            limit,
            events,
            count: events.length
          });
        } else {
          console.log(`üìã Last ${events.length} events:`);
          events.forEach(event => {
            console.log(`  [${new Date(event.timestamp).toISOString()}] ${event.type}: ${event.data.id || 'N/A'}`);
          });
        }
      }
    });

    this.commands.set('help', {
      description: 'Show help: help [topic]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showGeneralHelp();
        } else {
          this.showTopicHelp(args[0]);
        }
      }
    });

    this.commands.set('load-demo', {
      description: 'Load demo data for testing',
      handler: async () => this.loadDemoData()
    });

    this.commands.set('roots', {
      description: 'Find root nodes (no incoming edges): roots [limit]',
      handler: async (args: string[]) => {
        const limit = args[0] ? parseInt(args[0]) : 20;
        const allNodes = Array.from(this.store.nodes.values());
        
        const roots = allNodes.filter(node => {
          const inDegree = this.store.getNodeDegree(node.id).in;
          return inDegree === 0;
        });
        
        const limitedRoots = roots.slice(0, limit);
        
        if (this.outputFormat.isAgent) {
          this.output({
            roots: limitedRoots.map(n => n.toJSON()),
            count: limitedRoots.length,
            totalRoots: roots.length,
            limit
          });
        } else {
          console.log(`üå≥ Found ${roots.length} root nodes (showing ${limitedRoots.length}):\n`);
          limitedRoots.forEach(node => {
            const name = node.properties.get('name') || node.properties.get('title') || node.id;
            const outDegree = this.store.getNodeDegree(node.id).out;
            console.log(`  ‚Ä¢ ${node.id} (${node.type || 'untyped'}): ${name} ‚Üí ${outDegree} connections`);
          });
        }
      }
    });

    this.commands.set('entry-points', {
      description: 'Find likely entry points to explore: entry-points [limit]',
      handler: async (args: string[]) => {
        const limit = args[0] ? parseInt(args[0]) : 10;
        
        // Get nodes with high connectivity or specific characteristics
        const allNodes = Array.from(this.store.nodes.values());
        const entryPoints: Array<{node: any, score: number, reason: string}> = [];
        
        allNodes.forEach(node => {
          const degree = this.store.getNodeDegree(node.id);
          let score = 0;
          const reasons: string[] = [];
          
          // Root nodes (no incoming edges) are natural entry points
          if (degree.in === 0) {
            score += 10;
            reasons.push('root');
          }
          
          // High-connectivity nodes are important hubs
          if (degree.total >= 3) {
            score += degree.total;
            reasons.push(`hub(${degree.total})`);
          }
          
          // Certain node types are natural entry points
          const entryTypes = ['person', 'project', 'plan', 'milestone', 'user', 'system'];
          if (entryTypes.includes(node.type || '')) {
            score += 5;
            reasons.push(`type:${node.type}`);
          }
          
          // Nodes with common "entry" properties
          if (node.properties.has('name') || node.properties.has('title')) {
            score += 2;
            reasons.push('named');
          }
          
          if (score > 0) {
            entryPoints.push({
              node: node.toJSON(),
              score,
              reason: reasons.join(', ')
            });
          }
        });
        
        // Sort by score and limit
        const topEntryPoints = entryPoints
          .sort((a, b) => b.score - a.score)
          .slice(0, limit);
        
        if (this.outputFormat.isAgent) {
          this.output({
            entryPoints: topEntryPoints,
            count: topEntryPoints.length,
            criteria: 'roots, hubs, types, named nodes'
          });
        } else {
          console.log(`üö™ Top ${topEntryPoints.length} entry points to explore:\n`);
          topEntryPoints.forEach(({node, score, reason}) => {
            const name = node.properties.name || node.properties.title || node.id;
            const degree = this.store.getNodeDegree(node.id);
            console.log(`  ‚Ä¢ ${node.id} (${node.type || 'untyped'}): ${name}`);
            console.log(`    Score: ${score} | Reason: ${reason} | Connections: ${degree.in}‚Üí${degree.out}`);
          });
          console.log(`\nüí° Try: traverse <node_id> 2 out`);
        }
      }
    });

    this.commands.set('types', {
      description: 'List all node types in the graph: types',
      handler: async (args: string[]) => {
        const typeMap = new Map<string, number>();
        
        for (const node of this.store.nodes.values()) {
          const type = node.type || 'untyped';
          typeMap.set(type, (typeMap.get(type) || 0) + 1);
        }
        
        const sortedTypes = Array.from(typeMap.entries())
          .sort((a, b) => b[1] - a[1]); // Sort by count descending
        
        if (this.outputFormat.isAgent) {
          this.output({
            types: sortedTypes.map(([type, count]) => ({ type, count })),
            totalTypes: sortedTypes.length
          });
        } else {
          console.log(`üìã Found ${sortedTypes.length} node types:\n`);
          sortedTypes.forEach(([type, count]) => {
            console.log(`  ‚Ä¢ ${type}: ${count} nodes`);
          });
          console.log(`\nüí° Try: list-type <type> | entry-points`);
        }
      }
    });

    this.commands.set('scopes', {
      description: 'List all scopes in use: scopes',
      handler: async (args: string[]) => {
        const scopeMap = new Map<string, number>();
        
        for (const node of this.store.nodes.values()) {
          const scope = node.id.includes(':') ? node.id.split(':', 1)[0] : 'default';
          scopeMap.set(scope, (scopeMap.get(scope) || 0) + 1);
        }
        
        const sortedScopes = Array.from(scopeMap.entries())
          .sort((a, b) => b[1] - a[1]);
        
        if (this.outputFormat.isAgent) {
          this.output({
            scopes: sortedScopes.map(([scope, count]) => ({ scope, count })),
            totalScopes: sortedScopes.length
          });
        } else {
          console.log(`üè∑Ô∏è  Found ${sortedScopes.length} scopes:\n`);
          sortedScopes.forEach(([scope, count]) => {
            console.log(`  ‚Ä¢ ${scope}: ${count} nodes`);
          });
          console.log(`\nüí° Try: list-scope <scope> | find-by-property`);
        }
      }
    });

    this.commands.set('list-scope', {
      description: 'List all nodes in a scope: list-scope <scope>',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.error('Missing required argument: scope');
        }
        
        const targetScope = args[0];
        const scopedNodes = Array.from(this.store.nodes.values()).filter(node => {
          const scope = node.id.includes(':') ? node.id.split(':', 1)[0] : 'default';
          return scope === targetScope;
        });
        
        if (this.outputFormat.isAgent) {
          this.output({
            scope: targetScope,
            nodes: scopedNodes.map(n => n.toJSON()),
            count: scopedNodes.length
          });
        } else {
          console.log(`üìÇ Found ${scopedNodes.length} nodes in '${targetScope}' scope:\n`);
          scopedNodes.forEach(node => {
            const name = node.properties.get('name') || node.properties.get('title') || node.id;
            console.log(`  ‚Ä¢ ${node.id} (${node.type || 'untyped'}): ${name}`);
          });
        }
      }
    });

    this.commands.set('user', {
      description: 'Enter user scope context or run user command: user [command] [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          await this.enterScopeContext('user');
        } else {
          // Run command in user scope context
          await this.runInScope('user', args);
        }
      }
    });

    this.commands.set('project', {
      description: 'Enter project scope context or run project command: project [command] [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          await this.enterScopeContext('project');
        } else {
          // Run command in project scope context
          await this.runInScope('project', args);
        }
      }
    });

    this.commands.set('scratch', {
      description: 'Enter scratch scope context or run scratch command: scratch [command] [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          await this.enterScopeContext('scratch');
        } else {
          // Run command in scratch scope context  
          await this.runInScope('scratch', args);
        }
      }
    });

    // Tag command for managing node tags
    this.commands.set('tag', {
      description: 'Manage node tags: tag <add|remove|list> <node-id> [tags...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showTagHelp();
          return;
        }

        const subcommand = args[0];
        const subArgs = args.slice(1);

        switch (subcommand) {
          case 'add':
            await this.handleTagAdd(subArgs);
            break;
          case 'remove':
            await this.handleTagRemove(subArgs);
            break;
          case 'list':
            await this.handleTagList(subArgs);
            break;
          default:
            this.error(`Unknown tag subcommand: ${subcommand}. Use 'tag' for help.`);
        }
      }
    });

    // Nodes command for listing and filtering nodes
    this.commands.set('nodes', {
      description: 'List nodes with optional filters: nodes [--tag <tag>] [--type <type>] [--limit <n>]',
      handler: async (args: string[]) => {
        const { named } = this.parseNamedArgs(args);
        const tag = named['tag'];
        const type = named['type'];
        const limit = named['limit'] ? parseInt(named['limit']) : 50;

        let nodes: Node[];

        if (tag) {
          nodes = this.store.getByTag(tag);
          if (type) {
            nodes = nodes.filter(n => n.type === type);
          }
        } else if (type) {
          nodes = this.store.getByType(type);
        } else {
          nodes = Array.from(this.store.nodes.values());
        }

        const limitedNodes = nodes.slice(0, limit);

        if (this.outputFormat.isAgent) {
          this.output({
            nodes: limitedNodes.map(n => n.toJSON()),
            count: limitedNodes.length,
            total: nodes.length,
            filters: { tag, type, limit }
          });
        } else {
          const filterDesc = [];
          if (tag) filterDesc.push(`tag: ${tag}`);
          if (type) filterDesc.push(`type: ${type}`);
          const filterStr = filterDesc.length > 0 ? ` (${filterDesc.join(', ')})` : '';

          console.log(`\nüìã Found ${nodes.length} nodes${filterStr} (showing ${limitedNodes.length}):\n`);
          limitedNodes.forEach(node => {
            const name = node.properties.get('name') || node.properties.get('title') || node.id;
            const nodeTags = node.properties.get('tags') || [];
            const tagStr = nodeTags.length > 0 ? ` [${nodeTags.join(', ')}]` : '';
            console.log(`  ‚Ä¢ ${node.id} (${node.type || 'untyped'}): ${name}${tagStr}`);
          });
        }
      }
    });

    this.commands.set('snapshot', {
      description: 'Create snapshot and save current state',
      handler: async () => {
        await this.store.createSnapshot();
        this.success('Snapshot created successfully!', {
          operation: 'snapshot',
          timestamp: Date.now(),
          eventCount: this.store.stats.eventCount
        });
      }
    });

    this.commands.set('program', {
      description: 'Manage programs: program <create|get|update|publish|invoke|deprecate|list> [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showProgramHelp();
          return;
        }

        const subcommand = args[0];
        const subArgs = args.slice(1);

        switch (subcommand) {
          case 'create':
            await this.handleProgramCreate(subArgs);
            break;
          case 'get':
            await this.handleProgramGet(subArgs);
            break;
          case 'update':
            await this.handleProgramUpdate(subArgs);
            break;
          case 'publish':
            await this.handleProgramPublish(subArgs);
            break;
          case 'invoke':
            await this.handleProgramInvoke(subArgs);
            break;
          case 'deprecate':
            await this.handleProgramDeprecate(subArgs);
            break;
          case 'list':
            await this.handleProgramList(subArgs);
            break;
          default:
            this.error(`Unknown program subcommand: ${subcommand}. Use 'program' for help.`);
        }
      }
    });

    // Provider command
    this.commands.set('provider', {
      description: 'Manage providers: provider <create|get|configure|publish|deprecate|list> [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showProviderHelp();
          return;
        }

        const subcommand = args[0];
        const subArgs = args.slice(1);

        switch (subcommand) {
          case 'create':
            await this.handleProviderCreate(subArgs);
            break;
          case 'get':
            await this.handleProviderGet(subArgs);
            break;
          case 'configure':
            await this.handleProviderConfigure(subArgs);
            break;
          case 'publish':
            await this.handleProviderPublish(subArgs);
            break;
          case 'deprecate':
            await this.handleProviderDeprecate(subArgs);
            break;
          case 'list':
            await this.handleProviderList(subArgs);
            break;
          default:
            this.error(`Unknown provider subcommand: ${subcommand}. Use 'provider' for help.`);
        }
      }
    });

    // Model command
    this.commands.set('model', {
      description: 'Manage models: model <create|get|configure|publish|invoke|deprecate|list> [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showModelHelp();
          return;
        }

        const subcommand = args[0];
        const subArgs = args.slice(1);

        switch (subcommand) {
          case 'create':
            await this.handleModelCreate(subArgs);
            break;
          case 'get':
            await this.handleModelGet(subArgs);
            break;
          case 'configure':
            await this.handleModelConfigure(subArgs);
            break;
          case 'publish':
            await this.handleModelPublish(subArgs);
            break;
          case 'invoke':
            await this.handleModelInvoke(subArgs);
            break;
          case 'deprecate':
            await this.handleModelDeprecate(subArgs);
            break;
          case 'list':
            await this.handleModelList(subArgs);
            break;
          default:
            this.error(`Unknown model subcommand: ${subcommand}. Use 'model' for help.`);
        }
      }
    });

    // Information command
    this.commands.set('info', {
      description: 'Manage information: info <create|get|update|validate|activate|archive|list|query> [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showInfoHelp();
          return;
        }

        const subcommand = args[0];
        const subArgs = args.slice(1);

        switch (subcommand) {
          case 'create':
            await this.handleInfoCreate(subArgs);
            break;
          case 'get':
            await this.handleInfoGet(subArgs);
            break;
          case 'update':
            await this.handleInfoUpdate(subArgs);
            break;
          case 'validate':
            await this.handleInfoValidate(subArgs);
            break;
          case 'activate':
            await this.handleInfoActivate(subArgs);
            break;
          case 'archive':
            await this.handleInfoArchive(subArgs);
            break;
          case 'list':
            await this.handleInfoList(subArgs);
            break;
          case 'query':
            await this.handleInfoQuery(subArgs);
            break;
          default:
            this.error(`Unknown info subcommand: ${subcommand}. Use 'info' for help.`);
        }
      }
    });

    // Human command
    this.commands.set('human', {
      description: 'Manage humans: human <create|get|update|status|notify|approve|reject|list> [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showHumanHelp();
          return;
        }

        const subcommand = args[0];
        const subArgs = args.slice(1);

        switch (subcommand) {
          case 'create':
            await this.handleHumanCreate(subArgs);
            break;
          case 'get':
            await this.handleHumanGet(subArgs);
            break;
          case 'update':
            await this.handleHumanUpdate(subArgs);
            break;
          case 'status':
            await this.handleHumanStatus(subArgs);
            break;
          case 'notify':
            await this.handleHumanNotify(subArgs);
            break;
          case 'approve':
            await this.handleHumanApprove(subArgs);
            break;
          case 'reject':
            await this.handleHumanReject(subArgs);
            break;
          case 'list':
            await this.handleHumanList(subArgs);
            break;
          default:
            this.error(`Unknown human subcommand: ${subcommand}. Use 'human' for help.`);
        }
      }
    });

    // Task command
    this.commands.set('task', {
      description: 'Manage tasks: task <create|get|assign|start|complete|fail|list|dep|ready|blocked|close|stats|patch|apply> [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showTaskHelp();
          return;
        }

        const subcommand = args[0];
        const subArgs = args.slice(1);

        switch (subcommand) {
          case 'create':
            await this.handleTaskCreate(subArgs);
            break;
          case 'get':
            await this.handleTaskGet(subArgs);
            break;
          case 'assign':
            await this.handleTaskAssign(subArgs);
            break;
          case 'start':
            await this.handleTaskStart(subArgs);
            break;
          case 'complete':
            await this.handleTaskComplete(subArgs);
            break;
          case 'fail':
            await this.handleTaskFail(subArgs);
            break;
          case 'list':
            await this.handleTaskList(subArgs);
            break;
          case 'dep':
            await this.handleTaskDep(subArgs);
            break;
          case 'ready':
            await this.handleTaskReady(subArgs);
            break;
          case 'blocked':
            await this.handleTaskBlocked(subArgs);
            break;
          case 'close':
            await this.handleTaskClose(subArgs);
            break;
          case 'stats':
            await this.handleTaskStats(subArgs);
            break;
          case 'patch':
            await this.handleTaskPatch(subArgs);
            break;
          case 'apply':
            await this.handleTaskApply(subArgs);
            break;
          case 'export':
            await this.handleTaskExport(subArgs);
            break;
          case 'note':
            await this.handleTaskNote(subArgs);
            break;
          case 'decide':
            await this.handleTaskDecide(subArgs);
            break;
          case 'link':
            await this.handleTaskLink(subArgs);
            break;
          case 'log':
            await this.handleTaskLog(subArgs);
            break;
          case 'decisions':
            await this.handleTaskDecisions(subArgs);
            break;
          case 'prime':
            await this.handleTaskPrime(subArgs);
            break;
          default:
            this.error(`Unknown task subcommand: ${subcommand}. Use 'task' for help.`);
        }
      }
    });

    // Agent command
    this.commands.set('agent', {
      description: 'Manage agents: agent <create|get|configure|assign|step|run|status|pause|resume|stop|reset|list> [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showAgentHelp();
          return;
        }

        const subcommand = args[0];
        const subArgs = args.slice(1);

        switch (subcommand) {
          case 'create':
            await this.handleAgentCreate(subArgs);
            break;
          case 'get':
            await this.handleAgentGet(subArgs);
            break;
          case 'configure':
            await this.handleAgentConfigure(subArgs);
            break;
          case 'assign':
            await this.handleAgentAssign(subArgs);
            break;
          case 'step':
            await this.handleAgentStep(subArgs);
            break;
          case 'run':
            await this.handleAgentRun(subArgs);
            break;
          case 'status':
            await this.handleAgentStatus(subArgs);
            break;
          case 'pause':
            await this.handleAgentPause(subArgs);
            break;
          case 'resume':
            await this.handleAgentResume(subArgs);
            break;
          case 'stop':
            await this.handleAgentStop(subArgs);
            break;
          case 'reset':
            await this.handleAgentReset(subArgs);
            break;
          case 'list':
            await this.handleAgentList(subArgs);
            break;
          default:
            this.error(`Unknown agent subcommand: ${subcommand}. Use 'agent' for help.`);
        }
      }
    });

    // Session command
    this.commands.set('session', {
      description: 'Manage sessions: session <create|get|send|history|pause|resume|complete|list> [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showSessionHelp();
          return;
        }

        const subcommand = args[0];
        const subArgs = args.slice(1);

        switch (subcommand) {
          case 'create':
            await this.handleSessionCreate(subArgs);
            break;
          case 'get':
            await this.handleSessionGet(subArgs);
            break;
          case 'send':
            await this.handleSessionSend(subArgs);
            break;
          case 'history':
            await this.handleSessionHistory(subArgs);
            break;
          case 'pause':
            await this.handleSessionPause(subArgs);
            break;
          case 'resume':
            await this.handleSessionResume(subArgs);
            break;
          case 'complete':
            await this.handleSessionComplete(subArgs);
            break;
          case 'list':
            await this.handleSessionList(subArgs);
            break;
          case 'prime':
            await this.handleSessionPrime(subArgs);
            break;
          default:
            this.error(`Unknown session subcommand: ${subcommand}. Use 'session' for help.`);
        }
      }
    });

    // Embedding command
    this.commands.set('embed', {
      description: 'Embed a node: embed <node-id> [--text "optional text"]',
      handler: async (args: string[]) => {
        await this.handleEmbed(args);
      }
    });

    // Similar command
    this.commands.set('similar', {
      description: 'Find similar nodes: similar <node-id> | similar --text "query" [--type ...] [--limit N]',
      handler: async (args: string[]) => {
        await this.handleSimilar(args);
      }
    });

    // Embedding stats command
    this.commands.set('embed-stats', {
      description: 'Show embedding statistics',
      handler: async () => {
        await this.handleEmbedStats();
      }
    });

    // Epic command
    this.commands.set('epic', {
      description: 'Manage epics: epic <create|get|list|activate|complete|cancel|task|tasks|stats|update> [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showEpicHelp();
          return;
        }

        const subcommand = args[0];
        const subArgs = args.slice(1);

        switch (subcommand) {
          case 'create':
            await this.handleEpicCreate(subArgs);
            break;
          case 'get':
            await this.handleEpicGet(subArgs);
            break;
          case 'list':
            await this.handleEpicList(subArgs);
            break;
          case 'activate':
            await this.handleEpicActivate(subArgs);
            break;
          case 'complete':
            await this.handleEpicComplete(subArgs);
            break;
          case 'cancel':
            await this.handleEpicCancel(subArgs);
            break;
          case 'update':
            await this.handleEpicUpdate(subArgs);
            break;
          case 'task':
            await this.handleEpicTask(subArgs);
            break;
          case 'tasks':
            await this.handleEpicTasks(subArgs);
            break;
          case 'stats':
            await this.handleEpicStats(subArgs);
            break;
          default:
            this.error(`Unknown epic subcommand: ${subcommand}. Use 'epic' for help.`);
        }
      }
    });

    // Project command (overrides the old scope-based project command)
    this.commands.set('project', {
      description: 'Manage projects: project <create|get|list|activate|complete|archive|epic|epics|stats|update> [args...]',
      handler: async (args: string[]) => {
        if (args.length === 0) {
          this.showProjectHelp();
          return;
        }

        const subcommand = args[0];
        const subArgs = args.slice(1);

        switch (subcommand) {
          case 'create':
            await this.handleProjectCreate(subArgs);
            break;
          case 'get':
            await this.handleProjectGet(subArgs);
            break;
          case 'list':
            await this.handleProjectList(subArgs);
            break;
          case 'activate':
            await this.handleProjectActivate(subArgs);
            break;
          case 'complete':
            await this.handleProjectComplete(subArgs);
            break;
          case 'archive':
            await this.handleProjectArchive(subArgs);
            break;
          case 'update':
            await this.handleProjectUpdate(subArgs);
            break;
          case 'epic':
            await this.handleProjectEpic(subArgs);
            break;
          case 'epics':
            await this.handleProjectEpics(subArgs);
            break;
          case 'stats':
            await this.handleProjectStats(subArgs);
            break;
          default:
            this.error(`Unknown project subcommand: ${subcommand}. Use 'project' for help.`);
        }
      }
    });
  }

  // === TAG MANAGEMENT HELPERS ===

  private showTagHelp(): void {
    if (this.outputFormat.isAgent) {
      this.output({
        command: 'tag',
        description: 'Manage node tags',
        subcommands: {
          add: 'Add tags to a node: tag add <node-id> <tag1> [tag2...]',
          remove: 'Remove tags from a node: tag remove <node-id> <tag1> [tag2...]',
          list: 'List tags for a node: tag list <node-id>'
        },
        notes: 'Tags are stored in node.properties.tags as an array. Use "nodes --tag <tag>" to filter nodes by tag.'
      });
    } else {
      console.log('\nüè∑Ô∏è  Tag Management Commands\n');
      console.log('Subcommands:');
      console.log('  add <node-id> <tag1> [tag2...]     Add tags to a node');
      console.log('  remove <node-id> <tag1> [tag2...]  Remove tags from a node');
      console.log('  list <node-id>                     List tags for a node');
      console.log('\nExamples:');
      console.log('  ./ugs tag add alice important vip');
      console.log('  ./ugs tag remove alice vip');
      console.log('  ./ugs tag list alice');
      console.log('  ./ugs nodes --tag important        # Find all nodes with tag');
    }
  }

  private async handleTagAdd(args: string[]): Promise<void> {
    if (args.length < 2) {
      this.error('Usage: tag add <node-id> <tag1> [tag2...]');
    }

    const [nodeId, ...tags] = args;
    const node = this.store.nodes.get(nodeId);

    if (!node) {
      this.error(`Node not found: ${nodeId}`);
    }

    const result = await this.store.addTags(nodeId, tags);

    if (result) {
      const currentTags = result.properties.get('tags') || [];
      this.success(`Added tags to ${nodeId}: ${tags.join(', ')}`, {
        operation: 'tag-add',
        id: nodeId,
        addedTags: tags,
        allTags: currentTags
      });
    } else {
      this.error(`Failed to add tags to ${nodeId}`);
    }
  }

  private async handleTagRemove(args: string[]): Promise<void> {
    if (args.length < 2) {
      this.error('Usage: tag remove <node-id> <tag1> [tag2...]');
    }

    const [nodeId, ...tags] = args;
    const node = this.store.nodes.get(nodeId);

    if (!node) {
      this.error(`Node not found: ${nodeId}`);
    }

    const result = await this.store.removeTags(nodeId, tags);

    if (result) {
      const currentTags = result.properties.get('tags') || [];
      this.success(`Removed tags from ${nodeId}: ${tags.join(', ')}`, {
        operation: 'tag-remove',
        id: nodeId,
        removedTags: tags,
        remainingTags: currentTags
      });
    } else {
      this.error(`Failed to remove tags from ${nodeId}`);
    }
  }

  private async handleTagList(args: string[]): Promise<void> {
    if (args.length < 1) {
      this.error('Usage: tag list <node-id>');
    }

    const [nodeId] = args;
    const node = this.store.nodes.get(nodeId);

    if (!node) {
      this.error(`Node not found: ${nodeId}`);
    }

    const tags = this.store.getNodeTags(nodeId);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'tag-list',
        id: nodeId,
        tags,
        count: tags.length
      });
    } else {
      if (tags.length === 0) {
        console.log(`Node ${nodeId} has no tags`);
      } else {
        console.log(`\nüè∑Ô∏è  Tags for ${nodeId}:\n`);
        tags.forEach(tag => console.log(`  ‚Ä¢ ${tag}`));
        console.log(`\nTotal: ${tags.length} tags`);
      }
    }
  }

  private showProgramHelp(): void {
    if (this.outputFormat.isAgent) {
      this.output({
        command: 'program',
        description: 'Manage executable programs with state machine lifecycle',
        subcommands: {
          create: 'Create a new program: program create <id> --impl \'<code>\' [--name "..."]',
          get: 'Get program details: program get <id>',
          update: 'Update a draft program: program update <id> [--impl \'<code>\'] [--name "..."]',
          publish: 'Publish a program: program publish <id>',
          invoke: 'Invoke a published program: program invoke <id> [--input \'<json>\']',
          deprecate: 'Deprecate a published program: program deprecate <id>',
          list: 'List programs: program list [--state draft|published|deprecated]'
        },
        lifecycle: 'draft -> published -> deprecated'
      });
    } else {
      console.log('üì¶ Program Management Commands\n');
      console.log('Lifecycle: draft ‚Üí published ‚Üí deprecated\n');
      console.log('Subcommands:');
      console.log('  create <id> --impl \'<code>\' [--name "..."]  Create a new program (starts in draft)');
      console.log('  get <id>                                    Get program details');
      console.log('  update <id> [--impl \'<code>\']               Update a draft program');
      console.log('  publish <id>                                Publish a draft program');
      console.log('  invoke <id> [--input \'<json>\']              Invoke a published program');
      console.log('  deprecate <id>                              Deprecate a published program');
      console.log('  list [--state draft|published|deprecated]   List programs');
      console.log('\nExamples:');
      console.log('  ./ugs program create my-prog --impl \'return input * 2;\' --name "Doubler"');
      console.log('  ./ugs program publish my-prog');
      console.log('  ./ugs program invoke my-prog --input \'5\'');
    }
  }

  private parseNamedArgs(args: string[]): { positional: string[]; named: Record<string, string> } {
    const positional: string[] = [];
    const named: Record<string, string> = {};

    let i = 0;
    while (i < args.length) {
      if (args[i].startsWith('--')) {
        const key = args[i].slice(2);
        if (i + 1 < args.length && !args[i + 1].startsWith('--')) {
          named[key] = args[i + 1];
          i += 2;
        } else {
          named[key] = 'true';
          i += 1;
        }
      } else {
        positional.push(args[i]);
        i += 1;
      }
    }

    return { positional, named };
  }

  private async handleProgramCreate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.impl) {
      this.error('Usage: program create <id> --impl \'<code>\' [--name "..."] [--description "..."]');
    }

    const id = positional[0];
    const impl = named.impl;
    const name = named.name;
    const description = named.description;

    try {
      const program = await this.programManager.createProgram(id, impl, { name, description });
      this.success(`Created program: ${program.id} (${program.state})`, {
        operation: 'program-create',
        id: program.id,
        name: program.name,
        state: program.state,
        version: program.version
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProgramGet(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: program get <id>');
    }

    const id = args[0];
    const program = this.programManager.getProgram(id);

    if (program) {
      this.output({
        id: program.id,
        name: program.name,
        impl: program.impl,
        state: program.state,
        version: program.version,
        description: program.description,
        inputSchema: program.inputSchema,
        outputSchema: program.outputSchema,
        created: program.created,
        modified: program.modified
      }, `Program: ${program.name} (${program.state})`);
    } else {
      if (this.outputFormat.isAgent) {
        this.output({ found: false, id });
      } else {
        console.log(`Program not found: ${id}`);
      }
    }
  }

  private async handleProgramUpdate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: program update <id> [--impl \'<code>\'] [--name "..."] [--description "..."]');
    }

    const id = positional[0];
    const updates: any = {};
    if (named.impl) updates.impl = named.impl;
    if (named.name) updates.name = named.name;
    if (named.description) updates.description = named.description;

    if (Object.keys(updates).length === 0) {
      this.error('No updates specified. Use --impl, --name, or --description');
    }

    try {
      const program = await this.programManager.updateProgram(id, updates);
      this.success(`Updated program: ${program.id} (v${program.version})`, {
        operation: 'program-update',
        id: program.id,
        version: program.version,
        updates: Object.keys(updates)
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProgramPublish(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: program publish <id>');
    }

    const id = args[0];

    try {
      const program = await this.programManager.publishProgram(id);
      this.success(`Published program: ${program.id}`, {
        operation: 'program-publish',
        id: program.id,
        state: program.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProgramInvoke(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: program invoke <id> [--input \'<json>\']');
    }

    const id = positional[0];
    let input: any;

    if (named.input) {
      try {
        input = JSON.parse(named.input);
      } catch {
        // Try parsing as a simple value
        if (!isNaN(Number(named.input))) {
          input = Number(named.input);
        } else if (named.input === 'true') {
          input = true;
        } else if (named.input === 'false') {
          input = false;
        } else if (named.input === 'null') {
          input = null;
        } else {
          input = named.input;
        }
      }
    }

    try {
      const result = await this.programManager.invokeProgram(id, input);

      if (this.outputFormat.isAgent) {
        this.output({
          operation: 'program-invoke',
          id,
          success: result.success,
          output: result.output,
          error: result.error,
          duration: result.duration
        });
      } else {
        if (result.success) {
          console.log(`Invocation successful (${result.duration}ms):`);
          console.log(JSON.stringify(result.output, null, 2));
        } else {
          console.log(`Invocation failed (${result.duration}ms): ${result.error}`);
        }
      }
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProgramDeprecate(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: program deprecate <id>');
    }

    const id = args[0];

    try {
      const program = await this.programManager.deprecateProgram(id);
      this.success(`Deprecated program: ${program.id}`, {
        operation: 'program-deprecate',
        id: program.id,
        state: program.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProgramList(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);
    const state = named.state as 'draft' | 'published' | 'deprecated' | undefined;

    if (state && !['draft', 'published', 'deprecated'].includes(state)) {
      this.error('Invalid state. Use: draft, published, or deprecated');
    }

    const programs = this.programManager.listPrograms(state);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'program-list',
        filter: state || 'all',
        programs: programs.map(p => ({
          id: p.id,
          name: p.name,
          state: p.state,
          version: p.version
        })),
        count: programs.length
      });
    } else {
      console.log(`Found ${programs.length} programs${state ? ` (${state})` : ''}:\n`);
      for (const program of programs) {
        console.log(`  ${program.id} (${program.state}, v${program.version}): ${program.name}`);
      }
    }
  }

  // === PROVIDER HANDLERS ===

  private showProviderHelp(): void {
    if (this.outputFormat.isAgent) {
      this.output({
        command: 'provider',
        description: 'Manage LLM providers (Cloudflare AI Gateway)',
        subcommands: {
          create: 'Create a provider: provider create <id> --type cloudflare-ai-gateway [--account-id ...] [--gateway-id ...]',
          get: 'Get provider details: provider get <id>',
          configure: 'Configure a draft provider: provider configure <id> [--account-id ...] [--gateway-id ...]',
          publish: 'Publish a provider: provider publish <id>',
          deprecate: 'Deprecate a published provider: provider deprecate <id>',
          list: 'List providers: provider list [--state draft|published|deprecated]'
        },
        lifecycle: 'draft -> published -> deprecated',
        envVars: ['CLOUDFLARE_ACCOUNT_ID', 'CLOUDFLARE_GATEWAY_ID', 'CLOUDFLARE_API_TOKEN']
      });
    } else {
      console.log('üåê Provider Management Commands\n');
      console.log('Lifecycle: draft -> published -> deprecated\n');
      console.log('Subcommands:');
      console.log('  create <id> --type cloudflare-ai-gateway  Create a provider');
      console.log('  get <id>                                  Get provider details');
      console.log('  configure <id> [--account-id ...]         Configure a draft provider');
      console.log('  publish <id>                              Publish a draft provider');
      console.log('  deprecate <id>                            Deprecate a published provider');
      console.log('  list [--state ...]                        List providers');
      console.log('\nEnvironment Variables:');
      console.log('  CLOUDFLARE_ACCOUNT_ID   - Cloudflare account ID');
      console.log('  CLOUDFLARE_GATEWAY_ID   - AI Gateway ID');
      console.log('  CLOUDFLARE_API_TOKEN    - API token for authentication');
      console.log('\nExamples:');
      console.log('  ./ugs provider create cf-gateway --type cloudflare-ai-gateway');
      console.log('  ./ugs provider publish cf-gateway');
      console.log('  ./ugs provider list');
    }
  }

  private async handleProviderCreate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: provider create <id> --type cloudflare-ai-gateway [--account-id ...] [--gateway-id ...]');
    }

    const id = positional[0];
    const providerType = named.type || 'cloudflare-ai-gateway';

    if (providerType !== 'cloudflare-ai-gateway') {
      this.error('Only cloudflare-ai-gateway provider type is supported');
    }

    try {
      const provider = await this.providerManager.createProvider(id, providerType as any, {
        accountId: named['account-id'],
        gatewayId: named['gateway-id']
      });
      this.success(`Created provider: ${provider.id} (${provider.state})`, {
        operation: 'provider-create',
        id: provider.id,
        providerType: provider.data.providerType,
        state: provider.state,
        version: provider.version
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProviderGet(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: provider get <id>');
    }

    const id = args[0];
    const provider = this.providerManager.getProvider(id);

    if (provider) {
      this.output({
        id: provider.id,
        type: provider.type,
        programType: provider.programType,
        state: provider.state,
        data: provider.data,
        version: provider.version,
        created: provider.created,
        modified: provider.modified
      }, `Provider: ${provider.id} (${provider.state})`);
    } else {
      if (this.outputFormat.isAgent) {
        this.output({ found: false, id });
      } else {
        console.log(`Provider not found: ${id}`);
      }
    }
  }

  private async handleProviderConfigure(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: provider configure <id> [--account-id ...] [--gateway-id ...]');
    }

    const id = positional[0];
    const updates: any = {};
    if (named['account-id']) updates.accountId = named['account-id'];
    if (named['gateway-id']) updates.gatewayId = named['gateway-id'];

    if (Object.keys(updates).length === 0) {
      this.error('No updates specified. Use --account-id or --gateway-id');
    }

    try {
      const provider = await this.providerManager.configureProvider(id, updates);
      this.success(`Configured provider: ${provider.id} (v${provider.version})`, {
        operation: 'provider-configure',
        id: provider.id,
        version: provider.version,
        updates: Object.keys(updates)
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProviderPublish(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: provider publish <id>');
    }

    const id = args[0];

    try {
      const provider = await this.providerManager.publishProvider(id);
      this.success(`Published provider: ${provider.id}`, {
        operation: 'provider-publish',
        id: provider.id,
        state: provider.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProviderDeprecate(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: provider deprecate <id>');
    }

    const id = args[0];

    try {
      const provider = await this.providerManager.deprecateProvider(id);
      this.success(`Deprecated provider: ${provider.id}`, {
        operation: 'provider-deprecate',
        id: provider.id,
        state: provider.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProviderList(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);
    const state = named.state as 'draft' | 'published' | 'deprecated' | undefined;

    if (state && !['draft', 'published', 'deprecated'].includes(state)) {
      this.error('Invalid state. Use: draft, published, or deprecated');
    }

    const providers = this.providerManager.listProviders(state);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'provider-list',
        filter: state || 'all',
        providers: providers.map(p => ({
          id: p.id,
          providerType: p.data.providerType,
          state: p.state,
          version: p.version
        })),
        count: providers.length
      });
    } else {
      console.log(`Found ${providers.length} providers${state ? ` (${state})` : ''}:\n`);
      for (const provider of providers) {
        console.log(`  ${provider.id} (${provider.state}, v${provider.version}): ${provider.data.providerType}`);
      }
    }
  }

  // === MODEL HANDLERS ===

  private showModelHelp(): void {
    if (this.outputFormat.isAgent) {
      this.output({
        command: 'model',
        description: 'Manage LLM models (inference configurations)',
        subcommands: {
          create: 'Create a model: model create <id> --backend <model-name> --provider <provider-id> [--name ...] [--temperature ...]',
          get: 'Get model details: model get <id>',
          configure: 'Configure a draft model: model configure <id> [--temperature ...] [--max-tokens ...] [--situation ...]',
          publish: 'Publish a model: model publish <id>',
          invoke: 'Invoke a published model: model invoke <id> --message "..." [--system "..."] [--situation ...] [--stream]',
          deprecate: 'Deprecate a published model: model deprecate <id>',
          list: 'List models: model list [--state draft|published|deprecated]'
        },
        lifecycle: 'draft -> published -> deprecated',
        backendModels: ['claude-sonnet-4-5', 'claude-opus-4', 'gpt-4o', 'gpt-4o-mini', 'gemini-pro']
      });
    } else {
      console.log('ü§ñ Model Management Commands\n');
      console.log('Lifecycle: draft -> published -> deprecated\n');
      console.log('Subcommands:');
      console.log('  create <id> --backend <model> --provider <provider-id>  Create a model');
      console.log('  get <id>                                                Get model details');
      console.log('  configure <id> [--temperature ...] [--situation ...]    Configure a draft model');
      console.log('  publish <id>                                            Publish a draft model');
      console.log('  invoke <id> --message "..." [--stream]                  Invoke for inference');
      console.log('  deprecate <id>                                          Deprecate a published model');
      console.log('  list [--state ...]                                      List models');
      console.log('\nBackend Models:');
      console.log('  Anthropic: claude-sonnet-4-5, claude-opus-4, claude-haiku-3-5');
      console.log('  OpenAI: gpt-4o, gpt-4o-mini, gpt-4-turbo');
      console.log('  Google: gemini-pro, gemini-flash');
      console.log('\nExamples:');
      console.log('  ./ugs model create claude-fast --backend claude-sonnet-4-5 --provider cf-gateway');
      console.log('  ./ugs model configure claude-fast --temperature 0 --situation coding');
      console.log('  ./ugs model publish claude-fast');
      console.log('  ./ugs model invoke claude-fast --message "Hello!"');
      console.log('  ./ugs model invoke claude-fast --message "Hello!" --stream');
    }
  }

  private async handleModelCreate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.backend || !named.provider) {
      this.error('Usage: model create <id> --backend <model-name> --provider <provider-id> [--name ...] [--temperature ...] [--max-tokens ...]');
    }

    const id = positional[0];

    try {
      const model = await this.modelManager.createModel(id, named.backend, named.provider, {
        name: named.name,
        temperature: named.temperature ? parseFloat(named.temperature) : undefined,
        maxTokens: named['max-tokens'] ? parseInt(named['max-tokens']) : undefined,
        topP: named['top-p'] ? parseFloat(named['top-p']) : undefined
      });
      this.success(`Created model: ${model.id} (${model.state})`, {
        operation: 'model-create',
        id: model.id,
        name: model.data.name,
        backendModel: model.data.backendModel,
        provider: model.data.provider,
        state: model.state,
        version: model.version
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleModelGet(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: model get <id>');
    }

    const id = args[0];
    const model = this.modelManager.getModel(id);

    if (model) {
      this.output({
        id: model.id,
        type: model.type,
        programType: model.programType,
        state: model.state,
        data: model.data,
        version: model.version,
        created: model.created,
        modified: model.modified
      }, `Model: ${model.data.name} (${model.state})`);
    } else {
      if (this.outputFormat.isAgent) {
        this.output({ found: false, id });
      } else {
        console.log(`Model not found: ${id}`);
      }
    }
  }

  private async handleModelConfigure(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: model configure <id> [--name ...] [--temperature ...] [--max-tokens ...] [--situation <name>]');
    }

    const id = positional[0];
    const updates: any = {};

    if (named.name) updates.name = named.name;
    if (named.temperature) updates.temperature = parseFloat(named.temperature);
    if (named['max-tokens']) updates.maxTokens = parseInt(named['max-tokens']);
    if (named['top-p']) updates.topP = parseFloat(named['top-p']);

    // Handle situation configuration
    if (named.situation) {
      const situationParams: any = {};
      if (named.temperature) situationParams.temperature = parseFloat(named.temperature);
      if (named['max-tokens']) situationParams.maxTokens = parseInt(named['max-tokens']);
      updates.situation = { name: named.situation, params: situationParams };
      // Remove individual params if they were added for situation
      delete updates.temperature;
      delete updates.maxTokens;
    }

    if (Object.keys(updates).length === 0) {
      this.error('No updates specified. Use --name, --temperature, --max-tokens, or --situation');
    }

    try {
      const model = await this.modelManager.configureModel(id, updates);
      this.success(`Configured model: ${model.id} (v${model.version})`, {
        operation: 'model-configure',
        id: model.id,
        version: model.version,
        updates: Object.keys(updates)
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleModelPublish(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: model publish <id>');
    }

    const id = args[0];

    try {
      const model = await this.modelManager.publishModel(id);
      this.success(`Published model: ${model.id}`, {
        operation: 'model-publish',
        id: model.id,
        state: model.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleModelInvoke(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.message) {
      this.error('Usage: model invoke <id> --message "..." [--system "..."] [--situation ...] [--stream]');
    }

    const id = positional[0];
    const useStream = named.stream === 'true' || named.stream === true || args.includes('--stream');

    try {
      const result = await this.modelManager.invokeModel(id, {
        message: named.message,
        system: named.system,
        situation: named.situation,
        stream: useStream,
        onToken: useStream && !this.outputFormat.isAgent ? (token: string) => {
          // Print token directly to stdout for human-friendly streaming
          process.stdout.write(token);
        } : undefined
      });

      if (this.outputFormat.isAgent) {
        this.output({
          operation: 'model-invoke',
          id,
          success: result.success,
          text: result.text,
          usage: result.usage,
          error: result.error,
          duration: result.duration,
          model: result.model,
          situation: result.situation,
          streamed: useStream
        });
      } else {
        if (result.success) {
          if (useStream) {
            // Streaming output was already printed, just add newline and stats
            console.log(`\n\nInference completed (${result.duration}ms, streamed)`);
          } else {
            console.log(`Inference successful (${result.duration}ms):`);
            console.log(result.text);
          }
          if (result.usage) {
            console.log(`Tokens: ${result.usage.promptTokens} prompt + ${result.usage.completionTokens} completion = ${result.usage.totalTokens} total`);
          }
        } else {
          console.log(`Inference failed (${result.duration}ms): ${result.error}`);
        }
      }
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleModelDeprecate(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: model deprecate <id>');
    }

    const id = args[0];

    try {
      const model = await this.modelManager.deprecateModel(id);
      this.success(`Deprecated model: ${model.id}`, {
        operation: 'model-deprecate',
        id: model.id,
        state: model.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleModelList(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);
    const state = named.state as 'draft' | 'published' | 'deprecated' | undefined;

    if (state && !['draft', 'published', 'deprecated'].includes(state)) {
      this.error('Invalid state. Use: draft, published, or deprecated');
    }

    const models = this.modelManager.listModels(state);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'model-list',
        filter: state || 'all',
        models: models.map(m => ({
          id: m.id,
          name: m.data.name,
          backendModel: m.data.backendModel,
          provider: m.data.provider,
          state: m.state,
          version: m.version
        })),
        count: models.length
      });
    } else {
      console.log(`Found ${models.length} models${state ? ` (${state})` : ''}:\n`);
      for (const model of models) {
        console.log(`  ${model.id} (${model.state}, v${model.version}): ${model.data.name} -> ${model.data.backendModel}`);
      }
    }
  }

  // === INFORMATION HANDLERS ===

  private showInfoHelp(): void {
    if (this.outputFormat.isAgent) {
      this.output({
        command: 'info',
        description: 'Manage structured information (facts, schemas, workflows, patterns)',
        subcommands: {
          create: 'Create information: info create <id> --type fact|schema|workflow|pattern --content \'<json>\' [--tags "tag1,tag2"]',
          get: 'Get information details: info get <id>',
          update: 'Update draft information: info update <id> --content \'<json>\' [--tags "..."]',
          validate: 'Validate information: info validate <id>',
          activate: 'Activate information: info activate <id>',
          archive: 'Archive information: info archive <id>',
          list: 'List information: info list [--type fact|schema|workflow|pattern] [--state draft|validated|active|archived]',
          query: 'Query information: info query --tag <tag>'
        },
        lifecycle: 'draft -> validated -> active -> archived (archived -> active reactivation allowed)',
        infoTypes: ['fact', 'schema', 'workflow', 'pattern']
      });
    } else {
      console.log('üìù Information Management Commands\n');
      console.log('Lifecycle: draft -> validated -> active -> archived\n');
      console.log('  (archived can be reactivated back to active)\n');
      console.log('Subcommands:');
      console.log('  create <id> --type <type> --content \'<json>\'   Create information (starts in draft)');
      console.log('  get <id>                                       Get information details');
      console.log('  update <id> --content \'<json>\'                 Update draft information');
      console.log('  validate <id>                                  Validate information');
      console.log('  activate <id>                                  Activate validated/archived info');
      console.log('  archive <id>                                   Archive active information');
      console.log('  list [--type ...] [--state ...]                List information');
      console.log('  query --tag <tag>                              Query by tag');
      console.log('\nInfo Types: fact, schema, workflow, pattern');
      console.log('\nExamples:');
      console.log('  ./ugs info create fact1 --type fact --content \'{"subject": "test"}\'');
      console.log('  ./ugs info create schema1 --type schema --content \'{"fields": ["name"]}\' --tags "api,v1"');
      console.log('  ./ugs info validate fact1');
      console.log('  ./ugs info activate fact1');
      console.log('  ./ugs info list --type fact --state active');
      console.log('  ./ugs info query --tag api');
    }
  }

  private async handleInfoCreate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.type || !named.content) {
      this.error('Usage: info create <id> --type fact|schema|workflow|pattern --content \'<json>\' [--tags "tag1,tag2"] [--description "..."]');
    }

    const id = positional[0];
    const infoType = named.type;

    if (!['fact', 'schema', 'workflow', 'pattern'].includes(infoType)) {
      this.error('Invalid info type. Use: fact, schema, workflow, or pattern');
    }

    let content: any;
    try {
      content = JSON.parse(named.content);
    } catch {
      // Allow non-JSON content as a string
      content = named.content;
    }

    const tags = named.tags ? named.tags.split(',').map((t: string) => t.trim()) : undefined;

    try {
      const info = await this.informationManager.createInformation(id, infoType as any, content, {
        tags,
        description: named.description,
        schema: named.schema,
        sources: named.sources ? named.sources.split(',').map((s: string) => s.trim()) : undefined
      });
      this.success(`Created information: ${info.id} (${info.lifecycle})`, {
        operation: 'info-create',
        id: info.id,
        infoType: info.config.infoType,
        lifecycle: info.lifecycle,
        version: info.version,
        tags: info.config.tags
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleInfoGet(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: info get <id>');
    }

    const id = args[0];
    const info = this.informationManager.getInformation(id);

    if (info) {
      this.output({
        id: info.id,
        type: info.type,
        programType: info.programType,
        lifecycle: info.lifecycle,
        config: info.config,
        version: info.version,
        created: info.created,
        modified: info.modified
      }, `Information: ${info.id} (${info.config.infoType}, ${info.lifecycle})`);
    } else {
      if (this.outputFormat.isAgent) {
        this.output({ found: false, id });
      } else {
        console.log(`Information not found: ${id}`);
      }
    }
  }

  private async handleInfoUpdate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: info update <id> --content \'<json>\' [--tags "..."] [--description "..."]');
    }

    const id = positional[0];
    const updates: any = {};

    if (named.content) {
      try {
        updates.content = JSON.parse(named.content);
      } catch {
        updates.content = named.content;
      }
    }
    if (named.tags) {
      updates.tags = named.tags.split(',').map((t: string) => t.trim());
    }
    if (named.description) {
      updates.description = named.description;
    }
    if (named.schema) {
      updates.schema = named.schema;
    }
    if (named.sources) {
      updates.sources = named.sources.split(',').map((s: string) => s.trim());
    }

    if (Object.keys(updates).length === 0) {
      this.error('No updates specified. Use --content, --tags, --description, --schema, or --sources');
    }

    try {
      const info = await this.informationManager.updateInformation(id, updates);
      this.success(`Updated information: ${info.id} (v${info.version})`, {
        operation: 'info-update',
        id: info.id,
        version: info.version,
        updates: Object.keys(updates)
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleInfoValidate(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: info validate <id>');
    }

    const id = args[0];

    try {
      const info = await this.informationManager.validateInformation(id);
      this.success(`Validated information: ${info.id}`, {
        operation: 'info-validate',
        id: info.id,
        lifecycle: info.lifecycle
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleInfoActivate(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: info activate <id>');
    }

    const id = args[0];

    try {
      const info = await this.informationManager.activateInformation(id);
      this.success(`Activated information: ${info.id}`, {
        operation: 'info-activate',
        id: info.id,
        lifecycle: info.lifecycle
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleInfoArchive(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: info archive <id>');
    }

    const id = args[0];

    try {
      const info = await this.informationManager.archiveInformation(id);
      this.success(`Archived information: ${info.id}`, {
        operation: 'info-archive',
        id: info.id,
        lifecycle: info.lifecycle
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleInfoList(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);
    const state = named.state as 'draft' | 'validated' | 'active' | 'archived' | undefined;
    const infoType = named.type as 'fact' | 'schema' | 'workflow' | 'pattern' | undefined;

    if (state && !['draft', 'validated', 'active', 'archived'].includes(state)) {
      this.error('Invalid state. Use: draft, validated, active, or archived');
    }

    if (infoType && !['fact', 'schema', 'workflow', 'pattern'].includes(infoType)) {
      this.error('Invalid type. Use: fact, schema, workflow, or pattern');
    }

    let infos = this.informationManager.listInformation(state);

    // Filter by type if specified
    if (infoType) {
      infos = infos.filter(i => i.config.infoType === infoType);
    }

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'info-list',
        filterState: state || 'all',
        filterType: infoType || 'all',
        information: infos.map(i => ({
          id: i.id,
          infoType: i.config.infoType,
          lifecycle: i.lifecycle,
          version: i.version,
          tags: i.config.tags,
          description: i.config.description
        })),
        count: infos.length
      });
    } else {
      const filters = [];
      if (state) filters.push(`state: ${state}`);
      if (infoType) filters.push(`type: ${infoType}`);
      const filterStr = filters.length > 0 ? ` (${filters.join(', ')})` : '';

      console.log(`Found ${infos.length} information entries${filterStr}:\n`);
      for (const info of infos) {
        const tagsStr = info.config.tags ? ` [${info.config.tags.join(', ')}]` : '';
        console.log(`  ${info.id} (${info.config.infoType}, ${info.lifecycle}, v${info.version})${tagsStr}`);
        if (info.config.description) {
          console.log(`    ${info.config.description}`);
        }
      }
    }
  }

  private async handleInfoQuery(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);

    if (!named.tag) {
      this.error('Usage: info query --tag <tag>');
    }

    const infos = this.informationManager.queryByTag(named.tag);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'info-query',
        queryTag: named.tag,
        results: infos.map(i => ({
          id: i.id,
          infoType: i.config.infoType,
          lifecycle: i.lifecycle,
          version: i.version,
          tags: i.config.tags,
          description: i.config.description
        })),
        count: infos.length
      });
    } else {
      console.log(`Found ${infos.length} information entries with tag "${named.tag}":\n`);
      for (const info of infos) {
        const tagsStr = info.config.tags ? ` [${info.config.tags.join(', ')}]` : '';
        console.log(`  ${info.id} (${info.config.infoType}, ${info.lifecycle})${tagsStr}`);
        if (info.config.description) {
          console.log(`    ${info.config.description}`);
        }
      }
    }
  }

  // === HUMAN HANDLERS ===

  private showHumanHelp(): void {
    if (this.outputFormat.isAgent) {
      this.output({
        command: 'human',
        description: 'Manage human actors in the system',
        subcommands: {
          create: 'Create a human: human create <id> --name "..." [--email "..."] [--permissions "approve,assign"]',
          get: 'Get human details: human get <id>',
          update: 'Update a human: human update <id> [--name "..."] [--email "..."] [--permissions "..."]',
          status: 'Set human status: human status <id> --set available|busy|away|offline',
          notify: 'Send notification: human notify <id> --message "..."',
          approve: 'Approve a request: human approve <id> <approval-id>',
          reject: 'Reject a request: human reject <id> <approval-id> [--reason "..."]',
          list: 'List humans: human list [--state available|busy|away|offline]'
        },
        stateMachine: 'available <-> busy, available <-> away, any -> offline, offline -> available',
        permissions: ['approve', 'assign', 'configure', 'admin']
      });
    } else {
      console.log('üë§ Human Management Commands\n');
      console.log('State Machine: available <-> busy, available <-> away, any -> offline, offline -> available\n');
      console.log('Subcommands:');
      console.log('  create <id> --name "..."                     Create a human (starts in available)');
      console.log('  get <id>                                     Get human details');
      console.log('  update <id> [--name ...] [--permissions ...] Update a human');
      console.log('  status <id> --set available|busy|away|offline Set human status');
      console.log('  notify <id> --message "..."                  Send notification');
      console.log('  approve <id> <approval-id>                   Approve a pending request');
      console.log('  reject <id> <approval-id> [--reason "..."]   Reject a pending request');
      console.log('  list [--state ...]                           List humans');
      console.log('\nPermissions: approve, assign, configure, admin');
      console.log('\nExamples:');
      console.log('  ./ugs human create bln --name "Brian"');
      console.log('  ./ugs human status bln --set busy');
      console.log('  ./ugs human notify bln --message "Task complete"');
      console.log('  ./ugs human update bln --permissions "approve,assign"');
    }
  }

  private async handleHumanCreate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.name) {
      this.error('Usage: human create <id> --name "..." [--email "..."] [--permissions "approve,assign"]');
    }

    const id = positional[0];
    const permissions = named.permissions?.split(',').map((p: string) => p.trim()) as any;

    try {
      const human = await this.humanManager.createHuman(id, named.name, {
        email: named.email,
        permissions
      });
      this.success(`Created human: ${human.id} (${human.state})`, {
        operation: 'human-create',
        id: human.id,
        name: human.data.name,
        state: human.state,
        version: human.version
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleHumanGet(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: human get <id>');
    }

    const id = args[0];
    const human = this.humanManager.getHuman(id);

    if (human) {
      const pendingApprovals = this.humanManager.getPendingApprovals(id);
      this.output({
        id: human.id,
        type: human.type,
        programType: human.programType,
        state: human.state,
        data: human.data,
        version: human.version,
        pendingApprovals: pendingApprovals.length,
        created: human.created,
        modified: human.modified
      }, `Human: ${human.data.name} (${human.state})`);
    } else {
      if (this.outputFormat.isAgent) {
        this.output({ found: false, id });
      } else {
        console.log(`Human not found: ${id}`);
      }
    }
  }

  private async handleHumanUpdate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: human update <id> [--name "..."] [--email "..."] [--permissions "..."]');
    }

    const id = positional[0];
    const updates: any = {};

    if (named.name) updates.name = named.name;
    if (named.email) updates.email = named.email;
    if (named.permissions) {
      updates.permissions = named.permissions.split(',').map((p: string) => p.trim());
    }

    if (Object.keys(updates).length === 0) {
      this.error('No updates specified. Use --name, --email, or --permissions');
    }

    try {
      const human = await this.humanManager.updateHuman(id, updates);
      this.success(`Updated human: ${human.id} (v${human.version})`, {
        operation: 'human-update',
        id: human.id,
        version: human.version,
        updates: Object.keys(updates)
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleHumanStatus(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.set) {
      this.error('Usage: human status <id> --set available|busy|away|offline');
    }

    const id = positional[0];
    const newState = named.set as HumanState;

    if (!['available', 'busy', 'away', 'offline'].includes(newState)) {
      this.error('Invalid state. Use: available, busy, away, or offline');
    }

    try {
      const human = await this.humanManager.setStatus(id, newState);
      this.success(`Updated status: ${human.id} -> ${human.state}`, {
        operation: 'human-status',
        id: human.id,
        state: human.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleHumanNotify(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.message) {
      this.error('Usage: human notify <id> --message "..."');
    }

    const id = positional[0];

    try {
      const notification = await this.humanManager.notify(id, named.message, {
        channel: named.channel as any
      });
      this.success(`Notification sent to ${id}`, {
        operation: 'human-notify',
        humanId: id,
        notificationId: notification.id,
        channel: notification.channel
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleHumanApprove(args: string[]): Promise<void> {
    if (args.length < 2) {
      this.error('Usage: human approve <human-id> <approval-id>');
    }

    const [humanId, approvalId] = args;

    try {
      const approval = await this.humanManager.approve(humanId, approvalId);
      this.success(`Approved: ${approval.description}`, {
        operation: 'human-approve',
        humanId,
        approvalId,
        status: approval.status
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleHumanReject(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length < 2) {
      this.error('Usage: human reject <human-id> <approval-id> [--reason "..."]');
    }

    const [humanId, approvalId] = positional;

    try {
      const approval = await this.humanManager.reject(humanId, approvalId, named.reason);
      this.success(`Rejected: ${approval.description}`, {
        operation: 'human-reject',
        humanId,
        approvalId,
        status: approval.status,
        reason: approval.reason
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleHumanList(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);
    const state = named.state as HumanState | undefined;

    if (state && !['available', 'busy', 'away', 'offline'].includes(state)) {
      this.error('Invalid state. Use: available, busy, away, or offline');
    }

    const humans = this.humanManager.listHumans(state);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'human-list',
        filter: state || 'all',
        humans: humans.map(h => ({
          id: h.id,
          name: h.data.name,
          state: h.state,
          version: h.version,
          pendingApprovals: this.humanManager.getPendingApprovals(h.id).length
        })),
        count: humans.length
      });
    } else {
      console.log(`Found ${humans.length} humans${state ? ` (${state})` : ''}:\n`);
      for (const human of humans) {
        const pendingCount = this.humanManager.getPendingApprovals(human.id).length;
        const pending = pendingCount > 0 ? ` [${pendingCount} pending]` : '';
        console.log(`  ${human.id} (${human.state}, v${human.version}): ${human.data.name}${pending}`);
      }
    }
  }

  // === TASK HANDLERS ===

  private showTaskHelp(): void {
    if (this.outputFormat.isAgent) {
      this.output({
        command: 'task',
        description: 'Manage work specifications with trackable state',
        subcommands: {
          create: 'Create a task: task create <id> --title "..." [--priority P0-P4] [--description "..."] [--assignee "@(id)"]',
          get: 'Get task details: task get <id>',
          assign: 'Assign a task: task assign <id> --to <assignee>',
          start: 'Start working on a task: task start <id>',
          complete: 'Complete a task: task complete <id>',
          fail: 'Fail a task: task fail <id> --reason "..."',
          list: 'List tasks: task list [--state pending|assigned|in_progress|completed|failed] [--assignee "@(id)"]'
        },
        lifecycle: 'pending -> assigned -> in_progress -> completed|failed',
        priorities: ['P0 (critical)', 'P1 (high)', 'P2 (normal)', 'P3 (low)', 'P4 (lowest)']
      });
    } else {
      console.log('Task Management Commands\n');
      console.log('Lifecycle: pending -> assigned -> in_progress -> completed|failed\n');
      console.log('Subcommands:');
      console.log('  create <id> --title "..."             Create a new task');
      console.log('  get <id>                              Get task details');
      console.log('  assign <id> --to <assignee>           Assign task to an actor');
      console.log('  start <id>                            Start working on a task');
      console.log('  complete <id>                         Mark task as completed');
      console.log('  fail <id> --reason "..."              Mark task as failed');
      console.log('  list [--state ...] [--assignee ...]   List tasks');
      console.log('\nPriorities: P0 (critical) -> P4 (lowest)');
      console.log('\nExamples:');
      console.log('  ./ugs task create research-1 --title "Research quantum computing" --priority P1');
      console.log('  ./ugs task assign research-1 --to @(researcher)');
      console.log('  ./ugs task start research-1');
      console.log('  ./ugs task complete research-1');
      console.log('  ./ugs task list --state in_progress');
    }
  }

  private async handleTaskCreate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.title) {
      this.error('Usage: task create <id> --title "..." [--priority P0-P4] [--description "..."] [--assignee "@(id)"]');
    }

    const id = positional[0];
    const title = named.title;
    const priority = named.priority as TaskPriority | undefined;
    const description = named.description;
    const assignee = named.assignee || named.to;

    // Validate priority if provided
    if (priority && !['P0', 'P1', 'P2', 'P3', 'P4'].includes(priority)) {
      this.error('Invalid priority. Use: P0, P1, P2, P3, or P4');
    }

    try {
      const task = await this.taskManager.createTask(id, title, {
        priority,
        description,
        assignee
      });
      this.success(`Created task: ${task.id} (${task.state})`, {
        operation: 'task-create',
        id: task.id,
        title: task.data.title,
        state: task.state,
        priority: task.data.priority,
        assignee: task.data.assignee,
        version: task.version
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleTaskGet(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: task get <id>');
    }

    const id = args[0];
    const task = this.taskManager.getTask(id);

    if (task) {
      this.output({
        id: task.id,
        type: task.type,
        programType: task.programType,
        state: task.state,
        data: task.data,
        version: task.version,
        created: task.created,
        modified: task.modified
      }, `Task: ${task.data.title} (${task.state})`);
    } else {
      if (this.outputFormat.isAgent) {
        this.output({ found: false, id });
      } else {
        console.log(`Task not found: ${id}`);
      }
    }
  }

  private async handleTaskAssign(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.to) {
      this.error('Usage: task assign <id> --to <assignee>');
    }

    const id = positional[0];
    const assignee = named.to;

    try {
      const task = await this.taskManager.assignTask(id, assignee);
      this.success(`Assigned task: ${task.id} to ${assignee}`, {
        operation: 'task-assign',
        id: task.id,
        assignee: task.data.assignee,
        state: task.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleTaskStart(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: task start <id>');
    }

    const id = args[0];

    try {
      const task = await this.taskManager.startTask(id);
      this.success(`Started task: ${task.id}`, {
        operation: 'task-start',
        id: task.id,
        state: task.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleTaskComplete(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: task complete <id>');
    }

    const id = args[0];

    try {
      const task = await this.taskManager.completeTask(id);
      this.success(`Completed task: ${task.id}`, {
        operation: 'task-complete',
        id: task.id,
        state: task.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleTaskFail(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.reason) {
      this.error('Usage: task fail <id> --reason "..."');
    }

    const id = positional[0];
    const reason = named.reason;

    try {
      const task = await this.taskManager.failTask(id, reason);
      this.success(`Failed task: ${task.id}`, {
        operation: 'task-fail',
        id: task.id,
        state: task.state,
        reason: task.data.failureReason
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleTaskList(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);
    const state = named.state as TaskState | undefined;
    const assignee = named.assignee;
    const priority = named.priority as TaskPriority | undefined;

    if (state && !['pending', 'assigned', 'in_progress', 'completed', 'failed'].includes(state)) {
      this.error('Invalid state. Use: pending, assigned, in_progress, completed, or failed');
    }

    if (priority && !['P0', 'P1', 'P2', 'P3', 'P4'].includes(priority)) {
      this.error('Invalid priority. Use: P0, P1, P2, P3, or P4');
    }

    const filter: { state?: TaskState; assignee?: string; priority?: TaskPriority } = {};
    if (state) filter.state = state;
    if (assignee) filter.assignee = assignee;
    if (priority) filter.priority = priority;

    const tasks = this.taskManager.listTasks(Object.keys(filter).length > 0 ? filter : undefined);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'task-list',
        filter: filter,
        tasks: tasks.map(t => ({
          id: t.id,
          title: t.data.title,
          state: t.state,
          assignee: t.data.assignee,
          priority: t.data.priority,
          version: t.version
        })),
        count: tasks.length
      });
    } else {
      const filterDesc = Object.entries(filter).map(([k, v]) => `${k}=${v}`).join(', ') || 'all';
      console.log(`Found ${tasks.length} tasks (${filterDesc}):\n`);
      for (const task of tasks) {
        const priority = task.data.priority ? `[${task.data.priority}]` : '';
        const assignee = task.data.assignee ? `-> ${task.data.assignee}` : '';
        console.log(`  ${task.id} (${task.state}) ${priority}: ${task.data.title} ${assignee}`);
      }
    }
  }

  // === TASK DEP / READY / BLOCKED / CLOSE / STATS / PATCH / APPLY HANDLERS ===

  private async handleTaskDep(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: task dep <add|remove|show> [args...]');
    }

    const subcommand = args[0];
    const subArgs = args.slice(1);

    switch (subcommand) {
      case 'add': {
        if (subArgs.length < 2) {
          this.error('Usage: task dep add <id> <depends-on-id>');
        }
        const id = subArgs[0];
        const dependsOnId = subArgs[1];
        try {
          await this.taskManager.addDependency(id, dependsOnId);
          this.success(`Added dependency: ${id} depends on ${dependsOnId}`, {
            operation: 'task-dep-add',
            id,
            dependsOnId
          });
        } catch (error: any) {
          this.error(error.message);
        }
        break;
      }

      case 'remove': {
        if (subArgs.length < 2) {
          this.error('Usage: task dep remove <id> <depends-on-id>');
        }
        const id = subArgs[0];
        const dependsOnId = subArgs[1];
        try {
          await this.taskManager.removeDependency(id, dependsOnId);
          this.success(`Removed dependency: ${id} no longer depends on ${dependsOnId}`, {
            operation: 'task-dep-remove',
            id,
            dependsOnId
          });
        } catch (error: any) {
          this.error(error.message);
        }
        break;
      }

      case 'show': {
        if (subArgs.length === 0) {
          this.error('Usage: task dep show <id>');
        }
        const id = subArgs[0];
        const task = this.taskManager.getTask(id);
        if (!task) {
          this.error(`Task not found: ${id}`);
          return;
        }
        const { dependsOn, blockers } = this.taskManager.getDependencies(id);
        if (this.outputFormat.isAgent) {
          this.output({
            operation: 'task-dep-show',
            id,
            dependsOn: dependsOn.map(t => ({ id: t.id, title: t.data.title, state: t.state })),
            blockers: blockers.map(t => ({ id: t.id, title: t.data.title, state: t.state }))
          });
        } else {
          console.log(`Dependencies for task: ${id}\n`);
          if (dependsOn.length === 0) {
            console.log('  No dependencies.');
          } else {
            console.log('Depends on:');
            for (const dep of dependsOn) {
              const blocking = blockers.some(b => b.id === dep.id) ? ' [BLOCKING]' : ' [done]';
              console.log(`  ${dep.id} (${dep.state}): ${dep.data.title}${blocking}`);
            }
          }
          console.log(`\nBlockers: ${blockers.length}`);
        }
        break;
      }

      default:
        this.error(`Unknown dep subcommand: ${subcommand}. Use add, remove, or show.`);
    }
  }

  private async handleTaskReady(_args: string[]): Promise<void> {
    const tasks = this.taskManager.listReady();
    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'task-ready',
        tasks: tasks.map(t => ({
          id: t.id,
          title: t.data.title,
          state: t.state,
          priority: t.data.priority,
          assignee: t.data.assignee
        })),
        count: tasks.length
      });
    } else {
      console.log(`Ready tasks (${tasks.length}):\n`);
      for (const task of tasks) {
        const priority = task.data.priority ? `[${task.data.priority}]` : '';
        console.log(`  ${task.id} ${priority}: ${task.data.title}`);
      }
    }
  }

  private async handleTaskBlocked(_args: string[]): Promise<void> {
    const tasks = this.taskManager.listBlocked();
    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'task-blocked',
        tasks: tasks.map(t => {
          const { blockers } = this.taskManager.getDependencies(t.id);
          return {
            id: t.id,
            title: t.data.title,
            state: t.state,
            priority: t.data.priority,
            blockers: blockers.map(b => b.id)
          };
        }),
        count: tasks.length
      });
    } else {
      console.log(`Blocked tasks (${tasks.length}):\n`);
      for (const task of tasks) {
        const { blockers } = this.taskManager.getDependencies(task.id);
        const blockerIds = blockers.map(b => b.id).join(', ');
        const priority = task.data.priority ? `[${task.data.priority}]` : '';
        console.log(`  ${task.id} ${priority}: ${task.data.title}  (waiting on: ${blockerIds})`);
      }
    }
  }

  private async handleTaskClose(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: task close <id> [id2 id3...]');
    }

    const ids = args;
    const results: Array<{ id: string; success: boolean; error?: string }> = [];

    for (const id of ids) {
      try {
        const task = this.taskManager.getTask(id);
        if (!task) {
          results.push({ id, success: false, error: `Task not found: ${id}` });
          continue;
        }

        // Transition task to completed via appropriate path
        let currentTask = task;

        if (currentTask.lifecycle === 'pending') {
          // Assign then start then complete
          currentTask = await this.taskManager.assignTask(id, 'system');
          currentTask = await this.taskManager.startTask(id);
        } else if (currentTask.lifecycle === 'assigned') {
          currentTask = await this.taskManager.startTask(id);
        }

        if (currentTask.lifecycle === 'in_progress') {
          currentTask = await this.taskManager.completeTask(id);
        } else if (currentTask.lifecycle === 'completed') {
          // Already done
        } else {
          results.push({ id, success: false, error: `Cannot close task in ${currentTask.lifecycle} lifecycle` });
          continue;
        }

        results.push({ id, success: true });
      } catch (error: any) {
        results.push({ id, success: false, error: error.message });
      }
    }

    const succeeded = results.filter(r => r.success).map(r => r.id);
    const failed = results.filter(r => !r.success);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'task-close',
        completed: succeeded,
        errors: failed.map(f => ({ id: f.id, error: f.error })),
        count: succeeded.length
      });
    } else {
      console.log(`Closed ${succeeded.length} task(s): ${succeeded.join(', ')}`);
      if (failed.length > 0) {
        console.log(`\nFailed (${failed.length}):`);
        for (const f of failed) {
          console.log(`  ${f.id}: ${f.error}`);
        }
      }
    }
  }

  private async handleTaskStats(_args: string[]): Promise<void> {
    const allTasks = this.taskManager.listTasks();
    const counts: Record<string, number> = {
      pending: 0,
      assigned: 0,
      in_progress: 0,
      completed: 0,
      failed: 0
    };

    for (const task of allTasks) {
      counts[task.lifecycle] = (counts[task.lifecycle] || 0) + 1;
    }

    const blocked = this.taskManager.listBlocked().length;
    const ready = this.taskManager.listReady().length;

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'task-stats',
        total: allTasks.length,
        lifecycle: counts,
        blocked,
        ready
      });
    } else {
      console.log(`Tasks: ${allTasks.length} total`);
      console.log(`  pending:     ${counts.pending}`);
      console.log(`  assigned:    ${counts.assigned}`);
      console.log(`  in_progress: ${counts.in_progress}`);
      console.log(`  completed:   ${counts.completed}`);
      console.log(`  failed:      ${counts.failed}`);
      console.log(`  blocked:     ${blocked}  (of pending)`);
      console.log(`  ready:       ${ready}  (of pending)`);
    }
  }

  private async handleTaskPatch(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: task patch <id> [--title "..."] [--priority P0-P4] [--assignee "..."] [--description "..."] [--lifecycle pending] [--seq 3]');
    }

    const id = positional[0];

    const changes: any = {};
    if (named.title !== undefined) changes.title = named.title;
    if (named.priority !== undefined) changes.priority = named.priority;
    if (named.assignee !== undefined) changes.assignee = named.assignee;
    if (named.description !== undefined) changes.description = named.description;
    if (named.lifecycle !== undefined) changes.lifecycle = named.lifecycle;

    const seq = named.seq !== undefined ? parseInt(named.seq, 10) : undefined;

    if (Object.keys(changes).length === 0) {
      this.error('No changes specified. Use --title, --priority, --assignee, --description, or --lifecycle.');
    }

    try {
      const task = await this.taskManager.patchTask(id, changes, seq);
      this.success(`Patched task: ${task.id}`, {
        operation: 'task-patch',
        id: task.id,
        title: task.data.title,
        state: task.state,
        priority: task.data.priority,
        version: task.version
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleTaskApply(args: string[]): Promise<void> {
    // Read JSONL from file or stdin
    let input: string;

    const fileArg = args[0];
    if (fileArg && fileArg !== '-') {
      try {
        const { readFile } = await import('node:fs/promises');
        input = await readFile(fileArg, 'utf-8');
      } catch (error: any) {
        this.error(`Cannot read file: ${fileArg}: ${error.message}`);
        return;
      }
    } else {
      // Read from stdin
      const chunks: Buffer[] = [];
      for await (const chunk of process.stdin) {
        chunks.push(chunk);
      }
      input = Buffer.concat(chunks).toString('utf-8');
    }

    const lines = input.trim().split('\n').filter(l => l.trim());
    if (lines.length === 0) {
      this.error('No input records found.');
      return;
    }

    // Parse JSONL
    const records: any[] = [];
    const parseErrors: Array<{ line: number; error: string }> = [];

    for (let i = 0; i < lines.length; i++) {
      try {
        const obj = JSON.parse(lines[i]);
        // Support both 'depends-on' (CLI style) and 'dependsOn' (camelCase)
        const record: any = {
          id: obj.id,
          title: obj.title,
          priority: obj.priority,
          lifecycle: obj.lifecycle,
          assignee: obj.assignee,
          description: obj.description,
          dependsOn: obj.dependsOn || obj['depends-on'],
          seq: obj.seq
        };
        records.push(record);
      } catch (e: any) {
        parseErrors.push({ line: i + 1, error: e.message });
      }
    }

    const result = await this.taskManager.applyBatch(records);

    const createdItems = result.applied.filter(item => item.action === 'created');
    const updatedItems = result.applied.filter(item => item.action === 'updated');

    const totalApplied = result.applied.length;
    const totalConflicts = result.conflicts.length;
    const totalErrors = result.errors.length + parseErrors.length;

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'task-apply',
        applied: result.applied,
        conflicts: result.conflicts,
        errors: [...result.errors, ...parseErrors.map(e => ({ id: `line-${e.line}`, error: e.error }))],
        summary: {
          applied: totalApplied,
          conflicts: totalConflicts,
          errors: totalErrors
        }
      });
    } else {
      console.log(`${createdItems.length} created, ${updatedItems.length} updated, ${totalConflicts} conflict${totalConflicts !== 1 ? 's' : ''}, ${totalErrors} error${totalErrors !== 1 ? 's' : ''}`);
      if (result.conflicts.length > 0) {
        console.log('\nConflicts:');
        for (const c of result.conflicts) {
          console.log(`  ${c.id}: ${c.reason}`);
        }
      }
      if (result.errors.length > 0 || parseErrors.length > 0) {
        console.log('\nErrors:');
        for (const e of result.errors) {
          console.log(`  ${e.id}: ${e.error}`);
        }
        for (const e of parseErrors) {
          console.log(`  line ${e.line}: ${e.error}`);
        }
      }
    }
  }

  private async handleTaskExport(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);

    // --filter: all (default) | open | completed | failed
    const filterRaw = named.filter || 'all';
    if (!['all', 'open', 'completed', 'failed'].includes(filterRaw)) {
      this.error(`Invalid filter: ${filterRaw}. Use: all, open, completed, or failed`);
      return;
    }
    const filter = filterRaw as ExportFilter;

    // --prefix: only include tasks whose ID starts with this string
    const prefix = named.prefix || undefined;

    // --file: write output to file instead of stdout
    const filePath = named.file || undefined;

    const records = this.taskManager.exportTasks(filter, prefix);

    // Serialize to JSONL
    const lines = records.map(r => JSON.stringify(r));
    const output = lines.join('\n');

    if (filePath) {
      try {
        const { writeFile } = await import('node:fs/promises');
        await writeFile(filePath, output.length > 0 ? output + '\n' : '', 'utf-8');
        if (this.outputFormat.isAgent) {
          this.output({
            operation: 'task-export',
            filter,
            prefix: prefix || null,
            file: filePath,
            count: records.length
          });
        } else {
          console.log(`Exported ${records.length} tasks to ${filePath}`);
        }
      } catch (error: any) {
        this.error(`Cannot write file: ${filePath}: ${error.message}`);
      }
    } else {
      // Write to stdout
      if (output.length > 0) {
        process.stdout.write(output + '\n');
      }
      if (this.outputFormat.isAgent && !filePath) {
        // For agent mode writing to stdout, the JSONL IS the output.
        // But also log metadata to stderr so callers can parse.
        process.stderr.write(JSON.stringify({
          operation: 'task-export',
          filter,
          prefix: prefix || null,
          count: records.length
        }) + '\n');
      }
    }
  }

  // === TASK CONTENT (APPEND-ONLY) HANDLERS ===

  private async handleTaskNote(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length < 2) {
      this.error('Usage: task note <id> <text> [--author "..."]');
    }

    const id = positional[0];
    const text = positional[1];
    const author = named.author;

    try {
      const entry = await this.taskManager.appendNote(id, text, author);
      if (this.outputFormat.isAgent) {
        this.output({ operation: 'task-note', taskId: id, seq: entry.seq, entry });
      } else {
        console.log(`noted (seq:${entry.seq})`);
      }
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleTaskDecide(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length < 2) {
      this.error('Usage: task decide <id> <decision> [--context "..."] [--rationale "..."] [--author "..."]');
    }

    const id = positional[0];
    const decision = positional[1];

    try {
      const entry = await this.taskManager.recordDecision(id, decision, {
        context: named.context,
        rationale: named.rationale,
        author: named.author,
      });
      if (this.outputFormat.isAgent) {
        this.output({ operation: 'task-decide', taskId: id, seq: entry.seq, entry });
      } else {
        console.log(`decided (seq:${entry.seq})`);
      }
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleTaskLink(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length < 2 || !named.kind) {
      this.error('Usage: task link <id> <artifact> --kind file|commit|url|issue [--author "..."]');
    }

    const id = positional[0];
    const artifact = positional[1];
    const kind = named.kind as 'file' | 'commit' | 'url' | 'issue';

    if (!['file', 'commit', 'url', 'issue'].includes(kind)) {
      this.error(`Invalid kind: ${kind}. Must be one of: file, commit, url, issue`);
    }

    try {
      const entry = await this.taskManager.linkArtifact(id, artifact, kind, named.author);
      if (this.outputFormat.isAgent) {
        this.output({ operation: 'task-link', taskId: id, seq: entry.seq, entry });
      } else {
        console.log(`linked (seq:${entry.seq})`);
      }
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleTaskLog(args: string[]): Promise<void> {
    const { positional } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: task log <id>');
    }

    const id = positional[0];

    try {
      const events = this.taskManager.getEventLog(id);

      if (this.outputFormat.isAgent) {
        this.output({ operation: 'task-log', taskId: id, events });
      } else {
        if (events.length === 0) {
          console.log('(no events)');
        } else {
          for (const evt of events) {
            let line = `[${evt.seq}] ${evt.kind.padEnd(7)} ${evt.timestamp}  ${evt.text}`;
            if (evt.kind === 'link' && evt.linkKind) {
              line = `[${evt.seq}] ${'link'.padEnd(7)} ${evt.timestamp}  ${evt.linkKind}: ${evt.text}`;
            }
            console.log(line);
          }
        }
      }
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleTaskDecisions(args: string[]): Promise<void> {
    const { positional } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: task decisions <id>');
    }

    const id = positional[0];

    try {
      const decisions = this.taskManager.getDecisions(id);

      if (this.outputFormat.isAgent) {
        this.output({ operation: 'task-decisions', taskId: id, decisions });
      } else {
        if (decisions.length === 0) {
          console.log('(no decisions)');
        } else {
          for (const d of decisions) {
            console.log(`[${d.seq}] ${d.text}`);
            if (d.context) console.log(`    context: ${d.context}`);
            if (d.rationale) console.log(`    rationale: ${d.rationale}`);
          }
        }
      }
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleTaskPrime(args: string[]): Promise<void> {
    const { positional } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: task prime <id>');
    }

    const id = positional[0];

    try {
      const result = this.taskManager.primeTask(id);
      this.output(result);
    } catch (error: any) {
      this.error(error.message);
    }
  }

  // === AGENT HANDLERS ===

  private showAgentHelp(): void {
    if (this.outputFormat.isAgent) {
      this.output({
        command: 'agent',
        description: 'Manage autonomous agents with harness control',
        subcommands: {
          create: 'Create an agent: agent create <id> --name "..." --prompt "You are..." [--model @(model-id)]',
          get: 'Get agent details: agent get <id>',
          configure: 'Configure agent: agent configure <id> [--max-turns N] [--checkpoint-every N]',
          assign: 'Assign task to agent: agent assign <id> --task <task-id>',
          step: 'Execute one turn: agent step <id>',
          run: 'Run until completion: agent run <id> [--max-turns N]',
          status: 'Get agent status: agent status <id>',
          pause: 'Pause execution: agent pause <id>',
          resume: 'Resume execution: agent resume <id> [--input "..."]',
          stop: 'Stop and reset: agent stop <id>',
          reset: 'Reset to idle: agent reset <id>',
          list: 'List agents: agent list [--state idle|thinking|executing|waiting|completed|error]'
        },
        lifecycle: 'idle -> thinking <-> executing/waiting -> completed | error',
        harness: {
          maxTurns: 'Limit iterations (default 50)',
          reflectOnFailure: 'Auto-reflect on errors (default true)',
          checkpointEvery: 'Save state every N turns (default 5)'
        }
      });
    } else {
      console.log('Agent Management Commands\n');
      console.log('Lifecycle: idle -> thinking <-> executing/waiting -> completed | error\n');
      console.log('Subcommands:');
      console.log('  create <id> --name "..." --prompt "..."  Create a new agent');
      console.log('  get <id>                                 Get agent details');
      console.log('  configure <id> [--max-turns N]           Configure harness settings');
      console.log('  assign <id> --task <task-id>             Assign a task to agent');
      console.log('  step <id>                                Execute one turn');
      console.log('  run <id> [--max-turns N]                 Run until completion');
      console.log('  status <id>                              Get current status');
      console.log('  pause <id>                               Pause execution');
      console.log('  resume <id> [--input "..."]              Resume with optional input');
      console.log('  stop <id>                                Stop and reset');
      console.log('  reset <id>                               Reset to idle state');
      console.log('  list [--state ...]                       List agents');
      console.log('\nHarness settings: maxTurns, checkpointEvery, reflectOnFailure');
      console.log('\nExamples:');
      console.log('  ./ugs agent create researcher --name "Researcher" --prompt "You research topics"');
      console.log('  ./ugs agent assign researcher --task research-task');
      console.log('  ./ugs agent run researcher --max-turns 10');
      console.log('  ./ugs agent status researcher');
    }
  }

  private async handleAgentCreate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.name || !named.prompt) {
      this.error('Usage: agent create <id> --name "..." --prompt "..." [--model @(model-id)] [--max-turns N]');
    }

    const id = positional[0];

    try {
      const agent = await this.agentManager.createAgent(id, named.name, named.prompt, {
        defaultModel: named.model,
        harness: {
          maxTurns: named['max-turns'] ? parseInt(named['max-turns']) : undefined,
          checkpointEvery: named['checkpoint-every'] ? parseInt(named['checkpoint-every']) : undefined
        }
      });
      this.success(`Created agent: ${agent.id} (${agent.state})`, {
        operation: 'agent-create',
        id: agent.id,
        name: agent.data.name,
        state: agent.state,
        defaultModel: agent.data.defaultModel,
        harness: agent.data.harness,
        version: agent.version
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleAgentGet(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: agent get <id>');
    }

    const id = args[0];
    const agent = this.agentManager.getAgent(id);

    if (agent) {
      this.output({
        id: agent.id,
        type: agent.type,
        programType: agent.programType,
        state: agent.state,
        data: agent.data,
        version: agent.version,
        created: agent.created,
        modified: agent.modified
      }, `Agent: ${agent.data.name} (${agent.state})`);
    } else {
      if (this.outputFormat.isAgent) {
        this.output({ found: false, id });
      } else {
        console.log(`Agent not found: ${id}`);
      }
    }
  }

  private async handleAgentConfigure(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: agent configure <id> [--max-turns N] [--checkpoint-every N] [--name "..."]');
    }

    const id = positional[0];
    const updates: any = {};

    if (named.name) updates.name = named.name;
    if (named.prompt) updates.systemPrompt = named.prompt;
    if (named.model) updates.defaultModel = named.model;

    const harness: any = {};
    if (named['max-turns']) harness.maxTurns = parseInt(named['max-turns']);
    if (named['checkpoint-every']) harness.checkpointEvery = parseInt(named['checkpoint-every']);
    if (Object.keys(harness).length > 0) updates.harness = harness;

    if (Object.keys(updates).length === 0) {
      this.error('No updates specified');
    }

    try {
      const agent = await this.agentManager.configureAgent(id, updates);
      this.success(`Configured agent: ${agent.id}`, {
        operation: 'agent-configure',
        id: agent.id,
        updates: Object.keys(updates),
        harness: agent.data.harness,
        version: agent.version
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleAgentAssign(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.task) {
      this.error('Usage: agent assign <id> --task <task-id>');
    }

    const id = positional[0];
    const taskId = named.task;

    try {
      const agent = await this.agentManager.assignTask(id, taskId);
      this.success(`Assigned task ${taskId} to agent: ${agent.id}`, {
        operation: 'agent-assign',
        id: agent.id,
        taskId,
        state: agent.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleAgentStep(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: agent step <id>');
    }

    const id = args[0];

    try {
      const result = await this.agentManager.step(id);
      this.output({
        operation: 'agent-step',
        id,
        ...result
      }, `Step complete: turn ${result.turn}, done=${result.done}`);
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleAgentRun(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: agent run <id> [--max-turns N]');
    }

    const id = positional[0];
    const maxTurns = named['max-turns'] ? parseInt(named['max-turns']) : undefined;

    try {
      const result = await this.agentManager.run(id, maxTurns);
      this.output({
        operation: 'agent-run',
        id,
        ...result
      }, `Run complete: ${result.reason || 'finished'}, turns=${result.turn}`);
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleAgentStatus(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: agent status <id>');
    }

    const id = args[0];
    const status = this.agentManager.getStatus(id);

    if (status) {
      this.output({
        operation: 'agent-status',
        id,
        ...status
      }, `Agent ${id}: ${status.state} (turn ${status.turnCount})`);
    } else {
      if (this.outputFormat.isAgent) {
        this.output({ found: false, id });
      } else {
        console.log(`Agent not found: ${id}`);
      }
    }
  }

  private async handleAgentPause(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: agent pause <id>');
    }

    const id = args[0];

    try {
      const agent = await this.agentManager.pause(id);
      this.success(`Paused agent: ${agent.id}`, {
        operation: 'agent-pause',
        id: agent.id,
        state: agent.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleAgentResume(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: agent resume <id> [--input "..."]');
    }

    const id = positional[0];
    const input = named.input;

    try {
      const agent = await this.agentManager.resume(id, input);
      this.success(`Resumed agent: ${agent.id}`, {
        operation: 'agent-resume',
        id: agent.id,
        state: agent.state,
        withInput: !!input
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleAgentStop(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: agent stop <id>');
    }

    const id = args[0];

    try {
      const agent = await this.agentManager.stop(id);
      this.success(`Stopped agent: ${agent.id}`, {
        operation: 'agent-stop',
        id: agent.id,
        state: agent.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleAgentReset(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: agent reset <id>');
    }

    const id = args[0];

    try {
      const agent = await this.agentManager.reset(id);
      this.success(`Reset agent: ${agent.id}`, {
        operation: 'agent-reset',
        id: agent.id,
        state: agent.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleAgentList(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);
    const state = named.state as AgentState | undefined;

    if (state && !['idle', 'thinking', 'executing', 'waiting', 'completed', 'error'].includes(state)) {
      this.error('Invalid state. Use: idle, thinking, executing, waiting, completed, or error');
    }

    const agents = this.agentManager.listAgents(state);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'agent-list',
        filter: { state },
        agents: agents.map(a => ({
          id: a.id,
          name: a.data.name,
          state: a.state,
          currentTask: a.data.currentTask,
          turnCount: a.data.turnCount,
          version: a.version
        })),
        count: agents.length
      });
    } else {
      const filterDesc = state ? `state=${state}` : 'all';
      console.log(`Found ${agents.length} agents (${filterDesc}):\n`);
      for (const agent of agents) {
        const task = agent.data.currentTask ? `-> ${agent.data.currentTask}` : '';
        const turns = agent.data.turnCount ? `[turn ${agent.data.turnCount}]` : '';
        console.log(`  ${agent.id} (${agent.state}) ${turns}: ${agent.data.name} ${task}`);
      }
    }
  }

  // === SESSION HANDLERS ===

  private showSessionHelp(): void {
    if (this.outputFormat.isAgent) {
      this.output({
        command: 'session',
        description: 'Manage conversation sessions with JSONL logging',
        subcommands: {
          create: 'Create a session: session create <id> --model <model-id> [--owner @(agent-id)]',
          get: 'Get session details: session get <id>',
          send: 'Send a message: session send <id> "message" [--model ...] [--situation ...]',
          history: 'Get conversation history: session history <id> [--limit N]',
          pause: 'Pause an active session: session pause <id>',
          resume: 'Resume a paused session: session resume <id>',
          complete: 'Complete a session: session complete <id>',
          list: 'List sessions: session list [--state created|active|paused|completed]',
          prime: 'Inject workflow context: session prime [--mcp] [--no-git] [--no-ctx]'
        },
        lifecycle: 'created -> active (first message) -> paused | completed; paused -> active (resumed)'
      });
    } else {
      console.log('üí¨ Session Management Commands\n');
      console.log('Lifecycle: created -> active (first message) -> paused | completed\n');
      console.log('           paused -> active (resumed)\n');
      console.log('Subcommands:');
      console.log('  create <id> --model <model-id> [--owner ...]  Create a session');
      console.log('  get <id>                                      Get session details');
      console.log('  send <id> "message" [--model ...] [--situation ...]  Send a message');
      console.log('  history <id> [--limit N]                      Get conversation history');
      console.log('  pause <id>                                    Pause an active session');
      console.log('  resume <id>                                   Resume a paused session');
      console.log('  complete <id>                                 Complete a session');
      console.log('  list [--state ...]                            List sessions');
      console.log('\nExamples:');
      console.log('  ./ugs session create my-chat --model claude-fast');
      console.log('  ./ugs session send my-chat "Hello, how are you?"');
      console.log('  ./ugs session history my-chat --limit 10');
      console.log('  ./ugs session complete my-chat');
    }
  }

  private async handleSessionCreate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.model) {
      this.error('Usage: session create <id> --model <model-id> [--owner @(agent-id)]');
    }

    const id = positional[0];

    try {
      const session = await this.sessionManager.createSession(id, named.model, {
        owner: named.owner
      });
      this.success(`Created session: ${session.id} (${session.state})`, {
        operation: 'session-create',
        id: session.id,
        defaultModel: session.data.defaultModel,
        owner: session.data.owner,
        logFile: session.data.logFile,
        state: session.state,
        version: session.version
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleSessionGet(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: session get <id>');
    }

    const id = args[0];
    const session = this.sessionManager.getSession(id);

    if (session) {
      this.output({
        id: session.id,
        type: session.type,
        programType: session.programType,
        state: session.state,
        data: session.data,
        version: session.version,
        created: session.created,
        modified: session.modified
      }, `Session: ${session.id} (${session.state})`);
    } else {
      if (this.outputFormat.isAgent) {
        this.output({ found: false, id });
      } else {
        console.log(`Session not found: ${id}`);
      }
    }
  }

  private async handleSessionSend(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length < 2) {
      this.error('Usage: session send <id> "message" [--model ...] [--situation ...] [--system "..."]');
    }

    const id = positional[0];
    const message = positional.slice(1).join(' ');

    try {
      const result = await this.sessionManager.sendMessage(id, message, {
        model: named.model,
        situation: named.situation,
        system: named.system
      });

      if (this.outputFormat.isAgent) {
        this.output({
          operation: 'session-send',
          sessionId: id,
          success: result.success,
          text: result.text,
          usage: result.usage,
          error: result.error,
          duration: result.duration,
          model: result.model,
          situation: result.situation
        });
      } else {
        if (result.success) {
          console.log(`Response (${result.duration}ms, model: ${result.model}):`);
          console.log(result.text);
          if (result.usage) {
            console.log(`\nTokens: ${result.usage.inputTokens} in + ${result.usage.outputTokens} out`);
          }
        } else {
          console.log(`Message failed (${result.duration}ms): ${result.error}`);
        }
      }
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleSessionHistory(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: session history <id> [--limit N]');
    }

    const id = positional[0];
    const limit = named.limit ? parseInt(named.limit) : undefined;

    try {
      const history = await this.sessionManager.getHistory(id, limit);

      if (this.outputFormat.isAgent) {
        this.output({
          operation: 'session-history',
          sessionId: id,
          limit: limit,
          entries: history,
          count: history.length
        });
      } else {
        console.log(`Conversation history for ${id} (${history.length} messages):\n`);
        for (const entry of history) {
          const role = entry.message.role === 'user' ? 'üë§ User' : 'ü§ñ Assistant';
          const model = entry.message.model ? ` [${entry.message.model}]` : '';
          console.log(`${role}${model}:`);
          console.log(`  ${entry.message.content.substring(0, 200)}${entry.message.content.length > 200 ? '...' : ''}`);
          console.log();
        }
      }
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleSessionPause(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: session pause <id>');
    }

    const id = args[0];

    try {
      const session = await this.sessionManager.pauseSession(id);
      this.success(`Paused session: ${session.id}`, {
        operation: 'session-pause',
        id: session.id,
        state: session.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleSessionResume(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: session resume <id>');
    }

    const id = args[0];

    try {
      const session = await this.sessionManager.resumeSession(id);
      this.success(`Resumed session: ${session.id}`, {
        operation: 'session-resume',
        id: session.id,
        state: session.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleSessionComplete(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: session complete <id>');
    }

    const id = args[0];

    try {
      const session = await this.sessionManager.completeSession(id);
      this.success(`Completed session: ${session.id}`, {
        operation: 'session-complete',
        id: session.id,
        state: session.state
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleSessionList(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);
    const state = named.state as SessionState | undefined;

    if (state && !['created', 'active', 'paused', 'completed'].includes(state)) {
      this.error('Invalid state. Use: created, active, paused, or completed');
    }

    const sessions = this.sessionManager.listSessions(state);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'session-list',
        filter: state || 'all',
        sessions: sessions.map(s => ({
          id: s.id,
          defaultModel: s.data.defaultModel,
          owner: s.data.owner,
          state: s.state,
          version: s.version
        })),
        count: sessions.length
      });
    } else {
      console.log(`Found ${sessions.length} sessions${state ? ` (${state})` : ''}:\n`);
      for (const session of sessions) {
        const owner = session.data.owner ? ` owner: ${session.data.owner}` : '';
        console.log(`  ${session.id} (${session.state}, v${session.version}): model ${session.data.defaultModel}${owner}`);
      }
    }
  }

  // === SESSION PRIME HANDLER ===

  private async handleSessionPrime(args: string[]): Promise<void> {
    try {
      const { named } = this.parseNamedArgs(args);
      const mcpEnv = process.env.UGS_MCP === '1';
      const mcpFlag = named.mcp === 'true';
      const isMcp = mcpEnv || mcpFlag;
      const noGit = named['no-git'] === 'true';
      const noCtx = named['no-ctx'] === 'true';

      // MCP brief mode (~50 tokens)
      if (isMcp) {
        process.stdout.write('UGS workflow: ugs task ready|start|complete|close|apply. Export: ugs task export > .ugs/tasks.jsonl. Protocol: /wg\n');
        process.exit(0);
      }

      const { execSync } = await import('node:child_process');

      // Check for .ugs/PRIME.md at git root (customization hook)
      try {
        let gitRoot: string | null = null;
        try {
          gitRoot = execSync('git rev-parse --show-toplevel', { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] }).trim();
        } catch {
          // Not a git repo, skip PRIME.md check
        }
        if (gitRoot) {
          const primePath = join(gitRoot, '.ugs', 'PRIME.md');
          if (existsSync(primePath)) {
            const { readFileSync } = await import('node:fs');
            const content = readFileSync(primePath, 'utf8');
            process.stdout.write(content);
            process.exit(0);
          }
        }
      } catch {
        // Ignore errors in git root detection or file reading
      }

      // === GIT STATUS ===
      let gitSection = '';
      if (!noGit) {
        try {
          const isGitRepo = (() => {
            try { execSync('git rev-parse --is-inside-work-tree', { stdio: 'pipe' }); return true; }
            catch { return false; }
          })();
          if (isGitRepo) {
            let branch: string;
            try {
              branch = execSync('git branch --show-current', { encoding: 'utf8', stdio: 'pipe' }).trim();
              if (!branch) branch = execSync('git rev-parse --short HEAD', { encoding: 'utf8', stdio: 'pipe' }).trim();
            } catch { branch = '(detached)'; }

            let syncStatus = '';
            try {
              const upstream = execSync('git rev-parse --abbrev-ref "@{upstream}"', { encoding: 'utf8', stdio: 'pipe' }).trim();
              const ahead = parseInt(execSync('git rev-list --count "@{upstream}..HEAD"', { encoding: 'utf8', stdio: 'pipe' }).trim()) || 0;
              const behind = parseInt(execSync('git rev-list --count "HEAD..@{upstream}"', { encoding: 'utf8', stdio: 'pipe' }).trim()) || 0;
              if (ahead === 0 && behind === 0) syncStatus = `up to date with ${upstream}`;
              else if (ahead > 0 && behind === 0) syncStatus = `${ahead} ahead of ${upstream} ‚Äî push needed`;
              else if (ahead === 0 && behind > 0) syncStatus = `${behind} BEHIND ${upstream} ‚Äî pull needed`;
              else syncStatus = `${ahead} ahead, ${behind} behind ${upstream} ‚Äî diverged`;
            } catch { syncStatus = 'no upstream'; }

            let treeStatus: string;
            try {
              const dirty = execSync('git status --porcelain', { encoding: 'utf8', stdio: 'pipe' }).trim();
              if (!dirty) {
                treeStatus = 'clean';
              } else {
                const lines = dirty.split('\n').filter(Boolean);
                const modified = lines.filter(l => !l.startsWith('??')).length;
                const untracked = lines.filter(l => l.startsWith('??')).length;
                const parts: string[] = [];
                if (modified > 0) parts.push(`${modified} modified`);
                if (untracked > 0) parts.push(`${untracked} untracked`);
                treeStatus = `DIRTY ‚Äî ${parts.join(', ')}`;
              }
            } catch { treeStatus = 'unknown'; }

            gitSection = `## Git\nBranch: ${branch} (${syncStatus})\nWorking tree: ${treeStatus}\n`;
          }
        } catch { /* Non-fatal */ }
      }

      // === CTX FACTS ===
      let ctxSection = '';
      if (!noCtx) {
        try {
          execSync('which ctx', { stdio: 'pipe' });
          const keepPrefixes = ['finding:', 'decision:', 'eval:', 'project:', 'task:', 'obs:', 'note:'];
          try {
            const ctxOutput = execSync(
              'ctx query --limit=50 2>/dev/null',
              { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'], shell: true }
            ).trim();
            if (ctxOutput) {
              const lines = ctxOutput.split('\n').filter(line =>
                keepPrefixes.some(prefix => line.includes(prefix))
              );
              if (lines.length > 0) {
                ctxSection = `## Ctx Facts\n${lines.join('\n')}\n`;
              }
            }
          } catch { /* ctx query failed or no facts */ }
        } catch { /* ctx not in PATH */ }
      }

      // === READY TASKS ===
      const readyTasks = this.taskManager.listReady();
      let taskSection: string;
      if (readyTasks.length === 0) {
        taskSection = 'No unblocked tasks.';
      } else {
        const limit = 10;
        const shown = readyTasks.slice(0, limit);
        const lines = shown.map(t => {
          const priority = t.config.priority ? `[${t.config.priority}] ` : '';
          return `- ${priority}${t.id}: ${t.config.title}`;
        });
        if (readyTasks.length > limit) {
          lines.push(`... and ${readyTasks.length - limit} more`);
        }
        taskSection = lines.join('\n');
      }

      const output = `# UGS Session Context

> Run \`ugs session prime\` after compaction or new session to restore context.

${gitSection ? gitSection + '\n' : ''}${ctxSection ? ctxSection + '\n' : ''}## Ready Tasks

${taskSection}

## Core Rules

- Use \`ugs task\` for ALL task tracking. Do NOT use TodoWrite or markdown files.
- Create a task BEFORE writing code. Start it when beginning, close it when done.
- Use \`ugs task apply\` for bulk creates (pipe JSONL). Use \`ugs task patch\` for updates.
- Full protocol: invoke \`/wg\` skill for detailed reference.

## Essential Commands

### Finding Work
- \`ugs task ready\`              ‚Äî unblocked tasks (what to work on next)
- \`ugs task blocked\`            ‚Äî blocked tasks and why
- \`ugs task list\`               ‚Äî all tasks
- \`ugs task get <id>\`           ‚Äî task detail

### Creating & Updating
- \`ugs task create <id> --title "..." --priority P2\`   ‚Äî new task
- \`ugs task start <id>\`         ‚Äî mark in_progress
- \`ugs task complete <id>\`      ‚Äî mark done
- \`ugs task close <id> [id2..]\` ‚Äî close multiple at once
- \`ugs task patch <id> --title "..."\`  ‚Äî update fields
- \`ugs task apply < tasks.jsonl\`       ‚Äî bulk create/update

### Dependencies
- \`ugs task dep add <id> <dep>\` ‚Äî add dependency
- \`ugs task dep show <id>\`      ‚Äî show dependencies

### Project Health
- \`ugs task stats\`              ‚Äî counts by state
- \`ugs task export\`             ‚Äî export to JSONL (for backup/commit)

## Session Close Protocol

Before ending a session:
- [ ] \`ugs task export > .ugs/tasks.jsonl\`  (if .ugs/ exists in this project)
- [ ] \`git add .ugs/tasks.jsonl && git commit -m "chore: sync task graph"\`
`;

      process.stdout.write(output);
      process.exit(0);
    } catch {
      // Always exit 0 ‚Äî safe for hooks
      process.exit(0);
    }
  }

  // === EMBEDDING HANDLERS ===

  private async handleEmbed(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: embed <node-id> [--text "optional text"]');
    }

    const nodeId = positional[0];

    try {
      const embedding = await this.embeddingManager.embedNode(nodeId, {
        text: named.text
      });

      this.success(`Embedded node: ${nodeId}`, {
        operation: 'embed',
        nodeId,
        dimensions: embedding.length,
        model: '@cf/baai/bge-base-en-v1.5',
        customText: !!named.text
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleSimilar(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    const limit = named.limit ? parseInt(named.limit) : 10;
    const type = named.type;

    try {
      let results;

      if (named.text) {
        // Search by text query
        results = await this.embeddingManager.findSimilarToText(named.text, { type, limit });

        if (this.outputFormat.isAgent) {
          this.output({
            operation: 'similar-text',
            query: named.text,
            type: type || 'all',
            limit,
            results: results.map(r => ({
              id: r.node.id,
              type: r.node.type,
              similarity: r.similarity,
              properties: Object.fromEntries(r.node.properties)
            })),
            count: results.length
          });
        } else {
          console.log(`Found ${results.length} nodes similar to "${named.text}":\n`);
          for (const { node, similarity } of results) {
            const name = node.properties.get('name') || node.properties.get('title') || node.id;
            console.log(`  ${(similarity * 100).toFixed(1)}% - ${node.id} (${node.type || 'untyped'}): ${name}`);
          }
        }
      } else if (positional.length > 0) {
        // Search by node ID
        const nodeId = positional[0];
        results = await this.embeddingManager.findSimilarToNode(nodeId, { type, limit });

        if (this.outputFormat.isAgent) {
          this.output({
            operation: 'similar-node',
            nodeId,
            type: type || 'all',
            limit,
            results: results.map(r => ({
              id: r.node.id,
              type: r.node.type,
              similarity: r.similarity,
              properties: Object.fromEntries(r.node.properties)
            })),
            count: results.length
          });
        } else {
          console.log(`Found ${results.length} nodes similar to "${nodeId}":\n`);
          for (const { node, similarity } of results) {
            const name = node.properties.get('name') || node.properties.get('title') || node.id;
            console.log(`  ${(similarity * 100).toFixed(1)}% - ${node.id} (${node.type || 'untyped'}): ${name}`);
          }
        }
      } else {
        this.error('Usage: similar <node-id> | similar --text "query" [--type ...] [--limit N]');
      }
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleEmbedStats(): Promise<void> {
    const stats = this.embeddingManager.getStats();

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'embed-stats',
        ...stats,
        coverage: stats.totalNodes > 0 ? (stats.embeddedNodes / stats.totalNodes * 100).toFixed(1) + '%' : '0%'
      });
    } else {
      console.log('Embedding Statistics:\n');
      console.log(`  Total Nodes: ${stats.totalNodes}`);
      console.log(`  Embedded Nodes: ${stats.embeddedNodes}`);
      console.log(`  Coverage: ${stats.totalNodes > 0 ? (stats.embeddedNodes / stats.totalNodes * 100).toFixed(1) : 0}%`);
      console.log(`  Model: ${stats.model}`);
      console.log(`  Dimensions: ${stats.dimensions}`);
    }
  }

  private showGeneralHelp(): void {
    if (this.outputFormat.isAgent) {
      // Structured help for agents with topic discovery
      const help = {
        ugs: {
          version: '0.4.0',
          actor: this.outputFormat.isAgent ? 'agent' : 'human',
          dataDirectory: this.dataDir,
          commands: Object.fromEntries(
            Array.from(this.commands.entries())
              .filter(([name]) => !name.startsWith('--'))
              .map(([name, cmd]) => [name, { description: cmd.description }])
          ),
          helpTopics: Object.fromEntries(
            Array.from(this.helpTopics.entries())
              .map(([name, topic]) => [name, { 
                name: topic.name,
                description: topic.description,
                seeAlso: topic.seeAlso || []
              }])
          ),
          actorControl: {
            environment: 'UGS_ACTOR=agent|human',
            flags: '--agent | --human',
            default: 'agent'
          },
          quickStart: [
            './ugs help getting-started    # Step-by-step guide',
            './ugs load-demo              # Load sample data', 
            './ugs help workflow          # Common use patterns'
          ]
        }
      };
      this.output(help);
    } else {
      // Human-friendly help with progressive discovery
      console.log('üöÄ UGS - Universal Graph System\n');
      console.log(`Actor Mode: ${this.outputFormat.isAgent ? 'Agent' : 'Human'}`);
      console.log(`Data Directory: ${this.dataDir}\n`);
      
      // Quick start guidance
      console.log('üéØ Quick Start:');
      console.log('  ./ugs help getting-started    # Step-by-step guide');
      console.log('  ./ugs load-demo              # Load sample data');
      console.log('  ./ugs help workflow          # Common use patterns\n');
      
      console.log('üìö Learning Path:');
      console.log('  ./ugs help concepts          # What is UGS?');
      console.log('  ./ugs help getting-started   # First steps');
      console.log('  ./ugs help workflow          # Use cases');
      console.log('  ./ugs help patterns          # Design approaches');
      console.log('  ./ugs help best-practices    # Expert tips\n');
      
      console.log('Available commands:\n');
      
      for (const [name, cmd] of this.commands) {
        if (!name.startsWith('--')) {
          console.log(`  ${name.padEnd(15)} - ${cmd.description}`);
        }
      }
      
      console.log('\nü§ñ Actor Control:');
      console.log('  UGS_ACTOR=agent      # Structured output (default)');
      console.log('  UGS_ACTOR=human      # Verbose output');
      console.log('  ./ugs --agent stats  # Force agent mode');
      console.log('  ./ugs --human stats  # Force human mode');
      
      console.log('\nüí° Tips:');
      console.log('  ‚Ä¢ Use --help or help <topic> for detailed guidance');
      console.log('  ‚Ä¢ Start with load-demo to explore sample data');
      console.log('  ‚Ä¢ Switch to agent mode for script automation');
    }
  }

  private showTopicHelp(topicName: string): void {
    const topic = this.helpTopics.get(topicName);
    if (!topic) {
      this.error(`Unknown help topic: ${topicName}`);
    }

    if (this.outputFormat.isAgent) {
      this.output({
        topic: topicName,
        name: topic.name,
        description: topic.description,
        details: topic.details || null,
        examples: topic.examples || null,
        seeAlso: topic.seeAlso || null
      });
    } else {
      console.log(`üìñ Help: ${topic.name}\n`);
      console.log(`${topic.description}\n`);
      
      if (topic.details) {
        console.log('Details:');
        topic.details.forEach(detail => console.log(`  ‚Ä¢ ${detail}`));
        console.log();
      }
      
      if (topic.examples) {
        console.log('Examples:');
        topic.examples.forEach(example => console.log(`  ${example}`));
        console.log();
      }
      
      if (topic.seeAlso) {
        console.log(`See also: ${topic.seeAlso.join(', ')}`);
      }
    }
  }

  private parseProperties(propsStr?: string): Record<string, any> {
    if (!propsStr) return {};
    
    const props: Record<string, any> = {};
    propsStr.split(',').forEach(pair => {
      const [key, value] = pair.split('=');
      if (key && value) {
        let parsedValue: any = value;
        if (!isNaN(Number(value))) {
          parsedValue = Number(value);
        } else if (value.toLowerCase() === 'true') {
          parsedValue = true;
        } else if (value.toLowerCase() === 'false') {
          parsedValue = false;
        }
        props[key.trim()] = parsedValue;
      }
    });
    
    return props;
  }

  private async enterScopeContext(scope: string): Promise<void> {
    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'enter-scope-context',
        scope,
        instructions: 'Interactive scope context not available in agent mode. Use: ugs ' + scope + ' <command> [args...]'
      });
      return;
    }

    console.log(`üö™ Entering ${scope} scope context`);
    console.log(`üí° All commands now work within ${scope} scope`);
    console.log(`Type 'exit' to return to global context\n`);

    const readline = await import('readline');
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: `ugs ${scope}> `
    });

    rl.prompt();
    
    rl.on('line', async (line) => {
      const input = line.trim();
      
      if (input === 'exit' || input === 'quit') {
        console.log(`‚úì Exited ${scope} scope context`);
        rl.close();
        return;
      }
      
      if (input) {
        const parts = input.split(/\s+/);
        await this.runInScope(scope, parts);
      }
      
      rl.prompt();
    });
    
    rl.on('close', () => {
      process.exit(0);
    });
  }

  private async runInScope(scope: string, commandParts: string[]): Promise<void> {
    if (commandParts.length === 0) return;
    
    const commandName = commandParts[0];
    const commandArgs = commandParts.slice(1);
    
    // Prefix all node IDs with scope if the command creates or references nodes
    const scopedArgs = this.applyScopeToArgs(scope, commandName, commandArgs);
    
    const command = this.commands.get(commandName);
    if (command && !['user', 'project', 'scratch'].includes(commandName)) {
      try {
        await command.handler(scopedArgs);
      } catch (error: any) {
        this.error(error.message, 0);
      }
    } else {
      this.error(`Unknown command in ${scope} context: ${commandName}`, 0);
    }
  }

  private applyScopeToArgs(scope: string, commandName: string, args: string[]): string[] {
    // Commands that take node IDs as first argument and should be scoped
    const nodeCommands = ['add-node', 'get', 'update-node', 'set-property', 'remove-property'];
    const edgeCommands = ['add-edge']; // Special handling for edges (from/to nodes)
    
    if (nodeCommands.includes(commandName) && args.length > 0) {
      // Scope the first argument (node ID) if it doesn't already have a scope
      const nodeId = args[0];
      if (!nodeId.includes(':')) {
        args[0] = `${scope}:${nodeId}`;
      }
    } else if (edgeCommands.includes(commandName) && args.length >= 3) {
      // Scope the from and to node IDs if they don't have scopes
      const [edgeId, fromNode, toNode, ...rest] = args;
      const scopedFrom = fromNode.includes(':') ? fromNode : `${scope}:${fromNode}`;
      const scopedTo = toNode.includes(':') ? toNode : `${scope}:${toNode}`;
      args[1] = scopedFrom;
      args[2] = scopedTo;
    }
    
    return args;
  }

  private async loadDemoData(): Promise<void> {
    this.log('üöÄ Loading UGS demo data...');
    
    // People
    await this.store.addNode('alice', 'person', { name: 'Alice Johnson', role: 'developer', team: 'backend' });
    await this.store.addNode('bob', 'person', { name: 'Bob Smith', role: 'manager', team: 'product' });
    await this.store.addNode('charlie', 'person', { name: 'Charlie Brown', role: 'designer', team: 'frontend' });
    
    // Projects  
    await this.store.addNode('auth_proj', 'project', { name: 'Authentication System', priority: 'high' });
    await this.store.addNode('api_proj', 'project', { name: 'REST API Development', priority: 'medium' });
    
    // Tasks
    await this.store.addNode('task_1', 'task', { title: 'Implement Login', status: 'active', estimate: 5 });
    await this.store.addNode('task_2', 'task', { title: 'OAuth Integration', status: 'todo', estimate: 8 });
    await this.store.addNode('task_3', 'task', { title: 'API Documentation', status: 'done', estimate: 3 });
    
    // Relationships
    await this.store.addEdge('e1', 'alice', 'task_1', 'assigned_to');
    await this.store.addEdge('e2', 'alice', 'task_2', 'assigned_to');
    await this.store.addEdge('e3', 'charlie', 'task_3', 'assigned_to');
    await this.store.addEdge('e4', 'task_1', 'auth_proj', 'belongs_to');
    await this.store.addEdge('e5', 'task_2', 'auth_proj', 'belongs_to');
    await this.store.addEdge('e6', 'task_3', 'api_proj', 'belongs_to');
    await this.store.addEdge('e7', 'alice', 'bob', 'reports_to');
    await this.store.addEdge('e8', 'task_1', 'task_2', 'blocks', {}, 2);
    
    this.success('Demo data loaded! Try: stats, search alice, path alice auth_proj', {
      operation: 'load-demo',
      nodesCreated: 8,
      edgesCreated: 8
    });
  }

  // === EPIC HANDLERS ===

  private showEpicHelp(): void {
    if (this.outputFormat.isAgent) {
      this.output({
        command: 'epic',
        description: 'Group related tasks into a meaningful unit of work',
        subcommands: {
          create: 'Create an epic: epic create <id> --title "..." [--description "..."] [--owner "..."]',
          get: 'Get epic details: epic get <id>',
          list: 'List epics: epic list [--lifecycle planning|active|completed|cancelled]',
          activate: 'Activate an epic: epic activate <id>',
          complete: 'Complete an epic: epic complete <id>',
          cancel: 'Cancel an epic: epic cancel <id>',
          update: 'Update an epic: epic update <id> [--title "..."] [--description "..."] [--owner "..."]',
          'task add': 'Add task to epic: epic task add <epic-id> <task-id>',
          'task remove': 'Remove task from epic: epic task remove <epic-id> <task-id>',
          tasks: 'List tasks in epic: epic tasks <epic-id>',
          stats: 'Show epic stats: epic stats <epic-id>',
        },
        lifecycle: 'planning -> active -> completed | cancelled',
      });
    } else {
      console.log('Epic Management Commands\n');
      console.log('Lifecycle: planning -> active -> completed | cancelled\n');
      console.log('Subcommands:');
      console.log('  create <id> --title "..."          Create a new epic');
      console.log('  get <id>                           Get epic details');
      console.log('  list [--lifecycle ...]             List epics');
      console.log('  activate <id>                      Activate an epic');
      console.log('  complete <id>                      Mark epic as completed');
      console.log('  cancel <id>                        Cancel an epic');
      console.log('  update <id> [--title ...]          Update epic fields');
      console.log('  task add <epic-id> <task-id>       Add a task to an epic');
      console.log('  task remove <epic-id> <task-id>    Remove a task from an epic');
      console.log('  tasks <epic-id>                    List tasks in an epic');
      console.log('  stats <epic-id>                    Show completion stats');
    }
  }

  private async handleEpicCreate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.title) {
      this.error('Usage: epic create <id> --title "..." [--description "..."] [--owner "..."]');
    }

    const id = positional[0];
    const config = {
      title: named.title,
      description: named.description,
      owner: named.owner,
    };

    try {
      const epic = await this.epicManager.createEpic(id, config);
      this.success(`Created epic: ${epic.id} (${epic.lifecycle})`, {
        operation: 'epic-create',
        id: epic.id,
        title: epic.config.title,
        lifecycle: epic.lifecycle,
        owner: epic.config.owner,
        version: epic.version,
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleEpicGet(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: epic get <id>');
    }

    const id = args[0];
    const epic = this.epicManager.getEpic(id);

    if (epic) {
      this.output({
        id: epic.id,
        lifecycle: epic.lifecycle,
        config: epic.config,
        seq: epic.seq,
        version: epic.version,
        created: epic.created,
        modified: epic.modified,
      }, `Epic: ${epic.config.title} (${epic.lifecycle})`);
    } else {
      if (this.outputFormat.isAgent) {
        this.output({ found: false, id });
      } else {
        console.log(`Epic not found: ${id}`);
      }
    }
  }

  private async handleEpicList(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);
    const lifecycle = named.lifecycle as EpicLifecycle | undefined;

    if (lifecycle && !['planning', 'active', 'completed', 'cancelled'].includes(lifecycle)) {
      this.error('Invalid lifecycle. Use: planning, active, completed, or cancelled');
    }

    const epics = this.epicManager.listEpics(lifecycle ? { lifecycle } : undefined);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'epic-list',
        filter: lifecycle || 'all',
        epics: epics.map(e => ({
          id: e.id,
          title: e.config.title,
          lifecycle: e.lifecycle,
          owner: e.config.owner,
          version: e.version,
        })),
        count: epics.length,
      });
    } else {
      const filterDesc = lifecycle ? ` (${lifecycle})` : '';
      console.log(`Found ${epics.length} epics${filterDesc}:\n`);
      for (const epic of epics) {
        const owner = epic.config.owner ? ` [${epic.config.owner}]` : '';
        console.log(`  ${epic.id} (${epic.lifecycle})${owner}: ${epic.config.title}`);
      }
    }
  }

  private async handleEpicActivate(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: epic activate <id>');
    }

    const id = args[0];

    try {
      const epic = await this.epicManager.activateEpic(id);
      this.success(`Activated epic: ${epic.id}`, {
        operation: 'epic-activate',
        id: epic.id,
        lifecycle: epic.lifecycle,
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleEpicComplete(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: epic complete <id>');
    }

    const id = args[0];

    try {
      const epic = await this.epicManager.completeEpic(id);
      this.success(`Completed epic: ${epic.id}`, {
        operation: 'epic-complete',
        id: epic.id,
        lifecycle: epic.lifecycle,
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleEpicCancel(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: epic cancel <id>');
    }

    const id = args[0];

    try {
      const epic = await this.epicManager.cancelEpic(id);
      this.success(`Cancelled epic: ${epic.id}`, {
        operation: 'epic-cancel',
        id: epic.id,
        lifecycle: epic.lifecycle,
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleEpicUpdate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: epic update <id> [--title "..."] [--description "..."] [--owner "..."]');
    }

    const id = positional[0];
    const changes: any = {};
    if (named.title !== undefined) changes.title = named.title;
    if (named.description !== undefined) changes.description = named.description;
    if (named.owner !== undefined) changes.owner = named.owner;

    try {
      const epic = await this.epicManager.updateEpic(id, changes);
      this.success(`Updated epic: ${epic.id}`, {
        operation: 'epic-update',
        id: epic.id,
        version: epic.version,
        config: epic.config,
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleEpicTask(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: epic task <add|remove> <epic-id> <task-id>');
    }

    const subcommand = args[0];
    const subArgs = args.slice(1);

    switch (subcommand) {
      case 'add': {
        if (subArgs.length < 2) {
          this.error('Usage: epic task add <epic-id> <task-id>');
        }
        const epicId = subArgs[0];
        const taskId = subArgs[1];
        try {
          await this.epicManager.addTaskToEpic(epicId, taskId);
          this.success(`Added task ${taskId} to epic ${epicId}`, {
            operation: 'epic-task-add',
            epicId,
            taskId,
          });
        } catch (error: any) {
          this.error(error.message);
        }
        break;
      }

      case 'remove': {
        if (subArgs.length < 2) {
          this.error('Usage: epic task remove <epic-id> <task-id>');
        }
        const epicId = subArgs[0];
        const taskId = subArgs[1];
        try {
          await this.epicManager.removeTaskFromEpic(epicId, taskId);
          this.success(`Removed task ${taskId} from epic ${epicId}`, {
            operation: 'epic-task-remove',
            epicId,
            taskId,
          });
        } catch (error: any) {
          this.error(error.message);
        }
        break;
      }

      default:
        this.error(`Unknown epic task subcommand: ${subcommand}. Use add or remove.`);
    }
  }

  private async handleEpicTasks(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: epic tasks <epic-id>');
    }

    const epicId = args[0];
    const epic = this.epicManager.getEpic(epicId);

    if (!epic) {
      this.error(`Epic not found: ${epicId}`);
      return;
    }

    const tasks = this.epicManager.getEpicTasks(epicId);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'epic-tasks',
        epicId,
        tasks: tasks.map(t => ({
          id: t.id,
          title: t.title,
          lifecycle: t.lifecycle,
        })),
        count: tasks.length,
      });
    } else {
      console.log(`Tasks in epic ${epicId} (${tasks.length}):\n`);
      for (const task of tasks) {
        console.log(`  ${task.id} (${task.lifecycle}): ${task.title}`);
      }
    }
  }

  private async handleEpicStats(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: epic stats <epic-id>');
    }

    const epicId = args[0];
    const epic = this.epicManager.getEpic(epicId);

    if (!epic) {
      this.error(`Epic not found: ${epicId}`);
      return;
    }

    const stats = this.epicManager.getEpicStats(epicId);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'epic-stats',
        epicId,
        title: epic.config.title,
        lifecycle: epic.lifecycle,
        stats,
      });
    } else {
      console.log(`Stats for epic: ${epic.config.title} (${epic.lifecycle})\n`);
      console.log(`  total:       ${stats.total}`);
      console.log(`  completed:   ${stats.completed}`);
      console.log(`  in_progress: ${stats.in_progress}`);
      console.log(`  pending:     ${stats.pending}`);
      if (stats.total > 0) {
        const pct = Math.round((stats.completed / stats.total) * 100);
        console.log(`\n  progress:    ${pct}%`);
      }
    }
  }

  // === PROJECT HANDLERS ===

  private showProjectHelp(): void {
    if (this.outputFormat.isAgent) {
      this.output({
        command: 'project',
        description: 'Group epics into a top-level container',
        subcommands: {
          create: 'Create a project: project create <id> --title "..." [--description "..."] [--owner "..."]',
          get: 'Get project details: project get <id>',
          list: 'List projects: project list [--status draft|active|completed|archived]',
          activate: 'Activate a project: project activate <id>',
          complete: 'Complete a project: project complete <id>',
          archive: 'Archive a project: project archive <id>',
          update: 'Update a project: project update <id> [--title "..."] [--description "..."] [--owner "..."]',
          'epic add': 'Add epic to project: project epic add <project-id> <epic-id>',
          'epic remove': 'Remove epic from project: project epic remove <project-id> <epic-id>',
          epics: 'List epics in project: project epics <project-id>',
          stats: 'Show rolled-up stats: project stats <project-id>',
        },
        status: 'draft -> active -> completed | archived',
      });
    } else {
      console.log('Project Management Commands\n');
      console.log('Status: draft -> active -> completed | archived\n');
      console.log('Subcommands:');
      console.log('  create <id> --title "..."           Create a new project');
      console.log('  get <id>                            Get project details');
      console.log('  list [--status ...]                 List projects');
      console.log('  activate <id>                       Activate a project');
      console.log('  complete <id>                       Mark project as completed');
      console.log('  archive <id>                        Archive a project');
      console.log('  update <id> [--title ...]           Update project fields');
      console.log('  epic add <project-id> <epic-id>     Add an epic to a project');
      console.log('  epic remove <project-id> <epic-id>  Remove an epic from a project');
      console.log('  epics <project-id>                  List epics in a project');
      console.log('  stats <project-id>                  Show rolled-up stats');
    }
  }

  private async handleProjectCreate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0 || !named.title) {
      this.error('Usage: project create <id> --title "..." [--description "..."] [--owner "..."]');
    }

    const id = positional[0];
    const config = {
      title: named.title,
      description: named.description,
      owner: named.owner,
    };

    try {
      const project = await this.projectManager.createProject(id, config);
      this.success(`Created project: ${project.id} (${project.status})`, {
        operation: 'project-create',
        id: project.id,
        title: project.config.title,
        status: project.status,
        owner: project.config.owner,
        version: project.version,
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProjectGet(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: project get <id>');
    }

    const id = args[0];
    const project = this.projectManager.getProject(id);

    if (project) {
      this.output({
        id: project.id,
        status: project.status,
        config: project.config,
        seq: project.seq,
        version: project.version,
        created: project.created,
        modified: project.modified,
      }, `Project: ${project.config.title} (${project.status})`);
    } else {
      if (this.outputFormat.isAgent) {
        this.output({ found: false, id });
      } else {
        console.log(`Project not found: ${id}`);
      }
    }
  }

  private async handleProjectList(args: string[]): Promise<void> {
    const { named } = this.parseNamedArgs(args);
    const status = named.status as ProjectStatus | undefined;

    if (status && !['draft', 'active', 'completed', 'archived'].includes(status)) {
      this.error('Invalid status. Use: draft, active, completed, or archived');
    }

    const projects = this.projectManager.listProjects(status ? { status } : undefined);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'project-list',
        filter: status || 'all',
        projects: projects.map(p => ({
          id: p.id,
          title: p.config.title,
          status: p.status,
          owner: p.config.owner,
          version: p.version,
        })),
        count: projects.length,
      });
    } else {
      const filterDesc = status ? ` (${status})` : '';
      console.log(`Found ${projects.length} projects${filterDesc}:\n`);
      for (const project of projects) {
        const owner = project.config.owner ? ` [${project.config.owner}]` : '';
        console.log(`  ${project.id} (${project.status})${owner}: ${project.config.title}`);
      }
    }
  }

  private async handleProjectActivate(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: project activate <id>');
    }

    const id = args[0];

    try {
      const project = await this.projectManager.activateProject(id);
      this.success(`Activated project: ${project.id}`, {
        operation: 'project-activate',
        id: project.id,
        status: project.status,
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProjectComplete(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: project complete <id>');
    }

    const id = args[0];

    try {
      const project = await this.projectManager.completeProject(id);
      this.success(`Completed project: ${project.id}`, {
        operation: 'project-complete',
        id: project.id,
        status: project.status,
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProjectArchive(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: project archive <id>');
    }

    const id = args[0];

    try {
      const project = await this.projectManager.archiveProject(id);
      this.success(`Archived project: ${project.id}`, {
        operation: 'project-archive',
        id: project.id,
        status: project.status,
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProjectUpdate(args: string[]): Promise<void> {
    const { positional, named } = this.parseNamedArgs(args);

    if (positional.length === 0) {
      this.error('Usage: project update <id> [--title "..."] [--description "..."] [--owner "..."]');
    }

    const id = positional[0];
    const changes: any = {};
    if (named.title !== undefined) changes.title = named.title;
    if (named.description !== undefined) changes.description = named.description;
    if (named.owner !== undefined) changes.owner = named.owner;

    try {
      const project = await this.projectManager.updateProject(id, changes);
      this.success(`Updated project: ${project.id}`, {
        operation: 'project-update',
        id: project.id,
        version: project.version,
        config: project.config,
      });
    } catch (error: any) {
      this.error(error.message);
    }
  }

  private async handleProjectEpic(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: project epic <add|remove> <project-id> <epic-id>');
    }

    const subcommand = args[0];
    const subArgs = args.slice(1);

    switch (subcommand) {
      case 'add': {
        if (subArgs.length < 2) {
          this.error('Usage: project epic add <project-id> <epic-id>');
        }
        const projectId = subArgs[0];
        const epicId = subArgs[1];
        try {
          await this.projectManager.addEpicToProject(projectId, epicId);
          this.success(`Added epic ${epicId} to project ${projectId}`, {
            operation: 'project-epic-add',
            projectId,
            epicId,
          });
        } catch (error: any) {
          this.error(error.message);
        }
        break;
      }

      case 'remove': {
        if (subArgs.length < 2) {
          this.error('Usage: project epic remove <project-id> <epic-id>');
        }
        const projectId = subArgs[0];
        const epicId = subArgs[1];
        try {
          await this.projectManager.removeEpicFromProject(projectId, epicId);
          this.success(`Removed epic ${epicId} from project ${projectId}`, {
            operation: 'project-epic-remove',
            projectId,
            epicId,
          });
        } catch (error: any) {
          this.error(error.message);
        }
        break;
      }

      default:
        this.error(`Unknown project epic subcommand: ${subcommand}. Use add or remove.`);
    }
  }

  private async handleProjectEpics(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: project epics <project-id>');
    }

    const projectId = args[0];
    const project = this.projectManager.getProject(projectId);

    if (!project) {
      this.error(`Project not found: ${projectId}`);
      return;
    }

    const epics = this.projectManager.getProjectEpics(projectId);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'project-epics',
        projectId,
        epics: epics.map(e => ({
          id: e.id,
          title: e.title,
          lifecycle: e.lifecycle,
        })),
        count: epics.length,
      });
    } else {
      console.log(`Epics in project ${projectId} (${epics.length}):\n`);
      for (const epic of epics) {
        console.log(`  ${epic.id} (${epic.lifecycle}): ${epic.title}`);
      }
    }
  }

  private async handleProjectStats(args: string[]): Promise<void> {
    if (args.length === 0) {
      this.error('Usage: project stats <project-id>');
    }

    const projectId = args[0];
    const project = this.projectManager.getProject(projectId);

    if (!project) {
      this.error(`Project not found: ${projectId}`);
      return;
    }

    const stats = this.projectManager.getProjectStats(projectId);

    if (this.outputFormat.isAgent) {
      this.output({
        operation: 'project-stats',
        projectId,
        title: project.config.title,
        status: project.status,
        stats,
      });
    } else {
      console.log(`Stats for project: ${project.config.title} (${project.status})\n`);
      console.log(`  epics:     ${stats.epics}`);
      console.log(`  tasks:     ${stats.tasks}`);
      console.log(`  completed: ${stats.completed}`);
      if (stats.tasks > 0) {
        const pct = Math.round((stats.completed / stats.tasks) * 100);
        console.log(`\n  progress:  ${pct}%`);
      }
    }
  }

  public async run(): Promise<void> {
    const args = process.argv.slice(2);
    
    // Filter out actor and help flags  
    let commandArgs = args.filter(arg => !['--agent', '--human', '--help', '-h'].includes(arg));
    
    // Handle data directory flag
    const dataDirIndex = commandArgs.indexOf('--data-dir');
    if (dataDirIndex !== -1 && dataDirIndex + 1 < commandArgs.length) {
      this.dataDir = commandArgs[dataDirIndex + 1];
      commandArgs = commandArgs.filter((_, i) => i !== dataDirIndex && i !== dataDirIndex + 1);
      this.store = new GraphStore(this.dataDir);
    }
    
    // Initialize persistence
    await this.store.initialize();
    
    // Handle --help flag (check original args since it's filtered from commandArgs)
    if (args.includes('--help') || args.includes('-h')) {
      this.showGeneralHelp();
      return;
    }
    
    if (commandArgs.length === 0) {
      await this.startInteractiveMode();
      return;
    }
    
    const commandName = commandArgs[0];
    const commandArguments = commandArgs.slice(1);
    
    const command = this.commands.get(commandName);
    if (command) {
      try {
        await command.handler(commandArguments);
      } catch (error: any) {
        this.error(error.message);
      }
    } else {
      this.error(`Unknown command: ${commandName}`);
    }
  }

  private async startInteractiveMode(): Promise<void> {
    if (this.outputFormat.isAgent) {
      // Minimal startup for agents
      console.log('{"mode":"interactive","actor":"agent","ready":true}');
    } else {
      // Friendly startup for humans
      console.log('üöÄ UGS - Interactive Graph Database');
      console.log(`üìÇ Data Directory: ${this.dataDir}`);
      console.log(`ü§ñ Actor Mode: ${this.outputFormat.isAgent ? 'Agent' : 'Human'}`);
      console.log('Type "help" for commands, "snapshot" to save state, "quit" to exit\n');
    }
    
    const readline = await import('readline');
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: this.outputFormat.isAgent ? '' : 'ugs> '
    });

    if (!this.outputFormat.isAgent) rl.prompt();
    
    rl.on('line', async (line) => {
      const input = line.trim();
      
      if (input === 'exit' || input === 'quit') {
        await this.store.shutdown();
        if (this.outputFormat.isAgent) {
          this.output({ operation: 'exit', snapshot: true });
        } else {
          console.log('‚úì Final snapshot created, UGS session ended');
        }
        rl.close();
        return;
      }
      
      if (input) {
        const parts = input.split(/\s+/);
        const commandName = parts[0];
        const commandArgs = parts.slice(1);
        
        const command = this.commands.get(commandName);
        if (command) {
          try {
            await command.handler(commandArgs);
          } catch (error: any) {
            this.error(error.message, 0); // Don't exit in interactive mode
          }
        } else if (input !== '') {
          this.error(`Unknown command: ${commandName}`, 0);
        }
      }
      
      if (!this.outputFormat.isAgent) rl.prompt();
    });
    
    rl.on('close', async () => {
      await this.store.shutdown();
      process.exit(0);
    });
  }
}

// Run CLI if called directly
if (import.meta.main) {
  const dataDir = process.env.UGS_DATA_DIR || './data';

  // Create execution context from environment (loads credentials)
  const ctx = createContextFromEnv({ id: 'cli', type: 'human' });

  // Run CLI within context
  runWithContextAsync(ctx, () => new UGSCLI(dataDir).run()).catch((error) => {
    const isAgent = !process.argv.includes('--human') &&
                   process.env.UGS_ACTOR?.toLowerCase() !== 'human';
    if (isAgent) {
      console.error(JSON.stringify({ error: error.message, fatal: true }));
    } else {
      console.error('üí• Fatal error:', error.message);
    }
    process.exit(1);
  });
}

export { UGSCLI };
