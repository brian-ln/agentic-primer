use convergence:domain-graph/address.{address};

/// Convergence signal strength
enum convergence-strength {
    weak,
    moderate,
    strong,
}

/// Convergence detection result
record convergence-detection {
    /// Converging nodes/paths
    nodes: list<address>,
    /// Strength of convergence
    strength: convergence-strength,
    /// Similarity score (0.0 to 1.0)
    similarity: f64,
    /// Semantic theme
    theme: option<string>,
    /// Timestamp
    detected-at: u64,
}

/// Convergence tracking options
record convergence-options {
    /// Minimum similarity threshold
    min-similarity: f64,
    /// Minimum nodes for convergence
    min-nodes: u32,
    /// Time window for detection (ms)
    time-window: u64,
}

/// Convergence detection interface
interface convergence {
    use convergence:domain-graph/address.{address};

    /// Detect convergence among a set of nodes
    ///
    /// Analyzes semantic similarity and clustering to identify
    /// groups of nodes that converge on similar conclusions.
    detect-convergence: func(
        nodes: list<address>,
        options: convergence-options
    ) -> result<list<convergence-detection>, string>;

    /// Monitor ongoing convergence
    ///
    /// Track nodes as they're created/updated and detect emerging patterns.
    /// Returns convergence events as they occur.
    monitor-convergence: func(
        node-type: option<string>,
        options: convergence-options
    ) -> result<_, string>;

    /// Get convergence history
    get-convergence-history: func(limit: u32) -> list<convergence-detection>;

    /// Check if nodes are converging
    are-converging: func(
        nodes: list<address>,
        threshold: f64
    ) -> result<bool, string>;

    /// Extract common theme from converging nodes
    extract-theme: func(nodes: list<address>) -> result<string, string>;
}

use convergence:domain-graph/address.{address};

/// Embedding model information
record embedding-model {
    name: string,
    dimensions: u32,
    provider: string,
}

/// Similarity search result
record similarity-result {
    node: address,
    similarity: f64,
}

/// Similarity search options
record similarity-options {
    /// Filter by node type
    node-type: option<string>,
    /// Maximum results
    limit: u32,
    /// Minimum similarity threshold (0.0 to 1.0)
    min-similarity: f64,
}

/// Embedding statistics
record embedding-stats {
    total-nodes: u32,
    embedded-nodes: u32,
    model: string,
    dimensions: u32,
}

/// Embedding and similarity search interface
interface embedding {
    use convergence:domain-graph/address.{address};

    /// Get default embedding model
    get-model: func() -> embedding-model;

    /// Generate embedding for text
    embed-text: func(text: string) -> result<list<f64>, string>;

    /// Embed node content and store
    ///
    /// Extracts text from node properties and data, generates embedding,
    /// and stores it in the node for future similarity searches.
    embed-node: func(node: address) -> result<list<f64>, string>;

    /// Batch embed multiple nodes
    ///
    /// Returns addresses of successfully embedded nodes.
    /// Failed embeddings are silently skipped.
    embed-nodes: func(nodes: list<address>) -> result<list<address>, string>;

    /// Get stored embedding for node
    get-node-embedding: func(node: address) -> option<list<f64>>;

    /// Check if node has embedding
    has-embedding: func(node: address) -> bool;

    /// Calculate cosine similarity between vectors
    cosine-similarity: func(a: list<f64>, b: list<f64>) -> result<f64, string>;

    /// Find nodes similar to query text
    find-similar-to-text: func(
        text: string,
        options: similarity-options
    ) -> result<list<similarity-result>, string>;

    /// Find nodes similar to a given node
    find-similar-to-node: func(
        node: address,
        options: similarity-options
    ) -> result<list<similarity-result>, string>;

    /// Find nodes similar to vector
    find-similar: func(
        vector: list<f64>,
        options: similarity-options
    ) -> list<similarity-result>;

    /// Get embedding statistics
    get-stats: func() -> embedding-stats;
}

use convergence:domain-graph/address.{address};
use agentic-primer:types@0.1.0.{json-value};

/// Session context snapshot
record session-context {
    /// Active session
    session: address,
    /// Current iteration/turn
    iteration: u32,
    /// Active task (if any)
    task: option<address>,
    /// Key-value context data
    context: list<tuple<string, json-value>>,
    /// Timestamp
    captured-at: u64,
}

/// Knowledge artifact
record knowledge-artifact {
    id: string,
    artifact-type: string,
    content: json-value,
    source: address,
    created-at: u64,
    relevance: f64,
}

/// Session knowledge state
record session-knowledge {
    /// Session address
    session: address,
    /// Captured artifacts
    artifacts: list<knowledge-artifact>,
    /// Learned patterns
    patterns: list<string>,
    /// Context snapshots
    contexts: list<session-context>,
}

/// Session state management interface
interface session-state {
    use convergence:domain-graph/address.{address};

    /// Capture current session context
    capture-context: func(session: address) -> result<session-context, string>;

    /// Get session context history
    get-context-history: func(session: address, limit: u32) -> list<session-context>;

    /// Store knowledge artifact
    store-artifact: func(
        session: address,
        artifact-type: string,
        content: json-value,
        source: address
    ) -> result<knowledge-artifact, string>;

    /// Retrieve artifacts by type
    get-artifacts: func(
        session: address,
        artifact-type: option<string>
    ) -> list<knowledge-artifact>;

    /// Extract learned patterns from session
    ///
    /// Analyzes session history to identify recurring patterns,
    /// successful strategies, and emergent knowledge.
    extract-patterns: func(session: address) -> result<list<string>, string>;

    /// Get session knowledge state
    get-session-knowledge: func(session: address) -> result<session-knowledge, string>;

    /// Clear session state
    clear-session-state: func(session: address) -> result<_, string>;

    /// Export session knowledge
    export-knowledge: func(session: address) -> result<json-value, string>;

    /// Import session knowledge
    import-knowledge: func(
        session: address,
        knowledge: json-value
    ) -> result<_, string>;
}

