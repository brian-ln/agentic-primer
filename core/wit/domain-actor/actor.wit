// Actor Protocol for Universal Graph System
//
// Actors provide message-based communication primitives on the graph.
// Every actor has an address and communicates via the message protocol.
// Enables tool use, API calls, and inference through graph messaging.

package convergence:domain-actor@0.1.0;

use convergence:domain-graph/address.{address};
use agentic-primer:message/message.{message-envelope, node-type, node-capabilities, node-health};
use agentic-primer:types/types.{error-info};

/// Actor communication patterns
enum message-pattern {
    /// Fire-and-forget (no response expected)
    tell,
    /// Request-response (synchronous)
    ask,
    /// Streaming response
    stream,
}

/// Actor lifecycle states
enum actor-state {
    /// Actor is initializing
    initializing,
    /// Actor is ready to receive messages
    ready,
    /// Actor is processing messages
    active,
    /// Actor is paused (backpressure)
    paused,
    /// Actor is shutting down
    stopping,
    /// Actor has stopped
    stopped,
    /// Actor encountered an error
    error,
}

/// Actor supervision strategy
enum supervision-strategy {
    /// Restart actor on failure
    restart,
    /// Stop actor on failure
    stop,
    /// Resume processing (ignore error)
    resume,
    /// Escalate to parent supervisor
    escalate,
}

/// Actor metadata
record actor-metadata {
    /// Actor name (human-readable)
    name: string,
    /// Actor type classification
    actor-type: node-type,
    /// Supported message patterns
    patterns: list<message-pattern>,
    /// Actor capabilities
    capabilities: node-capabilities,
    /// Supervision strategy
    supervision: supervision-strategy,
    /// Actor version
    version: string,
    /// Creation timestamp
    created: string,
}

/// Message response for ask pattern
record message-response {
    /// Response message ID
    id: string,
    /// Correlation ID linking to request
    correlation-id: string,
    /// Responder address
    from: address,
    /// Original sender address
    to: address,
    /// Success/failure flag
    success: bool,
    /// Response payload (serialized)
    payload: option<list<u8>>,
    /// Error message if failed
    error: option<string>,
    /// Response timestamp
    timestamp: string,
}

/// Stream event for continuous updates
record stream-event {
    /// Event ID
    id: string,
    /// Correlation ID linking to stream request
    correlation-id: string,
    /// Stream source address
    from: address,
    /// Event type
    event-type: stream-event-type,
    /// Event payload (serialized)
    payload: option<list<u8>>,
    /// Error message if error event
    error: option<string>,
    /// Event timestamp
    timestamp: string,
}

/// Stream event types
enum stream-event-type {
    /// Data chunk
    data,
    /// Stream completed successfully
    end,
    /// Stream error occurred
    error,
}

/// Actor statistics
record actor-stats {
    /// Current actor state
    state: actor-state,
    /// Messages received
    messages-received: u64,
    /// Messages sent
    messages-sent: u64,
    /// Messages failed
    messages-failed: u64,
    /// Current mailbox size
    mailbox-size: u32,
    /// Actor uptime in milliseconds
    uptime-ms: u64,
    /// Last message timestamp
    last-message-at: option<string>,
}

/// Actor resource interface
///
/// Actors are the fundamental communication primitive in the graph.
/// They encapsulate state and behavior, communicating only via messages.
resource actor {
    /// Get actor's address
    get-address: func() -> address;

    /// Get actor metadata
    get-metadata: func() -> actor-metadata;

    /// Get actor health
    health: func() -> node-health;

    /// Get actor statistics
    stats: func() -> actor-stats;

    /// Receive a message (tell pattern - fire and forget)
    /// Actor processes message asynchronously
    receive: func(message: message-envelope) -> result<_, error-info>;

    /// Ask pattern - send message and wait for response
    /// Returns response with correlation to original message
    ask: func(message: message-envelope, timeout-ms: u64) -> result<message-response, error-info>;

    /// Send a tell message to another actor
    /// Fire-and-forget, no response expected
    tell: func(to: address, message-type: string, payload: list<u8>) -> result<_, error-info>;

    /// Send an ask message to another actor
    /// Request-response pattern with timeout
    ask-actor: func(
        to: address,
        message-type: string,
        payload: list<u8>,
        timeout-ms: u64
    ) -> result<message-response, error-info>;

    /// Shutdown actor gracefully
    shutdown: func() -> result<_, error-info>;
}

/// Actor system management interface
interface actor-system {
    use convergence:domain-graph/address.{address};
    use agentic-primer:types/types.{error-info};

    /// Create a new actor instance
    /// Actor is registered in the graph at the specified address
    create-actor: func(
        id: string,
        actor-type: node-type,
        config: list<tuple<string, string>>
    ) -> result<actor, error-info>;

    /// Get an existing actor by address
    get-actor: func(addr: address) -> result<actor, error-info>;

    /// Register a custom actor implementation
    /// Used for tool actors, program actors, etc.
    register-actor: func(
        id: string,
        actor: actor
    ) -> result<_, error-info>;

    /// Unregister an actor
    unregister-actor: func(id: string) -> result<_, error-info>;

    /// List all registered actors
    list-actors: func() -> list<address>;

    /// List actors by type
    list-by-type: func(actor-type: node-type) -> list<address>;

    /// Send a message through the actor system
    /// Routes to appropriate actor based on destination address
    send: func(message: message-envelope) -> result<option<message-response>, error-info>;

    /// Get actor system statistics
    system-stats: func() -> actor-system-stats;
}

/// Actor system statistics
record actor-system-stats {
    /// Total number of actors
    total-actors: u32,
    /// Active actors (processing messages)
    active-actors: u32,
    /// Total messages routed
    messages-routed: u64,
    /// Total messages failed
    messages-failed: u64,
    /// System uptime in milliseconds
    uptime-ms: u64,
}

/// Streaming actor interface (optional capability)
///
/// Actors implementing this interface support streaming responses
/// for real-time data (e.g., LLM token streaming, live updates)
interface streaming-actor {
    use convergence:domain-graph/address.{address};
    use agentic-primer:types/types.{error-info};

    /// Start a streaming request
    /// Returns stream handle for consuming events
    stream-request: func(
        actor-addr: address,
        message-type: string,
        payload: list<u8>,
        buffer-size: u32
    ) -> result<stream-handle, error-info>;

    /// Get next event from stream
    /// Returns none when stream completes or times out
    stream-next: func(
        handle: stream-handle,
        timeout-ms: u64
    ) -> result<option<stream-event>, error-info>;

    /// Cancel a stream
    cancel-stream: func(handle: stream-handle) -> result<_, error-info>;

    /// Check if stream is complete
    is-stream-complete: func(handle: stream-handle) -> bool;
}

/// Stream handle for consuming streaming responses
resource stream-handle {
    /// Get stream correlation ID
    correlation-id: func() -> string;

    /// Get source actor address
    source: func() -> address;

    /// Check if stream has buffered events
    has-data: func() -> bool;

    /// Close the stream handle
    close: func() -> result<_, error-info>;
}

/// Port-based pub/sub interface (optional capability)
///
/// Actors can expose named ports for 1:N broadcasting.
/// Enables reactive patterns where one actor publishes events
/// and multiple subscribers consume them independently.
interface port-actor {
    use convergence:domain-graph/address.{address};
    use agentic-primer:types/types.{error-info};

    /// Get available ports on an actor
    list-ports: func(actor-addr: address) -> result<list<string>, error-info>;

    /// Subscribe to a port
    /// Creates a subscription handle for consuming port events
    subscribe: func(
        actor-addr: address,
        port-name: string,
        buffer-size: u32
    ) -> result<port-subscription, error-info>;

    /// Unsubscribe from a port
    unsubscribe: func(subscription: port-subscription) -> result<_, error-info>;

    /// Publish event to a port (actor-side)
    /// Broadcasts to all subscribers
    publish: func(
        actor-addr: address,
        port-name: string,
        payload: list<u8>
    ) -> result<_, error-info>;
}

/// Port subscription handle
resource port-subscription {
    /// Get actor address
    actor-address: func() -> address;

    /// Get port name
    port-name: func() -> string;

    /// Receive next event from port
    /// Returns none if no events available within timeout
    receive: func(timeout-ms: u64) -> result<option<list<u8>>, error-info>;

    /// Check if subscription has buffered events
    has-events: func() -> bool;

    /// Close subscription
    close: func() -> result<_, error-info>;
}
