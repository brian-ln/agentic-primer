// Query DSL for Graph Traversal and Pattern Matching
//
// Inspired by Halo paper: query compilation, optimization, and distributed execution.

package convergence:domain@0.1.0;

use address.{address};
use edge.{edge-direction};
use node.{property-value};
use signal-hub:core/types@0.1.0.{json-value};

/// Pattern specification for matching nodes
record pattern-spec {
    /// Variable name to bind matches
    variable: string,
    /// Node types to match
    labels: list<string>,
    /// Property filters
    where-clause: list<tuple<string, property-value>>,
}

/// Relationship constraint
record relationship-constraint {
    target-variable: string,
    edge-type: option<string>,
    direction: edge-direction,
    properties: list<tuple<string, property-value>>,
}

/// Traversal specification
record traversal-spec {
    from-variable: string,
    edge-type: option<string>,
    direction: edge-direction,
    min-depth: option<u32>,
    max-depth: option<u32>,
    result-variable: string,
}

/// Aggregation operation
enum aggregation-op {
    count,
    collect,
    group,
    sum,
    avg,
}

/// Aggregation specification
record aggregation-spec {
    operation: aggregation-op,
    variable: string,
    group-by: option<string>,
    result-variable: string,
}

/// Query definition
record query-definition {
    patterns: list<pattern-spec>,
    traversals: list<traversal-spec>,
    aggregations: list<aggregation-spec>,
    return-variables: list<string>,
}

/// Query execution statistics
record query-stats {
    duration-ms: u64,
    steps-executed: u32,
    messages-sent: u32,
    cache-hits: u32,
    cache-misses: u32,
    results-returned: u32,
}

/// Query result
record query-result {
    /// Variable bindings (variable -> list of addresses)
    bindings: list<tuple<string, list<address>>>,
    /// Execution statistics
    stats: query-stats,
    /// Success flag
    success: bool,
    /// Error message (if failed)
    error: option<string>,
}

/// Query compilation and execution interface
interface query {
    use address.{address};

    /// Compile query to optimized plan
    ///
    /// Performs predicate pushdown, index selection, and parallelization.
    /// Returns plan ID for execution.
    compile: func(definition: query-definition) -> result<string, string>;

    /// Execute compiled query plan
    execute: func(plan-id: string) -> result<query-result, string>;

    /// Execute query (compile + execute)
    query-execute: func(definition: query-definition) -> result<query-result, string>;

    /// Explain query plan (for debugging)
    explain: func(definition: query-definition) -> result<string, string>;

    /// Get query statistics for learning
    get-query-stats: func(plan-id: string) -> option<query-stats>;

    /// Clear query plan cache
    clear-cache: func() -> result<_, string>;
}

/// Query builder interface (fluent API)
interface query-builder {
    use address.{address};

    /// Create new query builder
    new-query: func() -> query-builder;

    /// Match pattern
    match-pattern: func(pattern: pattern-spec) -> query-builder;

    /// Add traversal
    traverse: func(traversal: traversal-spec) -> query-builder;

    /// Add aggregation
    aggregate: func(aggregation: aggregation-spec) -> query-builder;

    /// Return variables
    return-vars: func(variables: list<string>) -> query-builder;

    /// Build query definition
    build: func() -> query-definition;

    /// Execute query
    execute: func() -> result<query-result, string>;
}
