// Graph Operations for Universal Graph System
//
// High-level graph operations including traversal, pathfinding, and analytics.

package convergence:domain@0.1.0;

use address.{address};
use edge.{edge-direction};

/// Traversal algorithm selection
enum traversal-algorithm {
    breadth-first,
    depth-first,
}

/// Traversal options
record traversal-options {
    /// Direction to traverse
    direction: edge-direction,
    /// Edge type filter
    edge-type: option<string>,
    /// Maximum depth
    max-depth: u32,
    /// Algorithm to use
    algorithm: traversal-algorithm,
    /// Maximum results
    max-results: u32,
}

/// Traversal result entry
record traversal-result {
    /// Node address
    node: address,
    /// Depth from start
    depth: u32,
    /// Path from start to this node
    path: list<address>,
}

/// Path result from pathfinding
record path-result {
    /// Node addresses in path order
    path: list<address>,
    /// Total distance/cost
    distance: float64,
}

/// Node degree statistics
record node-degree {
    /// Incoming edge count
    in-degree: u32,
    /// Outgoing edge count
    out-degree: u32,
    /// Total degree
    total: u32,
}

/// Graph analytics result
record graph-stats {
    /// Total node count
    node-count: u32,
    /// Total edge count
    edge-count: u32,
    /// Average node degree
    avg-degree: float64,
    /// Maximum depth in graph
    max-depth: u32,
}

/// Graph traversal and analytics interface
interface graph {
    use address.{address};

    /// Traverse graph from a starting node
    ///
    /// Returns nodes reachable from start according to options.
    /// Supports BFS/DFS, depth limits, and edge type filtering.
    traverse: func(start: address, options: traversal-options) -> list<traversal-result>;

    /// Find shortest path between two nodes (Dijkstra)
    ///
    /// Uses edge weights for cost calculation.
    /// Returns path and total distance, or none if unreachable.
    find-shortest-path: func(
        from: address,
        to: address,
        edge-type: option<string>
    ) -> option<path-result>;

    /// Get node degree (connectivity)
    get-node-degree: func(node: address) -> node-degree;

    /// Get most connected nodes
    get-most-connected: func(limit: u32) -> list<tuple<address, node-degree>>;

    /// Get graph statistics
    get-stats: func() -> graph-stats;

    /// Check if path exists between nodes
    has-path: func(from: address, to: address, edge-type: option<string>) -> bool;

    /// Get connected components
    ///
    /// Returns groups of nodes that are connected to each other.
    get-connected-components: func() -> list<list<address>>;
}
