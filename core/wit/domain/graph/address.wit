// Address Primitive for Universal Graph System
//
// Addresses (@(id)) are first-class primitives for universal interconnectedness.
// They support namespacing and different resolution scopes (nodes, edges, computed values).
//
// Design: Structured record (not string) to support future extensibility.

package convergence:domain@0.1.0;

/// Address types and resolution interface
interface address {
    /// Address scope determines how the address is resolved
    variant address-scope {
        /// Direct node reference
        node,
        /// Edge reference with endpoints
        edge(edge-ref),
        /// Computed/derived value
        computed(string),
    }

    /// Edge reference for scoped addresses
    record edge-ref {
        source: string,
        target: string,
    }

    /// Address primitive - universal reference to graph elements
    ///
    /// Format: @(id) with optional namespace and scope modifiers
    /// Examples:
    ///   @(task-123)           - Simple node reference
    ///   @(task:ns1/task-123)  - Namespaced reference
    ///   @(edge:from->to)      - Edge reference
    record address {
        /// Unique identifier within scope
        id: string,
        /// Optional namespace for scoping
        namespace: option<string>,
        /// Resolution scope
        scope: address-scope,
        /// Optional version for temporal queries
        version: option<string>,
    }

    /// Parse error types
    variant parse-error {
        invalid-format(string),
        missing-id,
        invalid-scope(string),
    }

    /// Resolution error types
    variant resolve-error {
        not-found(string),
        ambiguous(list<string>),
        invalid-scope,
        permission-denied,
    }

    /// Routing information for resolved addresses
    record routing-info {
        /// Canonical address
        canonical: address,
        /// Physical location hint
        location: option<string>,
        /// Metadata for resolution
        metadata: list<tuple<string, string>>,
    }

    /// Parse address from string format
    ///
    /// Accepts formats:
    ///   @(id)
    ///   @(id:version)
    ///   @(namespace/id)
    ///   @(namespace/id:version)
    parse: func(input: string) -> result<address, parse-error>;

    /// Serialize address to canonical string format
    serialize: func(addr: address) -> string;

    /// Resolve address to routing information
    resolve: func(addr: address) -> result<routing-info, resolve-error>;

    /// Create address from components
    create: func(
        id: string,
        namespace: option<string>,
        scope: address-scope,
        version: option<string>
    ) -> address;

    /// Normalize address (canonicalize)
    normalize: func(addr: address) -> address;

    /// Check if two addresses refer to the same entity
    equals: func(a: address, b: address) -> bool;
}
