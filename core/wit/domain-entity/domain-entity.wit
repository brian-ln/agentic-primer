
use convergence:domain-graph/address.{address};
use convergence:domain-entity/entity.{entity};

/// Agent execution state
enum agent-state {
    idle,
    thinking,
    executing,
    waiting,
    completed,
    error,
}

/// Agent harness configuration (execution limits)
record agent-harness {
    /// Maximum turns before auto-stop
    max-turns: u32,
    /// Auto-reflect on errors
    reflect-on-failure: bool,
    /// Checkpoint interval (turns)
    checkpoint-every: u32,
}

/// Agent configuration
record agent-config {
    name: string,
    system-prompt: string,
    tools: list<address>,
    default-model: address,
    harness: agent-harness,
}

/// Step execution result
record step-result {
    done: bool,
    turn: option<u32>,
    reason: option<string>,
    response: option<string>,
    error: option<string>,
}

/// Agent resource - autonomous task executor
///
/// Agents execute tasks iteratively with model inference and tool use.
/// They maintain session history and support streaming responses.
resource agent {
    use convergence:domain-entity/entity.{entity};

    /// Get underlying entity
    as-entity: func() -> entity;

    /// Get current execution state
    get-state: func() -> agent-state;

    /// Get agent configuration
    get-config: func() -> agent-config;

    /// Get current task (if assigned)
    get-current-task: func() -> option<address>;

    /// Get current session (if active)
    get-current-session: func() -> option<address>;

    /// Get turn count
    get-turn-count: func() -> u32;

    /// Get last error (if any)
    get-last-error: func() -> option<string>;
}

/// Agent lifecycle and execution interface
interface agent-ops {
    use convergence:domain-graph/address.{address};

    /// Create a new agent in idle state
    create-agent: func(
        id: string,
        name: string,
        system-prompt: string,
        default-model: address,
        harness: option<agent-harness>
    ) -> result<address, string>;

    /// Get agent by address
    get-agent: func(addr: address) -> result<agent, string>;

    /// Configure agent (only in idle state)
    configure-agent: func(
        addr: address,
        config: agent-config
    ) -> result<_, string>;

    /// Assign task to agent (idle -> thinking)
    assign-task: func(addr: address, task: address) -> result<_, string>;

    /// Execute one turn (thinking -> thinking/executing/completed/error)
    ///
    /// Returns step result indicating if execution should continue.
    /// Supports streaming via external event subscriptions.
    step: func(addr: address) -> result<step-result, string>;

    /// Run agent until completion or limit
    run: func(addr: address, max-turns: option<u32>) -> result<step-result, string>;

    /// Pause execution (thinking/executing -> waiting)
    pause: func(addr: address, reason: option<string>) -> result<_, string>;

    /// Resume execution (waiting -> thinking)
    resume: func(addr: address, input: option<string>) -> result<_, string>;

    /// Stop and reset (any -> idle)
    stop: func(addr: address) -> result<_, string>;

    /// Set error state
    set-error: func(addr: address, error: string) -> result<_, string>;

    /// List agents by state
    list-by-state: func(state: agent-state) -> list<address>;
}

use convergence:domain-graph/address.{address};
use agentic-primer:types@0.1.0.{json-value};

/// Entity kind discriminator
enum entity-kind {
    agent,
    task,
    session,
    human,
    model,
    provider,
    program,
}

/// Entity lifecycle states (for programs)
enum entity-lifecycle {
    draft,
    published,
    deprecated,
}

/// Entity metadata
record entity-metadata {
    kind: entity-kind,
    lifecycle: option<entity-lifecycle>,
    version: u32,
    created: u64,
    modified: u64,
}

/// Base entity interface
///
/// All domain entities implement this interface.
/// Entities are specialized nodes with typed semantics.
resource entity {
    /// Get entity's unique address
    get-address: func() -> address;

    /// Get entity kind
    get-kind: func() -> entity-kind;

    /// Get entity metadata
    get-metadata: func() -> entity-metadata;

    /// Get entity configuration as JSON
    get-config: func() -> json-value;

    /// Update entity configuration
    update-config: func(config: json-value) -> result<_, string>;

    /// Serialize to JSON
    to-json: func() -> json-value;
}

/// Entity factory and query interface
interface entity-ops {
    use convergence:domain-graph/address.{address};

    /// Create entity from kind and configuration
    create-entity: func(
        id: string,
        kind: entity-kind,
        config: json-value
    ) -> result<address, string>;

    /// Get entity by address
    get-entity: func(addr: address) -> result<entity, string>;

    /// Delete entity
    delete-entity: func(addr: address) -> result<_, string>;

    /// List entities by kind
    list-by-kind: func(kind: entity-kind) -> list<address>;

    /// List entities by lifecycle
    list-by-lifecycle: func(lifecycle: entity-lifecycle) -> list<address>;
}


use convergence:domain-graph/address.{address};
use convergence:domain-entity/entity.{entity};

/// Human presence/availability states
enum human-state {
    available,
    busy,
    away,
    offline,
}

/// Notification channel
enum notification-channel {
    terminal,
    email,
    slack,
}

/// Human permission
enum human-permission {
    approve,
    assign,
    configure,
    admin,
}

/// Human preferences
record human-preferences {
    notification-channel: option<notification-channel>,
    timezone: option<string>,
}

/// Human configuration
record human-config {
    name: string,
    email: option<string>,
    preferences: option<human-preferences>,
    permissions: list<human-permission>,
}

/// Approval request status
enum approval-status {
    pending,
    approved,
    rejected,
}

/// Approval request
record approval-request {
    id: string,
    description: string,
    requested-by: option<address>,
    requested-at: u64,
    status: approval-status,
    resolved-at: option<u64>,
    reason: option<string>,
}

/// Notification
record notification {
    id: string,
    message: string,
    sent-at: u64,
    channel: notification-channel,
    read: bool,
}

/// Human resource - user representation
resource human {
    use convergence:domain-entity/entity.{entity};

    /// Get underlying entity
    as-entity: func() -> entity;

    /// Get human state (presence)
    get-state: func() -> human-state;

    /// Get human configuration
    get-config: func() -> human-config;

    /// Check if human has permission
    has-permission: func(permission: human-permission) -> bool;
}

/// Human lifecycle and interaction interface
interface human-ops {
    use convergence:domain-graph/address.{address};

    /// Create a new human
    create-human: func(
        id: string,
        name: string,
        config: human-config,
        initial-state: option<human-state>
    ) -> result<address, string>;

    /// Get human by address
    get-human: func(addr: address) -> result<human, string>;

    /// Update human configuration
    update-human: func(
        addr: address,
        config: human-config
    ) -> result<_, string>;

    /// Set human status/presence
    set-status: func(addr: address, state: human-state) -> result<_, string>;

    /// Send notification to human
    notify: func(
        addr: address,
        message: string,
        channel: option<notification-channel>
    ) -> result<notification, string>;

    /// Request approval from human
    request-approval: func(
        addr: address,
        description: string,
        requested-by: option<address>
    ) -> result<approval-request, string>;

    /// Approve a pending request
    approve: func(
        addr: address,
        approval-id: string
    ) -> result<approval-request, string>;

    /// Reject a pending request
    reject: func(
        addr: address,
        approval-id: string,
        reason: option<string>
    ) -> result<approval-request, string>;

    /// Get pending approvals for human
    get-pending-approvals: func(addr: address) -> list<approval-request>;

    /// Get notifications for human
    get-notifications: func(addr: address, unread-only: bool) -> list<notification>;

    /// List humans by state
    list-by-state: func(state: human-state) -> list<address>;
}


use convergence:domain-graph/address.{address};
use convergence:domain-entity/entity.{entity};

/// Session lifecycle states
enum session-lifecycle {
    created,
    active,
    paused,
    completed,
}

/// Message role
enum message-role {
    user,
    assistant,
}

/// Message usage statistics
record message-usage {
    input-tokens: u32,
    output-tokens: u32,
}

/// Session message entry (JSONL format)
record session-message {
    uuid: string,
    parent-uuid: option<string>,
    timestamp: string,
    role: message-role,
    content: string,
    model: option<string>,
    usage: option<message-usage>,
}

/// Session configuration
record session-config {
    owner: option<address>,
    default-model: address,
    log-file: string,
}

/// Send message options
record send-message-options {
    model: option<address>,
    situation: option<string>,
    system: option<string>,
}

/// Send message result
record send-message-result {
    success: bool,
    text: option<string>,
    usage: option<message-usage>,
    error: option<string>,
    duration: u64,
    model: string,
}

/// Session resource - conversation container
resource session {
    use convergence:domain-entity/entity.{entity};

    /// Get underlying entity
    as-entity: func() -> entity;

    /// Get session lifecycle state
    get-lifecycle: func() -> session-lifecycle;

    /// Get session configuration
    get-config: func() -> session-config;

    /// Get conversation history
    get-history: func(limit: option<u32>) -> list<session-message>;

    /// Get message count
    get-message-count: func() -> u32;
}

/// Session lifecycle and messaging interface
interface session-ops {
    use convergence:domain-graph/address.{address};

    /// Create a new session
    create-session: func(
        id: string,
        default-model: address,
        owner: option<address>
    ) -> result<address, string>;

    /// Get session by address
    get-session: func(addr: address) -> result<session, string>;

    /// Send message in session (creates -> active, paused -> active)
    ///
    /// Logs user message, invokes model, logs assistant response.
    /// Supports streaming via external event subscriptions.
    send-message: func(
        addr: address,
        message: string,
        options: option<send-message-options>
    ) -> result<send-message-result, string>;

    /// Pause session (active -> paused)
    pause-session: func(addr: address) -> result<_, string>;

    /// Resume session (paused -> active)
    resume-session: func(addr: address) -> result<_, string>;

    /// Complete session (active/paused -> completed)
    complete-session: func(addr: address) -> result<_, string>;

    /// List sessions by lifecycle
    list-by-lifecycle: func(lifecycle: session-lifecycle) -> list<address>;

    /// List sessions by owner
    list-by-owner: func(owner: address) -> list<address>;
}


use convergence:domain-graph/address.{address};
use convergence:domain-entity/entity.{entity};
use agentic-primer:types@0.1.0.{json-value};

/// Task lifecycle states
enum task-lifecycle {
    pending,
    assigned,
    in-progress,
    completed,
    failed,
}

/// Task priority levels
enum task-priority {
    p0,
    p1,
    p2,
    p3,
    p4,
}

/// Success criterion specification
record success-criterion {
    /// Criterion type (file-exists, word-count, custom, etc.)
    criterion-type: string,
    /// Criterion parameters as JSON
    params: json-value,
}

/// Task specification (inputs, outputs, constraints)
record task-spec {
    inputs: list<string>,
    outputs: list<string>,
    constraints: list<string>,
    success-criteria: list<success-criterion>,
}

/// Task configuration
record task-config {
    title: string,
    description: option<string>,
    spec: option<task-spec>,
    assignee: option<address>,
    priority: option<task-priority>,
}

/// Task resource - work specification
resource task {
    use convergence:domain-entity/entity.{entity};

    /// Get underlying entity
    as-entity: func() -> entity;

    /// Get task lifecycle state
    get-lifecycle: func() -> task-lifecycle;

    /// Get task configuration
    get-config: func() -> task-config;

    /// Get task result (if completed)
    get-result: func() -> option<json-value>;

    /// Get failure reason (if failed)
    get-failure-reason: func() -> option<string>;

    /// Evaluate success criteria
    evaluate-criteria: func() -> result<bool, string>;
}

/// Task lifecycle management interface
interface task-ops {
    use convergence:domain-graph/address.{address};

    /// Create a new task in pending state
    create-task: func(
        id: string,
        title: string,
        config: task-config
    ) -> result<address, string>;

    /// Get task by address
    get-task: func(addr: address) -> result<task, string>;

    /// Update task (only in pending/assigned)
    update-task: func(
        addr: address,
        config: task-config
    ) -> result<_, string>;

    /// Assign task to actor (pending/assigned -> assigned)
    assign-task: func(addr: address, assignee: address) -> result<_, string>;

    /// Unassign task (assigned/in-progress -> pending)
    unassign-task: func(addr: address) -> result<_, string>;

    /// Start task (assigned -> in-progress)
    start-task: func(addr: address) -> result<_, string>;

    /// Complete task (in-progress -> completed)
    complete-task: func(addr: address, result: option<json-value>) -> result<_, string>;

    /// Fail task (in-progress -> failed)
    fail-task: func(addr: address, reason: string) -> result<_, string>;

    /// List tasks by lifecycle
    list-by-lifecycle: func(lifecycle: task-lifecycle) -> list<address>;

    /// List tasks by assignee
    list-by-assignee: func(assignee: address) -> list<address>;

    /// List tasks by priority
    list-by-priority: func(priority: task-priority) -> list<address>;
}

