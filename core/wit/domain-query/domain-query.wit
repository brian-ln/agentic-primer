use convergence:domain-graph/address.{address};
use agentic-primer:types@0.1.0.{json-value};

/// Criterion evaluation result
enum criterion-result {
    pass,
    fail,
    inconclusive,
}

/// Common criterion types
enum criterion-type {
    file-exists,
    word-count,
    pattern-match,
    custom,
}

/// File existence criterion parameters
record file-exists-params {
    path: string,
}

/// Word count criterion parameters
record word-count-params {
    min-words: option<u32>,
    max-words: option<u32>,
    text-source: string,
}

/// Pattern match criterion parameters
record pattern-match-params {
    pattern: string,
    text-source: string,
    must-match: bool,
}

/// Custom criterion parameters
record custom-params {
    evaluator-code: string,
    params: json-value,
}

/// Criterion specification
variant criterion-spec {
    file-exists(file-exists-params),
    word-count(word-count-params),
    pattern-match(pattern-match-params),
    custom(custom-params),
}

/// Evaluation context
record eval-context {
    /// Task being evaluated
    task: address,
    /// Evaluation timestamp
    timestamp: u64,
    /// Additional context data
    context: json-value,
}

/// Evaluation result with details
record evaluation-result {
    result: criterion-result,
    reason: option<string>,
    details: option<json-value>,
}

/// Success criteria evaluation interface
interface criteria {
    use convergence:domain-graph/address.{address};

    /// Evaluate a single criterion
    evaluate-criterion: func(
        spec: criterion-spec,
        context: eval-context
    ) -> result<evaluation-result, string>;

    /// Evaluate multiple criteria (AND logic)
    evaluate-all: func(
        specs: list<criterion-spec>,
        context: eval-context
    ) -> result<evaluation-result, string>;

    /// Evaluate multiple criteria (OR logic)
    evaluate-any: func(
        specs: list<criterion-spec>,
        context: eval-context
    ) -> result<evaluation-result, string>;

    /// Register custom evaluator
    register-evaluator: func(
        name: string,
        evaluator-code: string
    ) -> result<_, string>;

    /// List registered evaluators
    list-evaluators: func() -> list<string>;
}

use convergence:domain-graph/address.{address};
use convergence:domain-graph/edge.{edge-direction};
use node.{property-value};
use agentic-primer:types@0.1.0.{json-value};

/// Pattern specification for matching nodes
record pattern-spec {
    /// Variable name to bind matches
    variable: string,
    /// Node types to match
    labels: list<string>,
    /// Property filters
    where-clause: list<tuple<string, property-value>>,
}

/// Relationship constraint
record relationship-constraint {
    target-variable: string,
    edge-type: option<string>,
    direction: edge-direction,
    properties: list<tuple<string, property-value>>,
}

/// Traversal specification
record traversal-spec {
    from-variable: string,
    edge-type: option<string>,
    direction: edge-direction,
    min-depth: option<u32>,
    max-depth: option<u32>,
    result-variable: string,
}

/// Aggregation operation
enum aggregation-op {
    count,
    collect,
    group,
    sum,
    avg,
}

/// Aggregation specification
record aggregation-spec {
    operation: aggregation-op,
    variable: string,
    group-by: option<string>,
    result-variable: string,
}

/// Query definition
record query-definition {
    patterns: list<pattern-spec>,
    traversals: list<traversal-spec>,
    aggregations: list<aggregation-spec>,
    return-variables: list<string>,
}

/// Query execution statistics
record query-stats {
    duration-ms: u64,
    steps-executed: u32,
    messages-sent: u32,
    cache-hits: u32,
    cache-misses: u32,
    results-returned: u32,
}

/// Query result
record query-result {
    /// Variable bindings (variable -> list of addresses)
    bindings: list<tuple<string, list<address>>>,
    /// Execution statistics
    stats: query-stats,
    /// Success flag
    success: bool,
    /// Error message (if failed)
    error: option<string>,
}

/// Query compilation and execution interface
interface query {
    use convergence:domain-graph/address.{address};

    /// Compile query to optimized plan
    ///
    /// Performs predicate pushdown, index selection, and parallelization.
    /// Returns plan ID for execution.
    compile: func(definition: query-definition) -> result<string, string>;

    /// Execute compiled query plan
    execute: func(plan-id: string) -> result<query-result, string>;

    /// Execute query (compile + execute)
    query-execute: func(definition: query-definition) -> result<query-result, string>;

    /// Explain query plan (for debugging)
    explain: func(definition: query-definition) -> result<string, string>;

    /// Get query statistics for learning
    get-query-stats: func(plan-id: string) -> option<query-stats>;

    /// Clear query plan cache
    clear-cache: func() -> result<_, string>;
}

/// Query builder interface (fluent API)
interface query-builder {
    use convergence:domain-graph/address.{address};

    /// Create new query builder
    new-query: func() -> query-builder;

    /// Match pattern
    match-pattern: func(pattern: pattern-spec) -> query-builder;

    /// Add traversal
    traverse: func(traversal: traversal-spec) -> query-builder;

    /// Add aggregation
    aggregate: func(aggregation: aggregation-spec) -> query-builder;

    /// Return variables
    return-vars: func(variables: list<string>) -> query-builder;

    /// Build query definition
    build: func() -> query-definition;

    /// Execute query
    execute: func() -> result<query-result, string>;
}

