#!/usr/bin/env tsx
/**
 * Generate TypeScript types and Zod validators from domain.schema.json
 *
 * This script generates:
 * - domain.types.ts: TypeScript type definitions
 * - domain.validators.ts: Zod validation schemas
 *
 * From: core/wit/domain/domain.schema.json
 */

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import { compile, Options } from 'json-schema-to-typescript';

const SCHEMA_PATH = join(__dirname, '../core/wit/domain/domain.schema.json');
const TYPES_OUTPUT = join(__dirname, '../core/wit/domain/domain.types.ts');
const VALIDATORS_OUTPUT = join(__dirname, '../core/wit/domain/domain.validators.ts');

interface JsonSchema {
  $schema: string;
  $id: string;
  title: string;
  description: string;
  definitions: Record<string, any>;
}

async function generateTypes() {
  console.log('Reading schema from:', SCHEMA_PATH);
  const schemaContent = readFileSync(SCHEMA_PATH, 'utf-8');
  const schema: JsonSchema = JSON.parse(schemaContent);

  console.log('Generating TypeScript types...');

  // Configure json-schema-to-typescript options
  const options: Partial<Options> = {
    bannerComment: `/**
 * TypeScript type definitions for Convergence Domain Model
 *
 * Generated from: ${schema.$id}
 * Schema version: v0.1.0
 *
 * DO NOT EDIT MANUALLY - Generated by scripts/generate-domain-types.ts
 *
 * This file contains TypeScript type definitions for all domain model entities
 * defined in the convergence:domain@0.1.0 WIT package.
 */`,
    declareExternallyReferenced: false,
    enableConstEnums: true,
    format: true,
    strictIndexSignatures: true,
    style: {
      semi: true,
      singleQuote: true,
      trailingComma: 'es5',
    },
    unknownAny: false,
    unreachableDefinitions: false,
  };

  // Generate types for each definition
  const typeDefinitions: string[] = [];

  for (const [name, definition] of Object.entries(schema.definitions)) {
    try {
      const typeDef = await compile(
        {
          ...definition,
          $id: name,
          definitions: schema.definitions,
        },
        name,
        options
      );
      typeDefinitions.push(typeDef);
    } catch (error) {
      console.error(`Error generating type for ${name}:`, error);
      throw error;
    }
  }

  // Combine all type definitions
  const typesOutput = typeDefinitions.join('\n\n');

  console.log('Writing TypeScript types to:', TYPES_OUTPUT);
  writeFileSync(TYPES_OUTPUT, typesOutput);
  console.log('✓ TypeScript types generated successfully');
}

function generateZodValidators() {
  console.log('Generating Zod validators...');
  const schemaContent = readFileSync(SCHEMA_PATH, 'utf-8');
  const schema: JsonSchema = JSON.parse(schemaContent);

  // Determine dependency order
  const ordered = topologicalSort(schema.definitions);

  // Build Zod schemas programmatically from JSON Schema
  const validatorCode = `/**
 * Zod validation schemas for Convergence Domain Model
 *
 * Generated from: ${schema.$id}
 * Schema version: v0.1.0
 *
 * DO NOT EDIT MANUALLY - Generated by scripts/generate-domain-types.ts
 *
 * This file contains Zod validation schemas for runtime validation
 * of domain model entities.
 */

import { z } from 'zod';

${generateZodSchemasOrdered(schema.definitions, ordered)}

// Export all validators
export const DomainValidators = {
${ordered.map(name => `  ${toCamelCase(name)}: ${toCamelCase(name)}Schema,`).join('\n')}
};

// Helper function to validate any domain entity
export function validateDomainEntity<T>(
  schema: z.ZodSchema<T>,
  data: unknown
): { success: true; data: T } | { success: false; error: z.ZodError } {
  const result = schema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return { success: false, error: result.error };
}
`;

  console.log('Writing Zod validators to:', VALIDATORS_OUTPUT);
  writeFileSync(VALIDATORS_OUTPUT, validatorCode);
  console.log('✓ Zod validators generated successfully');
}

function topologicalSort(definitions: Record<string, any>): string[] {
  const graph: Map<string, Set<string>> = new Map();
  const inDegree: Map<string, number> = new Map();

  // Build dependency graph
  for (const name of Object.keys(definitions)) {
    graph.set(name, new Set());
    inDegree.set(name, 0);
  }

  for (const [name, def] of Object.entries(definitions)) {
    const deps = extractDependencies(def);
    for (const dep of deps) {
      if (dep !== name && graph.has(dep)) {
        graph.get(dep)!.add(name);
        inDegree.set(name, (inDegree.get(name) || 0) + 1);
      }
    }
  }

  // Kahn's algorithm for topological sort
  const queue: string[] = [];
  const result: string[] = [];

  for (const [name, degree] of inDegree.entries()) {
    if (degree === 0) {
      queue.push(name);
    }
  }

  while (queue.length > 0) {
    const current = queue.shift()!;
    result.push(current);

    for (const neighbor of graph.get(current) || []) {
      const newDegree = (inDegree.get(neighbor) || 0) - 1;
      inDegree.set(neighbor, newDegree);
      if (newDegree === 0) {
        queue.push(neighbor);
      }
    }
  }

  // Add any remaining nodes that have cycles (in-degree > 0)
  for (const [name, degree] of inDegree.entries()) {
    if (degree > 0 && !result.includes(name)) {
      result.push(name);
    }
  }

  return result;
}

function extractDependencies(schema: any): string[] {
  const deps: string[] = [];

  function traverse(obj: any) {
    if (!obj || typeof obj !== 'object') return;

    if (obj.$ref && typeof obj.$ref === 'string') {
      const refName = obj.$ref.replace('#/definitions/', '');
      deps.push(refName);
    }

    if (Array.isArray(obj)) {
      obj.forEach(traverse);
    } else {
      Object.values(obj).forEach(traverse);
    }
  }

  traverse(schema);
  return deps;
}

function generateZodSchemasOrdered(definitions: Record<string, any>, orderedNames: string[]): string {
  const schemas: string[] = [];

  // Generate schemas in dependency order
  for (const name of orderedNames) {
    const def = definitions[name];
    schemas.push(generateZodSchema(name, def, definitions));
  }

  return schemas.join('\n\n');
}

function generateZodSchema(name: string, definition: any, allDefinitions: Record<string, any>): string {
  const schemaName = `${toCamelCase(name)}Schema`;
  const zodCode = jsonSchemaToZod(definition, allDefinitions, new Set());

  return `// ${name}\nexport const ${schemaName} = ${zodCode};`;
}

function jsonSchemaToZod(schema: any, allDefinitions: Record<string, any>, visited: Set<string>): string {
  // Handle $ref
  if (schema.$ref) {
    const refName = schema.$ref.replace('#/definitions/', '');
    return `${toCamelCase(refName)}Schema`;
  }

  // Handle oneOf (discriminated unions)
  if (schema.oneOf) {
    const variants = schema.oneOf.map((s: any) => jsonSchemaToZod(s, allDefinitions, visited));
    return `z.union([${variants.join(', ')}])`;
  }

  // Handle type arrays (nullable types)
  if (Array.isArray(schema.type)) {
    if (schema.type.includes('null') && schema.type.length === 2) {
      const nonNullType = schema.type.find((t: string) => t !== 'null');
      const baseSchema = jsonSchemaToZod({ ...schema, type: nonNullType }, allDefinitions, visited);
      return `${baseSchema}.nullable()`;
    }
  }

  // Handle primitive types
  switch (schema.type) {
    case 'string':
      let stringSchema = 'z.string()';
      if (schema.format === 'email') stringSchema += '.email()';
      if (schema.format === 'uuid') stringSchema += '.uuid()';
      if (schema.format === 'date-time') stringSchema += '.datetime()';
      if (schema.const) stringSchema = `z.literal('${schema.const}')`;
      if (schema.enum) {
        const enumValues = schema.enum.map((v: string) => `'${v}'`).join(', ');
        stringSchema = `z.enum([${enumValues}])`;
      }
      return stringSchema;

    case 'number':
      let numberSchema = 'z.number()';
      if (schema.minimum !== undefined) numberSchema += `.min(${schema.minimum})`;
      if (schema.maximum !== undefined) numberSchema += `.max(${schema.maximum})`;
      return numberSchema;

    case 'integer':
      let intSchema = 'z.number().int()';
      if (schema.minimum !== undefined) intSchema += `.min(${schema.minimum})`;
      if (schema.maximum !== undefined) intSchema += `.max(${schema.maximum})`;
      return intSchema;

    case 'boolean':
      return 'z.boolean()';

    case 'null':
      return 'z.null()';

    case 'array':
      if (schema.items) {
        // Tuple array
        if (Array.isArray(schema.items)) {
          const itemSchemas = schema.items.map((item: any) => jsonSchemaToZod(item, allDefinitions, visited));
          return `z.tuple([${itemSchemas.join(', ')}])`;
        }
        // Regular array
        const itemSchema = jsonSchemaToZod(schema.items, allDefinitions, visited);
        return `z.array(${itemSchema})`;
      }
      return 'z.array(z.unknown())';

    case 'object':
      if (schema.properties) {
        const props = Object.entries(schema.properties).map(([key, propSchema]: [string, any]) => {
          const zodProp = jsonSchemaToZod(propSchema, allDefinitions, visited);
          const isRequired = schema.required?.includes(key);
          const propKey = key.includes('-') ? `'${key}'` : key;
          return `  ${propKey}: ${zodProp}${isRequired ? '' : '.optional()'}`;
        });

        const objectSchema = `z.object({\n${props.join(',\n')}\n})`;
        return schema.additionalProperties === false ? `${objectSchema}.strict()` : objectSchema;
      }
      return 'z.object({})';

    default:
      return 'z.unknown()';
  }
}

function toCamelCase(str: string): string {
  return str
    .split('-')
    .map((word, index) =>
      index === 0
        ? word
        : word.charAt(0).toUpperCase() + word.slice(1)
    )
    .join('');
}

async function main() {
  try {
    console.log('=== Convergence Domain Type Generator ===\n');

    await generateTypes();
    console.log();

    generateZodValidators();
    console.log();

    console.log('=== Generation Complete ===');
    console.log('\nGenerated files:');
    console.log('  - ' + TYPES_OUTPUT);
    console.log('  - ' + VALIDATORS_OUTPUT);
  } catch (error) {
    console.error('Error during generation:', error);
    process.exit(1);
  }
}

main();
